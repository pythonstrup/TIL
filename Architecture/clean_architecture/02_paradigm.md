# Chapter02 벽돌부터 시작하기: 프로그래밍 패러다임

- 패러다임이란 프로그래밍을 하는 방법으로, 대체로 언에는 독립적이다.
  - 어떤 프로그래밍 구조를 사용할지, 그리고 언제 이 구조를 사용해야 하는지를 결정한다.

---

## 3장 개요

### 구조적 프로그래밍

> 제어흐름의 직접적인 전환에 대해 규칙을 부과한다.

- `if`/`then`/`else`와 `do`/`while`/`until` 구조 사용.

### 객체 지향 프로그래밍

> 제어흐름의 간접적인 전환에 대해 규칙을 부과한다.

- 위 요약은 객체 지향의 다형성을 염두에 두고 한 말일 것.

### 함수형 프로그래밍

> 할당문에 대해 규칙을 부과한다.

### 생각할 거리

- 패러다임은 무엇을 해야 할지를 말하기보다는 무엇을 해서는 안 되는지를 말해준다.
  - 세 패러다임 각각은 goto문, 함수 포인터, 할당문을 앗아간다.

---

## 4장 구조적 프로그래밍

- 데이크스트라는 프로그램을 증명하는 유클리드 계층구조를 만들고자 했다. 
- 뵘과 야코피니는 모든 프로그램은 `순차 sequence`, `분기 selection`, `반복 iteration`이라는 세 가지 구조만으로 표현할 수 있다는 사실을 증명했다.
- 데이크스트라의 증명
  - 순차: 각 순차 구문의 입력을 순차 구문의 출력까지 수학적으로 추적. (일반적인 수학 증명과 동일)
  - 분기: 열거법을 재적용하는 방식으로 처리. 분기를 통한 각 경로를 열거하고, 결과적으로 두 경로가 수학적으로 적절한 결과를 만들어낸다면, 증명은 신뢰할 수 있게 된다.
  - 반복: 귀납법 사용. 열거법 사용.

### 기능적 분해

- 구조적 프로그래밍을 통해 모듈을 증명 가능한 더 작은 단위로 재귀적으로 분해할 수 있게 되었다.
  - 이는 결국 모듈을 기능적으로 분해할 수 있음을 뜻했다.

### 엄밀한 증명은 없었다.

- 끝내 증명은 이루어지지 않았다.
- 프로그램 관점에서 정리에 대한 유클리드 계층구조는 끝내 만들어지지 않았다.
- 하지만 상당히 성공한 또 다른 전략이 있다. `과학적 방법 scientific method`

### 과학이 구출하다

- 과학 이론과 법칙은 그 올바름을 절대 증명할 수 없다. (근본적으로 수학과 다른 점)
  - 과학적인 반증은 가능하지만 증명은 불가능.
  - 과학은 서술된 내용이 사실임을 증명하는 방식이 아니라 서술이 틀렸음을 증명하는 방식으로 동작.

### 테스트

> 테스트는 버그가 있음을 보여줄 뿐, 버그가 없음을 보여줄 수는 없다.
> - 데이크스트라

- 이말은 소프트웨어 개발이 수학적 시도가 아닌 과학과 같다는 것을 뜻한다. (테스트 = 반증)

---

## 5장 객체 지향 프로그래밍

- OO(Object-Oriented)는 세 가지 개념을 적절하게 조합한 것.
1. 캡슐화
2. 상속
3. 다형성

### 캡슐화

- 구분 짓는 선을 그어 데이터는 은닉하고, 일부 함수만 외부에 노출.
  - 이는 C 언어에서 완벽하게 가능
- 하지만 C++이 등장하면서 완벽한 캡슐화는 깨지게 됨. 헤더 파일을 통해 멤버 변수가 존재한다는 사실을 알 수 있게 되어버렸기 때문.
  - 다만, 멤버 변수에 대한 직접적인 접근은 컴파일러가 막아줄 것이다.
- 자바와 C#은 헤더와 구현체를 분리하는 방식을 모두 버려, 캡슐화는 더욱 심하게 훼손.
  - 이 때문에 OO 언어가 강력한 캡슐화에 의존한다는 정의는 받아들이기 어렵다.

### 상속

- 상속만큼은 OO 언어가 확실히 제공.
- 멤버 변수의 순서를 동일하게 정의함으로써 C언어에서도 가능 => 실제로 C++에서는 이 방법을 이용해 단일 상속 구현
- OO 언어에서는 업캐스팅이 암묵적으로 이뤄진다. (C언어에서는 타입을 강제로 변환해야 함.)

### 다형성

- C언어의 `STDIN`과 `STDOUT` 그리고 `FILE`.

```c
struct FILE {
  // ...
  int (*read)();
  // ...
}
```

- `getchart()`는 `STDIN`으로 참조되는 `FILE` 데이터 구조의 `read` 포인터가 가리키는 함수를 단순히 호출할 뿐이다.

```c
extern struct FILE* STDIN;

int getchar() {
  return STDIN->read();
}
```

- 즉, 함수를 가리키는 포인터를 활용해 다형성을 구현.
  - 함수 포인터는 위험하다. '포인터를 초기화해야 한다', '포인터를 통해 모든 함수를 호출해야 한다'는 관례를 지키지 않으면 버그가 발생하고, 이 버그는 찾아내고 없애기가 지독히도 힘들다. 
- OO 언어는 다형성을 좀 더 안전하고 더욱 편리하게 사용할 수 있게 해준다.

#### 의존성 역전

- 보통 고수준 -> 저수준 호출로 의존성의 방향이 흐름.
  - 제어흐름은 시스템의 행위에 따라 결정되며, 소스 코드의 의존성은 제어흐름에 따라 결정된다.
  - 하지만 다형성이 끼어들면 무언가 특별한 일이 일어난다.
- `의존성 역전 dependency inversion`을 통해 의존성을 뒤집을 수 있다.
  - 소스 코드 의존성이 제어흐름의 방향과 일치되도록 제한되지 않는다.
- 실무에서는?
  - UI와 데이터베이스가 업무 규칙의 플러그인이 된다는 뜻이다.
  - 이를 통해 `배포 독립성 independent deployability`과 `개발 독립성 independent developability`를 보장할 수 있다.

---

## 6장 함수형 프로그래밍

- 람다 계산법이 그 시초.

### 불변성과 아키텍처

- 왜 가변성을 염려하는가? 
  - `경합 조건 race condition`과 `교착 상태 deadlock`, `동시 업데이트 concurrent update` 문제가 모두 가변 변수로 인해 발생하기 때문.

### 가변성의 분리

- 불변성과 관련하여 가장 주요한 타협 중 하나. 가변 컴포넌트와 불변 컴포넌트로 분리하는 일.
  - 불변 컴포넌트는 순수하게 함수형 방식으로만 작업이 처리되며, 어떤 가변 변수도 사용되지 않는다.
- 상태 변경은 컴포넌트가 갖가지 동시성 문제에 노출하는 꼴이므로, 흔히 `트랜잭션 메모리 transactional memory`와 같은 실천법을 통해 동시 업데이트와 경합 조건 문제로부터 가변 변수를 보호.
- 현명한 아키텍트라면 가능한 한 많은 처리를 불변 컴포넌트로 옮겨야 하고, 가변 컴포넌트에서는 가능한 한 많은 코드를 빼내야 한다.

### 이벤트 소싱

- 이벤트 소싱은 상태가 아닌 트랜잭션을 저장하자는 전략이다.
  - 상태가 필요해지면 단순히 상태의 시작점부터 모든 트랜잭션을 처리.
- 이제 이 전략에 필요한 데이터 저장소를 생각. 아마 저장 공간이 많이 필요.
  - 더 중요한 점은 데이터 저장소에서 삭제되거나 변경되는 것이 하나도 없다는 사실. (CRUD가 아닌 CR만 수행)
  - 이러면 동시성 문제 또한 일어나지 않는다.
- 소스 코드 버전 관리 시스템이 정확히 이 방식으로 동작한다고 함.

---

## 정리

도구도 달라졌고 하드웨어도 변했지만, 소프트웨어의 핵심은 여전히 그대로다. 순차, 분기, 반속, 참조로 구성된다. 그 이상도 이하도 아니다.

---

# 참고자료

- 클린 아키텍처, 로버트 C. 마틴
