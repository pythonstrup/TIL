# 5부 아키텍처

## 15장 아키텍처란?

> 소프트웨어 아키텍트라면 코드에서 탈피하여 고수준의 문제에 집중해야 한다는 거짓말에 절대로 속아 넘어가서는 안 된다.
> 소프트웨어 아키텍트는 코드와 동떨어져서는 안 된다.

- 초점은 항상 '생산성 극대화'
- 소프트웨어 시스템의 아키텍처란? 시스템을 구축했던 사람들이 만들어낸 시스템의 형태
  - 그 모양은 시스템을 컴포넌트로 분할하는 방법, 분할된 컴포넌트를 배치하는 방법, 컴포넌트가 서로 의사소통하는 방식에 따라 정해진다.
  - 그리고 그 형태는 아키텍처 안에 담긴 소프트웨어 시스템이 쉽게 개발, 배포, 운영, 유지보수되도록 만들어진다.

> 이러한 일을 용이하게 만들기 위해서는 가능한 한 많은 선택지를, 가능한 한 오래 남겨두는 전략을 따라야 한다.

> 아키텍처의 주된 목적은 시스템의 생명주기를 지원하는 것이다.
> 시스템의 수명과 관련된 비용은 최소화하고, 프로그래머의 생산성은 최대화하는 데 있다.

### 개발

- 팀 구조 -> 아키텍처 관련 결정에서도 차이가 난다.
  - 소규모 팀은 아키텍처 관련 제약이 오히려 방해가 된다고 여길 수 있음.
  - 수많은 시스템에서 좋은 아키텍처가 결여된 이유는 바로 이 때문이다.

### 배포

- 배포 비용이 높을수록 시스템의 유용성은 떨어진다.
- 프로젝트 초기에 '마이크로서비스'를 채택했다고 가정.
  - 위협적일만큼 늘어난 수많은 마이크로서비스를 발견하게 될지도? -> 서로 연결하기 위해 설정하고 작동 순서를 결정하는 과정에서 오작동이 발생할 원천이 스며들 수 있다. 
  - 배포 문제를 고려한다면 더 적은 서비스를 사용하고, 서비스 컴포넌트와 프로세스 수준의 컴포넌트를 하이브리드로 융합하며, 더 통합된 도구를 사용하여 상호 연결을 관리

### 운영

- 아키텍처가 미치는 영향이 개발, 배포, 유지보수보다는 덜 극적이다.
  - 하드웨어를 더 투입해서 해결할 수 있기 때문. (아키텍처가 만약 비효율적이라면 말이다.)

> 좋은 아키텍처는 시스템을 운영하는 데 필요한 요구도 알려준다.

### 유지보수

- 유지보수는 소프트웨어에서 비용이 가장 많이 발생하는 곳.
  - 새로운 기능 -> 결함 -> 결험 수정
  - 그 중 가장 큰 비용은 `탐사 spelunking`. 기존의 소프트웨어에 새로운 기능을 추가하거나 결함을 수정할 때, 소프트웨어를 파헤쳐서 어디를 고치는 게 최선인지, 그리고 어떤 전략을 쓰는 게 최적일지를 결정할 때 드는 비용
  - 의도치 않은 결함이 발생할 가능성은 항상 존재.

### 선택사항 열어 두기

- 소프트웨어의 두 가지 가치
1. 행위적 가치
2. 구조적 가치

- 이 중 구조적 가치가 더 중요. 소프트웨어를 soft하게 만드는 것이기 때문이다.
  - 부드럽게 유지하는 방법? 선택사항을 가능한 한 많이, 그리고 가능한 한 오랫동안 열어 두는 것이다.
  - 열어 둬야 하는 선택사항이란? 중요치 않은 세부사항
- 모든 소프트웨어 시스템의 주요한 두 가지 구성요소
1. `정책 policy`: 모든 업무 규칙과 업무 절차를 구체화. 시스템의 진정한 가치가 살아 있는 곳.
2. `세부사항 detail`: 사람, 외부 시스템, 프로그래머가 정책과 소통할 때 필요한 요소지만, 정책이 가진 행위에는 조금도 영향을 미치지 않는다. (ex-입출력 장치, 데이터베이스, 서버, 프레임워크, 프로토콜 등)

> 아키텍트의 목표는 시스템에서 정책을 가장 핵심적인 요소로 식별하고, 동시에 세부사항은 정책에 무관하게 만들 수 있는 형태의 시스템을 구축하는 데 있다.
> 이를 통해 세부사항을 결정하는 일을 미루거나 연기할 수 있다.

> 선택사항을 오랫동안 열어둘 수 있다면 더 많은 실험을 해볼 수 있고 더 많은 것을 시도할 수 있다.
> 그리고 결정을 더 이상 연기할 수 없는 순간이 닥쳤을 때는 이러한 실험과 시도 덕분에 더 많은 정보를 획득한 상태일 것이다.

> 좋은 아키텍트는 결정되지 않은 사항의 수를 최대화한다.

### 장치 독립성

- 예전의 소프트웨어 예시. 오직 카드 판독기와 카드 천공기에서만 작동하는 소프트웨어.
  - `장치 종속적 device dependent`
- 1960년대 후반에 이르러서야 교휸을 얻고 `장치 독립성 device independence`을 생각해냄.

### 광고 우편

- 자기테이프, 라인 프린터 각각 호환되는 프로그램을 만듦.
- 정책은 이름과 주소 레코드에 대한 서식.
- 세부사항은 장치.

### 물리적 주소 할당

- 고수준의 정책이 디스크의 물리적인 구조에 종속적이었던 예시
  - 200개의 실린더와 10개의 헤드로 구성, 각 실린더는 헤드별로 수십 개의 섹터로 구성. 
  - 어느 실린더가 `Agent`, `Employer`, `Member`를 포함하는지 알게 되었고, 이러한 정보가 모두 하드코딩됨.
  - 레코드에 실린더 번호, 헤더 번호, 섹터 번호를 포함했다고 한다 (??!?!)
- 그런데 헤더가 더 많거나 실린더가 더 많은, 또는 실린더당 섹터가 더 많은 새로운 디스크 드라이브로 업그레이드해야 한다면??
  - 실린더/헤드/섹터 번호를 마이그레이션해야 한다. 하드 코딩도 많았다고 하니, 그 많은 코드를 수정해야 한다.
- 상대 주소를 사용하라는 충고.
  - 각 섹터 주소는 순차적인 정수를 이용해 지정 가능. 디스크를 이러한 섹터로 구성된 하나의 거대한 선형 배열 취급.

----

## 16장 독립성

- 좋은 아키텍처는 다음을 지원해야 한다.
1. 시스템의 유스케이스
2. 시스템의 운영
3. 시스템의 개발
4. 시스템의 배포

### 유스케이스

- 시스템의 의도를 지원해야 한다는 뜻.
- 하지만 아키텍처는 시스템의 행위에 그다지 큰 영향을 주지 않는다.
  - 행위와 관련하여 아키텍처가 열어 둘 수 있는 선택사항은 거의 없다.
- 하지만 영향이 전부는 아니다. 좋은 아키텍처가 행위를 지원하기 위해 할 수 있는 일 중에서 가장 중요한 사항은 행위를 명확히 하고 외부로 드러내며, 이를 통해 시스템이 지닌 의도를 아키텍처 수준에서 알아볼 수 있게 만드는 것이다.

### 운영

- 시스템이 단일체로 작성되어 모놀리틱 구조를 갖는다면, 다중 프로세스, 다중 스레드, 또는 마이크로서비스 형태가 필요해질 때 개선하기가 어렵다.
- 아키텍처에서 각 컴포넌트를 적절히 격리하여 유지하고 컴포넌트 간 통신 방식을 특정 형태로 제한하지 않는다면, 시간이 지나 운영에 필요한 요구사항이 바뀌더라도 스레드, 프로세스, 서비스로 구성된 기술 스펙트럼 사이를 전환하는 일이 훨씬 쉬워질 것이다.

### 개발

- 아키텍처는 개발환경을 지원하는 데 있어 핵심적인 역할 수행.
- `콘웨이의 법칙 Conway's Law`

> 시스템을 설계하는 조직이라면 어디든지 그 조직의 의사소통 구조와 동일한 구조의 설계를 만들어낼 것이다.

- 많은 팀 구성 -> 독립적인 컴포넌트로 만들어 잘 격리되게끔 해야 한다.

### 배포

- 아키텍처는 배포 용이성을 결정하는 데 중요한 역할을 한다.
  - 이때 목표는 `즉각적인 배포 immediate deployment`
  - 좋은 아키텍처는 수십 개의 작은 설정 스크립트나 속성 파일을 약간씩 수정하는 방식을 사용하지 않는다.
  - 좋은 아키텍처는 꼭 필요한 디렉터리나 파일을 수작업으로 생성하게 내버려 두지 않는다.
  - 좋은 아키텍처라면 시스템이 빌드된 후 즉각 배포할 수 있도록 지원해야 한다.
- 이러한 아키텍처를 만들려면 시스템을 컴포넌트 단위로 적절하게 분할하고 격리시켜야 한다.
  - 여기에는 마스터 컴포넌트도 포함되는데, 마스터 컴포넌트는 시스템 전체를 하나로 묶고, 각 컴포넌트를 올바르게 구동하고 통합하고 관리해야 한다.

### 선택사항 열어놓기

- 좋은 아키텍처는 컴포넌트 구조와 관련된 이 관심사들 사이에서 균형을 맞추고, 각 관심사 모두를 만족시킨다. <s>말은 쉽다.</s>
  - 현실에서 이러한 균형을 잡기가 매우 어렵다. 대부분의 경우 모든 유스케이스를 알 수는 없으며, 운영하는 데 따르는 제약사항, 팀 구조, 배포 요구사항도 알지 못하기 때문이다.
  - 더 심각한 문제는 이러한 사항들을 알고 있더라도, 시스템이 생명주기의 단계를 하나씩 거쳐감에 따라 이 사항들도 반드시 변해간다는 사실이다.
  - 우리가 도달하려는 목표는 뚜렷하지 않을 뿐만 아니라 시시각각 변한다.
- 이런 변화 속에서도 사라지지 않는 것! 아키텍처 원칙!

### 계층 결합 분리

- 아키텍트는 필요한 모든 유스케이스를 지원할 수 있는 시스템 구조를 원하지만, 유스케이스 전부를 알지는 못한다.
  - 하지만 아키텍트는 시스템의 기본적인 의도는 분명히 알고 있다.
  - 단일 책임 원칙과 공통 폐쇄 원칙을 적용하여, 그 의도의 맥락에 따라서 다른 이유로 변경되는 것들을 분리하고, 동일한 이유로 변경되는 것들을 묶는다.
- 서로 다른 이유로 변경되는 것은 무엇일까?
  - 사용자 인터페이스가 변경되는 이유는 업무 규칙과는 아무런 관련이 없다.
  - 뛰어난 아키텍트는 유스케이스에서 UI 부분과 업무 규칙 부분을 서로 분리하고자 할 것이다. => 이렇게 함으로써 두 요소를 서로 독립적으로 변경 가능, 유스케이스는 여전히 가시적이며 분명하게 유지 가능.

### 유스케이스 결합 분리

- 서로 다른 이유로 변경되는 것에는 또 무엇이 있을까? 유스케이스 그 자체.
  - 유스케이스는 시스템을 분할하는 매우 자연스러운 방법
- 유스케이스는 시스템의 수평적인 계층을 가로지르도록 자른, 수직으로 좁다란 조각.
  - UI의 일부, 애플리케이션 특화 업무 규칙의 일부, 애플리케이션 독립적 업무 규칙의 일부, 그리고 데이터베이스 기능의 일부를 사용.
- 따라서 우리는 시스템을 수평적 계층으로 분할하면서 동시에 해당 계층을 가로지르는, 얇은 수직적인 유스케이스로 시스템을 분할할 수 있다.

### 결합 분리 모드

- 이렇게 결합을 분리하면 운영 관점에서 어떤 의미가 있을까?
  - 유스케이스에서 서로 다른 `관점 Aspect`이 분리 되었다면, 높은 처리량을 보장해야 하는 유스케이스와 낮은 처리량으로도 충분한 유스케이스는 이미 분리되어 있을 가능성이 높다.
  - 높은 대역폭을 요구하는 유스케이스는 여러 서버로 복제하여 실행할 수 있다는 말이다.
- 운영 측면의 이점을 살리기 위해선 결합을 분리할 때 적절한 모드를 선택해야 한다.
  - 서로 다른 서버에서 실행되어야 한다면? => 분리된 컴포넌트는 반드시 독립된 서비스가 되어야 하고, 일종의 네트워크를 통해 서로 통신해야 한다.
  - 마이크로서비스. `서비스 지향 아키텍처 service-oriented architecture`
  - SOA가 최선의 아키텍처라거나, 마이크로서비스가 미래라는 것은 아님. 핵심은, 우리는 때때로 컴포넌트를 서비스 수준까지도 분리해야 한다는 것이다.

### 개발 독립성

- 컴포넌트가 완전히 분리되면 팀 사이의 간섭은 줄어든다.

### 배포 독립성

- 유스케이스와 계층의 결합이 분리되면 배포 측면에서도 고도의 유연성이 생긴다.
  - 실제로 결합을 제대로 분리했다면 운영 중인 시스템에서도 계층과 유스케이스를 `교체 hot-swap`할 수 있다.

### 중복

- 중복에 대한 공포 -> 함정
- 중복은 일반적으로 나쁜 것. 하지만 중복에도 여러 종류가 있다. `진짜 중복`과 `우발적인 중복`
  - 중복으로 보이는 두 코드 영역이 각자의 경로로 발전한다면, 즉 서로 다른 속도와 다른 이유로 변경된다면 이 두 코드는 진짜 중복이 아니다.
  - 우발적 중복을 섣불리 통합하면, 나중에 분리하기 위해 더 많은 공수가 필요해질 수도 있다.

### 결합 분리 모드(다시)

- 계층과 유스케이스의 결합을 분리하는 방법은 다양하다.
1. `소스 코드 수준`: 소스 코드 모듈 사이의 의존성을 제어할 수 있다. 하나의 모듈이 변하더라도 다른 모듈을 변경하거나 재컴파일하지 않도록 만들 수 있다. 모든 컴포넌트가 같은 주소 공간에서 실행. 서로 통신할 때는 간단한 함수 호출을 사용. 컴퓨터 메모리에는 하나의 실행 파일만이 로드. 모놀리틱 구조.
2. `바이너리 코드 수준 (배포)`: jar 파일, DLL, 공유 라이브러리와 같이 배포 가능한 단위들 사이의 의존성을 제어할 수 있다. 한 모듈의 소스 코드가 변하더라도 다른 모듈을 재빌드하거나 재배포하지 않도록 할 수 있다. 많은 컴포넌트가 여전히 같은 공간에 상주, 단순한 함수 호출을 통해 통신 가능. 어떤 컴포넌트는 다른 프로세스에 상주하여 프로세스 간 통신, 소켓 또는 공유 메모리를 통해 통신할 수 있다.
3. `실행 단위 수준 (서비스)`: 의존하는 수준을 데이터 구조 단위까지 낮출 수 있고, 순전히 네트워크 패킷을 통해서만 통신하도록 만들 수 있다. 실행 가능한 단위는 소스와 바이너리 변경에 대해 완전히 독립적.

- 프로젝트 초기에는 어떤 것이 최선인지 알기 어렵다는 게 답이다.
  - 프로젝트가 성숙해갈수록 최적인 모드가 달라질 수 있다.
- 저자는 컴포넌트가 서비스화될 가능성이 있다면 컴포넌트 결합을 분리하되 서비스가 되기 직전에 멈추는 방식을 선호
  - 그러고는 컴포넌트들을 가능한 한 오랫동안 동일한 주소 공간에 남겨둔다. 이를 통해 서비스에 대한 선택권을 열어둘 수 있다.
- 좋은 아키텍처는 시스템이 모노리틱 구조로 태어나서 단일 파일로 배포되더라도, 이후에는 독립적으로 배포 가능한 단위들의 집합으로 성장하고, 또 독립적인 서비스나 마이크로서비스 수준까지 성장할 수 있도록 만들어져야 한다.
- 좋은 아키텍처라면 나중에 상황이 바뀌었을 때 이 진행 방향을 거꾸로 돌려 원래 형태인 모노리틱 구조로 되돌릴 수도 있어야 한다.
- 좋은 아키텍처는 이러한 변경으로부터 소스 코드 대부분을 보호한다.
- 좋은 아키텍처는 결합 분리 모드를 선택사항으로 남겨두어서 배포 규모에 따라 가장 적합한 모드를 선택해 사용할 수 있게 만들어 준다.


