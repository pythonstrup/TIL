# 5부 아키텍처

## 15장 아키텍처란?

> 소프트웨어 아키텍트라면 코드에서 탈피하여 고수준의 문제에 집중해야 한다는 거짓말에 절대로 속아 넘어가서는 안 된다.
> 소프트웨어 아키텍트는 코드와 동떨어져서는 안 된다.

- 초점은 항상 '생산성 극대화'
- 소프트웨어 시스템의 아키텍처란? 시스템을 구축했던 사람들이 만들어낸 시스템의 형태
  - 그 모양은 시스템을 컴포넌트로 분할하는 방법, 분할된 컴포넌트를 배치하는 방법, 컴포넌트가 서로 의사소통하는 방식에 따라 정해진다.
  - 그리고 그 형태는 아키텍처 안에 담긴 소프트웨어 시스템이 쉽게 개발, 배포, 운영, 유지보수되도록 만들어진다.

> 이러한 일을 용이하게 만들기 위해서는 가능한 한 많은 선택지를, 가능한 한 오래 남겨두는 전략을 따라야 한다.

> 아키텍처의 주된 목적은 시스템의 생명주기를 지원하는 것이다.
> 시스템의 수명과 관련된 비용은 최소화하고, 프로그래머의 생산성은 최대화하는 데 있다.

### 개발

- 팀 구조 -> 아키텍처 관련 결정에서도 차이가 난다.
  - 소규모 팀은 아키텍처 관련 제약이 오히려 방해가 된다고 여길 수 있음.
  - 수많은 시스템에서 좋은 아키텍처가 결여된 이유는 바로 이 때문이다.

### 배포

- 배포 비용이 높을수록 시스템의 유용성은 떨어진다.
- 프로젝트 초기에 '마이크로서비스'를 채택했다고 가정.
  - 위협적일만큼 늘어난 수많은 마이크로서비스를 발견하게 될지도? -> 서로 연결하기 위해 설정하고 작동 순서를 결정하는 과정에서 오작동이 발생할 원천이 스며들 수 있다. 
  - 배포 문제를 고려한다면 더 적은 서비스를 사용하고, 서비스 컴포넌트와 프로세스 수준의 컴포넌트를 하이브리드로 융합하며, 더 통합된 도구를 사용하여 상호 연결을 관리

### 운영

- 아키텍처가 미치는 영향이 개발, 배포, 유지보수보다는 덜 극적이다.
  - 하드웨어를 더 투입해서 해결할 수 있기 때문. (아키텍처가 만약 비효율적이라면 말이다.)

> 좋은 아키텍처는 시스템을 운영하는 데 필요한 요구도 알려준다.

### 유지보수

- 유지보수는 소프트웨어에서 비용이 가장 많이 발생하는 곳.
  - 새로운 기능 -> 결함 -> 결험 수정
  - 그 중 가장 큰 비용은 `탐사 spelunking`. 기존의 소프트웨어에 새로운 기능을 추가하거나 결함을 수정할 때, 소프트웨어를 파헤쳐서 어디를 고치는 게 최선인지, 그리고 어떤 전략을 쓰는 게 최적일지를 결정할 때 드는 비용
  - 의도치 않은 결함이 발생할 가능성은 항상 존재.

### 선택사항 열어 두기

- 소프트웨어의 두 가지 가치
1. 행위적 가치
2. 구조적 가치

- 이 중 구조적 가치가 더 중요. 소프트웨어를 soft하게 만드는 것이기 때문이다.
  - 부드럽게 유지하는 방법? 선택사항을 가능한 한 많이, 그리고 가능한 한 오랫동안 열어 두는 것이다.
  - 열어 둬야 하는 선택사항이란? 중요치 않은 세부사항
- 모든 소프트웨어 시스템의 주요한 두 가지 구성요소
1. `정책 policy`: 모든 업무 규칙과 업무 절차를 구체화. 시스템의 진정한 가치가 살아 있는 곳.
2. `세부사항 detail`: 사람, 외부 시스템, 프로그래머가 정책과 소통할 때 필요한 요소지만, 정책이 가진 행위에는 조금도 영향을 미치지 않는다. (ex-입출력 장치, 데이터베이스, 서버, 프레임워크, 프로토콜 등)

> 아키텍트의 목표는 시스템에서 정책을 가장 핵심적인 요소로 식별하고, 동시에 세부사항은 정책에 무관하게 만들 수 있는 형태의 시스템을 구축하는 데 있다.
> 이를 통해 세부사항을 결정하는 일을 미루거나 연기할 수 있다.

> 선택사항을 오랫동안 열어둘 수 있다면 더 많은 실험을 해볼 수 있고 더 많은 것을 시도할 수 있다.
> 그리고 결정을 더 이상 연기할 수 없는 순간이 닥쳤을 때는 이러한 실험과 시도 덕분에 더 많은 정보를 획득한 상태일 것이다.

> 좋은 아키텍트는 결정되지 않은 사항의 수를 최대화한다.

### 장치 독립성

- 예전의 소프트웨어 예시. 오직 카드 판독기와 카드 천공기에서만 작동하는 소프트웨어.
  - `장치 종속적 device dependent`
- 1960년대 후반에 이르러서야 교휸을 얻고 `장치 독립성 device independence`을 생각해냄.

### 광고 우편

- 자기테이프, 라인 프린터 각각 호환되는 프로그램을 만듦.
- 정책은 이름과 주소 레코드에 대한 서식.
- 세부사항은 장치.

### 물리적 주소 할당

- 고수준의 정책이 디스크의 물리적인 구조에 종속적이었던 예시
  - 200개의 실린더와 10개의 헤드로 구성, 각 실린더는 헤드별로 수십 개의 섹터로 구성. 
  - 어느 실린더가 `Agent`, `Employer`, `Member`를 포함하는지 알게 되었고, 이러한 정보가 모두 하드코딩됨.
  - 레코드에 실린더 번호, 헤더 번호, 섹터 번호를 포함했다고 한다 (??!?!)
- 그런데 헤더가 더 많거나 실린더가 더 많은, 또는 실린더당 섹터가 더 많은 새로운 디스크 드라이브로 업그레이드해야 한다면??
  - 실린더/헤드/섹터 번호를 마이그레이션해야 한다. 하드 코딩도 많았다고 하니, 그 많은 코드를 수정해야 한다.
- 상대 주소를 사용하라는 충고.
  - 각 섹터 주소는 순차적인 정수를 이용해 지정 가능. 디스크를 이러한 섹터로 구성된 하나의 거대한 선형 배열 취급.

----

## 16장 독립성

