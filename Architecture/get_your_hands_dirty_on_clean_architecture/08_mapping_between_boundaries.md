# Chapter08. 경계 간 매핑하기

#### 매핑에 찬성하는 개발자

- 두 계층 간에 매핑을 하지 않으면 양 계층에서 같은 모델을 사용해야 하는데  이렇게 하면 두 계층이 강하게 결합

#### 매핑에 반대하는 개발자

- 하지만 두 계층 간에 매핑을 하게 되면 보일러 플레이트 코드를 너무 많이 만들게 된다.
- 많은 유스케이스들이 오직 CRUD만 수행하고 계층에 걸쳐 같은 모델을 사용하기 때문에 계층 사이의 매핑은 과하다.

## '매핑하지 않기' 전략 No Mapping

- `Account`라는 객체에 웹 계층, 애플리케이션, 영속성 계층까지 접근하게 만드는 방식이다.
- 도메인과 애플리케이션 계층은 웹이나 영속성과 관련된 특수한 요구사항에 관심이 없음에도 불구하고 아래와 같은 요구사항을 다뤄야 한다.
  - 웹 계층: REST로 모델을 노출시킨다면 모델을 JSON으로 직렬화하기 위한 어노테이션을 모델 클래스의 특정 필드에 붙여야 할 수도 있다.
  - 애플리케이션 계층: 비즈니스 모델을 다룬다.
  - 영속성 계층: ORM 프레임워크를 사용한다면 데이터베이스 매핑을 위한 특정 어노테이션이 필요할 것이다.
- 이는 `단일 책임 원칙`을 위반하는 것이다.
- 간단한 CRUD 유스케이스의 경우 '매핑하지 않기' 전략이 오히려 좋을 수도 있다.
- 간단한 CRUD 유스케이스로 시작해서 시간이 지남에 따라 값비싼 매핑 전략을 채택할 수도 있다.

## '양방향' 매핑 전략 Two-Way Mapping

- 각 계층은 도메인 모델과는 완전히 다른 구조의 전용 모델을 가진다.
  - 웹 계층: 웹 모델
  - 애플리케이션 계층: 도메인 모델
  - 영속성 계층: 영속성 모델
- 각 계층이 전용 모델을 가지고 있는 덕분에 각 계층이 전용 모델을 변경하더라도 다른 계층에는 영향이 없다. 아래와 같은 구조를 갖추기에 최적이다.
  - 웹 모델: 데이터를 최적으로 표현할 수 있는 구조.
  - 도메인 모델: 유스케이스를 제일 잘 구현할 수 있는 구조.
  - 영속성 모델: 데이터베이스에 객체를 저장하기 위해 ORM에서 필요로 하는 구조.
- 하지만 너무 많은 보일러플레이트 코드가 생긴다.
  - 코드의 양을 줄이기 위해 매핑 프레임워크를 사용하더라도 두 모델 간 매핑을 구현하는 데 꽤 시간이 든다.
  - 특히 매핑 프레임워크가 내부 동작 방식을 제네릭 코드와 리플렉션 뒤로 숨길 경우 매핑 로직을 디버깅하는 것은 꽤나 고통스럽다.
- 또 다른 단점은 도메인 모델이 계층 경계를 넘어서 통신하는 데 사용되고 있다는 것이다.
  - 인커밍 포트와 아웃고잉 포트는 도메인 객체를 입력 파라미터와 반환값으로 사용한다.
  - 바깥쪽 계층의 요구에 따른 변경에 취약해진다.
- 어떤 매핑 전략도 철칙처럼 여겨져서는 안 된다. 그 대신 각 유스케이스마다 적절한 전략을 택할 수 있어야 한다.

## '완전' 매핑 전략

- 이 매핑 전략은 각 연산마다 별도의 입출력 모델을 사용한다.
  - ex. `SendMoneyUseCase` 포트의 입력 모델로 `SendMoneyCommand`처럼 각 작업에 특화된 모델을 사용.
  - 이런 모델을 가리켜 `command` 혹은 `request`, 또는 그와 비슷한 단어로 표현한다.
- 각 유스케이스는 전용 필드와 유효성 검증 로직을 가진 전용 커맨드를 가진다.
  - 빈 필드를 허용하지 말자. 유스케이스에서는 쓸데없는 유효성 검증을 하게 둬선 안 된다.
- 이렇게 매핑하면 여러 유스케이스의 요구사항을 함께 다뤄야 하는 매핑에 비해 구현하고 유지보수하기가 훨씬 쉽다.
  - 이 매핑 전략은 전역 패턴으로 추천하지는 않는다.
  - 이 전략은 웹 계층과 애플리케이션 계층 사이에서 상태 변경 유스케이스의 경계를 명확하게 할 때 가장 빛을 발한다.
- 애플리케이션 계층과 영속성 계층 사이에서는 매핑 오버헤드 때문에 사용하지 않는 것이 좋다.
- 이처럼 매핑 전략은 여러 가지를 섞어서 써야만 한다.

## '단방향' 매핑 전략

- 이 전략에서는 모든 계층의 모델들이 같은 인터페이스를 구현한다.
- 도메인 객체를 바깥 계층으로 전달하고 싶을 때 매핑 없이 할 수 있다. 왜냐하면 도메인 객체가 인커밍/아웃고잉 포트가 기대하는 대로 상태 인터페이스를 구현하고 있기 때문이다.
- 바깥 계층에서는 상태 인터페이스를 사용할지, 전용 모델로 매핑해야 할지 결정할 수 있다.
  - 인터페이스에서는 도메인 모델의 행동을 노출하지 않기 때문에 실수로 도메인의 상태를 변경하는 일은 발생하지 않는다.

## 언제 어떤 매핑 전략을 사용할 것인가?

#### 변경 유스케이스

- 웹 계층과 애플리케이션 계층 사이에서는 유스케이스 간의 결합을 제거하기 위해 '완전 매핑'을 채택.
  - 유스케이스별 유효성 검증 규칙이 명확해짐.
  - 특정 유스케이스에서 필요하지 않은 필드를 다룰 필요가 없다.
- 애플리케이션과 영속성 계층 사이에서는 매핑 오버헤드를 줄이고 빠르게 코드를 짜기 위해 '매핑하지 않기'를 첫 번째 선택지로 둔다.
  - 하지만 '완전 매핑'을 통해 영속성 문제를 영속성 계층에 가둘 수도 있다.

#### 쿼리 작업

- 매핑 오버헤드를 줄이고 빠르게 코드를 짜기 위해 '매핑하지 않기 전략'이 첫 선택지.
  - '양방향' 매핑을 사용할 수도 있다.

<br/>

# 참고자료

- 만들면서 배우는 클린 아키텍처, 톰 홈버그 지음
