# Chapter 06 워크플로

- 분산 시스템에서의 워크플로 모델링과 구현

## 1. 데이터베이스 트랜잭션

### 1-1. ACID 트랜잭션

#### 원자성

- 트랜잭션 내에서 시도된 작업이 두 가지 상태, 즉 모두 완료한 상태거나 모두 실패한 상태인지 확인한다.
- 어떤 이유로든 시도한 변경이 실패하면 전체 연산이 중단되고 마치 아무것도 적용되지 않는 것처럼 보인다.

#### 일관성

- 데이터베이스가 변경되면, 유효하고 일관된 상태가 유지도니다.

#### 격리성

- 여러 트랜잭션이 간섭 없이 동시에 작동할 수 있다.
- 이는 어떤 트랜잭션 중에 이뤄진 모든 중간 상태 변경이 다른 트랜잭션에 안 보이게 하는 방법으로 달성된다.

#### 내구성

- 일단 트랜잭션이 완료되고 나면 시스템 오류가 발생하는 상황헤서도 데이터가 손실되지 않는 것을 보장한다.

### 1-2. 여전히 ACID이지만 원자성이 부족한가?

- 마이크로서비스를 분리할 대 ACID 방식의 트랜잭션은 여전히 사용 가능하다.
  - 서비스의 자기 데이터베이스에 대한 연산
- 하지만 각기 다른 데이터베이스를 변경해야 하는 순간 트랜잭션이 늘어난다.
  - 각 트랜잭션은 서로 독립적으로 작동하거나 실패할 수 있다.
  - 물론 고객 테이블에서 행을 변경할 수 있는 경우에만 등록보류 테이블에서 행을 제거하도록 두 트랜잭션의 순서를 정할 수는 있다.
  - 하지만 등록보류 테이블에서 삭제가 실패할 경우 어떻게 해야 할지 추론해야 한다.
- 이러한 원자성의 결여는 특히 직전에 이 속성에 의존했던 시스템을 마이그레이션하는 경우 심각한 문제가 발생할 수 있다.

<br/>

## 2. 분산 트랜잭션 - 2단계 커밋

- `2단계 커밋 알고리즘 Two-Phase Commit Algorithm`(줄여서 2PC)은 전체 작업의 일부로 여러 개별 프로세스를 업데이트해야 하는 분산 시스템에서 트랜잭션을 변경할 수 있는 기능을 제공하려는 시도로 자주 사용된다.
  - 문제를 해결할 수도. 시스템에 더 많은 혼란을 가져올 수도 있다.
- 2PC는 `투표 voting` 단계와 `커밋 commit` 단계라는 두 단계로 나뉜다.
- 투표 단계는 `중앙 조정자 coordinator`는 트랜잭션에 참가할 모든 `워커 worker`에 연락하고 일부 상태 변경이 가능한지 여부를 확인 요청하는 것을 말한다.
  - 워커가 변경할 수 있다고 알려준 직후에 변경 사항이 즉시 적용되지는 않는다. 즉시 적용되는 대신, 워커는 미래 어느 시점에서 그 변경을 수행할 수 있음을 보장하고 있다.
  - 상태의 변경을 나중에 수행할 수 있도록 보장하기 위해 변경이 일어나지 않도록 레코드를 잠가 놓는다.
  - 커밋에 찬성하지 않은 워커가 있는 경우, 모든 당사자에게 롤백 메시지를 보내 로컬에서 정리하도록 보장한다. 이때 잠금이 해제된다.
  - 모든 워커가 찬성한 경우 커밋 단계로 이동한다. 실제로 변경이 일어나고 이때도 잠금이 해제된다.
- 하지만 여러 참가자 간에 잠금을 조정하는 일은 쉽지 않다. (교착 상태를 피하기 위해)
  - 참여자가 많을수록, 시스템에서 지연 시간이 길수록 2단계 커밋은 더 많은 문제가 발생한다.

<br/>

## 3. 분산 트랜잭션 - 그냥 안 된다고 하라

- 2단계 커밋 같은 분산 트랜잭션은 비추.
- 대안?

1. 처음부터 데이터를 분리하지 않는 방법
2. 데이터를 분해해야 하지만, 분산 트랜잭션 관리에 따르는 모든 고통을 원치 않는다면? `사가 saga`라는 대안을 고려할 수 있다.

> #### 데이터베이스 분산 트랜잭션
> - 구글의 스패너(Spanner) - 대규모 데이터베이스 분산 트랜잭션 알고리즘
> - 분산 트랜잭션은 하부의 데이터베이스에 의해 애플리케이션 관점에서는 투명하게 적용되고 있다.
> - 단일 논리 데이터베이스 내에서 상태 변경을 조정하는 데만 사용되고 있다.

<br/>

## 4. 사가 패턴

- `사가 saga`는 여러 상태 변경을 조정할 수 있지만 자원을 잠글 필요가 없는 알고리즘으로 설계됐다.
  - 단계를 독립적으로 실행할 수 있는 개별 활동으로 모델링
- `Long Lived Transaction, LLT`: 몇 분, 몇 시간 또는 며칠이 걸리는 장기 트랜잭션
  - 일반 데이터베이스 트랜잭션에 직접 매핑하면 트랜잭션이 LLT 전체 생명주기에 걸쳐 진행. 이로인해 여러 행이 오랫동아 ㄴ잠길 수 있다.
  - LLT를 일련의 트랜잭션으로 분해하면 각 트랜잭션을 독립적으로 처리할 수 있다.

### 4-1. 사가 실패 모드

- 사가를 개별 트랜잭션으로 분해하려면, 실패 처리 방법을 고려해야 한다. (복구 작업)
- `역방향 복구 bacjward recovery`: 실패 복구와 이후에 일어나는 정리 작업인 롤백이 포함. 커밋된 트랜잭션을 취소하는 보상 조치를 정의해야 함.
- `순방향 복구 forward recovery`: 실패가 발생한 지점에서 데이터를 가져와 계속 처리할 수 있다. 트랜잭션 재시도 필요. 시스템이 재시도를 위한 충분한 정보를 보유하고 있음을 의미.
- 사가를 통해 기술적인 실패가 아닌 비즈니스 실패로부터 복구할 수 있다는 점을 기억.

#### 사가 롤백

- 사가의 경우 여러 트랜잭션이 관련돼 있으며, 일부 트랜잭션은 전체 연산을 롤백하기로 결정하기 전에 이미 커밋됐을지도 모른다.
- 프로세스에서 전체 작업을 한 번에 되돌릴 간단한 '롤백'은 없다.
- 차라리 롤백 구현을 원한다면 보상 트랜잭션을 구현해야 한다.
- `보상 트랜잭션 compensating transaction`(= `의미적 롤백 semantic rollback`)은 이전에 커밋된 트랜잭션을 취소하는 연산이다.
  - 이런 보상 트랜잭션은 일반적인 데이터베이스 롤백과 정확히 동일한 동작을 수행하지 않을 수도 있다.
  - 사가 패턴을 적용한 상황에서는 이미 트랜잭션이 **발생했다.** => 트랜잭션이 전혀 일어나지 않은 것처럼 만들 수는 없다.
- 고객에게 이미 이메일을 보냈다면 롤백을 해도 전송된 이메일은 취소할 수 없다. 대신 보상 트랜잭션은 고객에게 두 번째 이메일을 발송해서 문제가 생겨 주문이 취소됐음은 알릴 수 있다.ㄴ

#### 롤백을 줄이는 워크플로의 단계 재정렬

- 때로는 프로세스 실행 방식을 조율하는 방법만으로도 롤백 연산을 단순화할 수 있다.
- 실패할 가능성이 가장 높은 단계를 앞으로 당기고 해당 프로세스를 더 일찍 실패하면, 해당 단계는 애초에 수행되지도 않았으므로 나중에 보상 트랜잭션을 할 필요가 없다.

#### 역방향 실패 및 정방향 실패 상황의 혼합

- 실패 복구 모드를 혼합해 사용하는 것이 전적으로 적절하다.
- 상황에 맞는 실패 복구 방법을 사용하자.

### 4-2. 사가 패턴 구현

#### 오케스트레이션형 사가 orchestrated saga

- 원시 솔루션 공간을 밀접하게 따라가면 주로 중앙 집중식 조정과 추적에 의존
  - `중앙 조정자 central coordinator / orchestrator`를 사용해 실행 순서를 정의하고 필요한 보상 조치를 트리거한다.
- `명령과 제어 방식 command-and-control approach`
- 서비스 간 요청/응답 호출을 많이 사용하는 편이다.
- 고려해야할 점
1. 본질적으로 이 방식은 어느 정도 결합된 방식이다. (도메인 결합)
2. 서비스에 전달돼야 할 로직이 오케스트레이터에 흡수되기 시작할 수 있다. (로직을 한데 모을 장소가 있다면, 그곳에 중앙 집중화될 것이다.)

- 너무 많은 중앙 집중화를 피하는 한 가지 방법은 서로 다른 흐름에 대해 서로 다른 서비스가 오케스트레이터 역할을 수행하도록 하는 것이다.

#### 코레오그래피형 사가 choreographed saga

- 더 느슨하게 결합된 모델을 선호.
- 여러 협력 서비스 사이에서 사가 운영에 대한 책임을 분산시키는 것을 목표로 한다. 신뢰하지만 검증된 아키텍처.
- 종종 서비스 간 협업을 위해 이벤트를 많이 사용한다.
  - 이벤트를 통해 병렬 처리를 용이하게 만드는 방법을 사용.
  - 메시지 브로커를 통해 토픽의 내구성을 보장하고 해당 토픽의 이벤트가 구독자에게 성공적으로 전달되도록 보장한다.
- 이런 방식은 어떤 일이 일어나고 있는지 파악하기 어려워진다는 단점이 있다.
  - 비즈니스 프로세스를 명시적으로 표현하지 못하는 것도 문제지만, 사가가 어떤 상태에 있는지를 파악할 방법도 부족하므로 필요한 경우 보상 조치를 취할 기회조차 놓칠 수 있다.
  - 이 문제를 해결하는 가장 쉬운 방법 중 하나는 발행된 이벤트를 사용해 사가의 상태에 대한 `뷰 view`를 투영하는 것이다. (사가에 대한 고유ID, `상관관계 ID correlation ID`)

#### 혼합 방식

- 이 둘을 혼합해 사용하는 모델도 고려해볼 수 있다.
- 두 모델을 혼합하기로 결정한 경우에도 사가가 어떤 상태인지, 사가의 일부분으로 이미 어떤 활동이 진행됐는지 명확하게 파악할 수 있는 방법을 마련하는 것이 중요하다.

#### 코레오그래피형 사가와 오케스트레이션형 사가 중 어는 것을 사용해야 할까?

- 필자의 경험. 사가의 진행 상황을 추적하는 것과 관련된 추가적인 복잡성은 느슨하게 결합된 아키텍처를 통해 얻을 수 있는 이점보다 큰 경우가 대부분.
- 한 팀이 전체 사가의 구현을 담당할 경우 오케스트레이션형 사가가 훨씬 더 편하다.
- 여러 팀에서 관여하는 경우, 더 세분화된 코레오그래피형 사가를 선호.
  - 사가 구현에 대한 책임을 각 팀에 분배하기가 더 쉽고 느슨하게 결합된 아키텍처를 통해 각 팀이 독립적으로 작업할 수 있기 때문.
  - 하지만 이벤트 기반의 협업이 어렵게 느껴진다면 코레오그래피 방식이 부적합할 수도 있다.

### 4-3. 사가와 분산 트랜잭션의 비교

- 필자의 의견. 최대한 분산 트랜잭션은 피하는 편.
- 분산 시스템 분야의 개척자인 팻 헬런드는 오늘날 주로 구축하는 애플리케이션 유형을 위한 분산 트랜잭션 구현과 관련되 근본적인 문제의 핵심을 다음과 같이 뽑아냈다.

> 대다수 분산 트랜잭션 시스템에서 단일 노드에 장애가 발생하면 트랜잭션 커밋은 중단된다. 이로 인해 애플리케이션은 쐐기가 박힌 상태가 된다. 이런 시스템에서 그 크기가 커질수록 시스템이 죽을 가능성도 높아진다. 모든 엔진이 작동해야 하는 비행기가 비행할 때, 엔진을 하나 추가하면 비행기의 가용성은 감소한다. 

- 비즈니스 프로세스를 사가로 명시적으로 모델링하면 분산 트랜잭션으로 인한 다양한 문제를 피할 수 있으며 암시적으로 모델링된 프로세스가 개발자에게 더욱 명확하게 보여줄 수 있는 추가적 이점이 있다.

<br/>

# 참고 자료

- 마이크로서비스 아키텍처 구축, 샘 뉴먼 지음
