# Chapter 11. 보안

- 애플리케이션 보안 분야는 여전히 전문가의 지원이 필요하지만, 그들의 도움을 받더라도 이러한 주제와 관련해 기초 지식을 갖추는 것은 여전히 중요하다.
- 마이크로서비스는 시스템의 보안을 약화시킬 수도 있고 강화할 수도 있다.

## 1. 핵심 원칙

- 보안 문제는 가장 안전하지 않은 측면만큼만 안전하다.
  - 비유: 뒷문을 열어둔 채 강력한 정문을 만드는 것.

### 1-1. 최소 권한의 원칙

- 개인, 외부 또는 내부 시스템, 심지어 자체 마이크로서비스에 액세스 권한을 부여할 때는 부여하는 액세스 권한에 주의를 기울여야 한다.
- `최소 권한의 원칙 principle of least privilege`은 액세스 권한을 부여할 때 당사자가 필요한 기능을 수행하는 데 필요한 최소힌의 액세스 권한을 필요한 기간 동안만 부여한다는 개념을 설명한다.
- 최소 권한의 원칙은 제한된 시간 동안만 액세스 제어를 부여하도록 확장해 탈취될 경우 악영향을 더욱 제한할 수 있다.

### 1-2. 심층 방어

- 보호 메커니즘이 하나만 있는 것 
  - 그 방어를 무력화할 수 있다면 문제가 된다.
  - 혹은 특정 유형에 대해서만 방어할 때 문제가 된다.
- 여러 보호 장치를 갖추는 것은 굉장히 중요하다.

> #### 보안 통제 유형
> 1. 예방형 preventive
> - 공격이 발생하지 않도록 방지. secret을 안전하게 저장. 저장 및 전송 중인 데이터를 암호화. 적절한 인증 및 권한 부여 메커니즘 구현.
> 2. 탐지형 detective
> - 공격이 발생하고 있거나 발생했다는 사실을 알려준다. 애플리케이션 방화벽과 침입 탐지 서비스가 좋은 예시.
> 3. 대응형 reponsive
> - 공격 중 또는 공격 후 대응을 돕는다. 시스템 재구축 자동화 메커니즘. 데이터 복구를 위한 백업 작업.

### 1-3. 자동화

- 마이크로서비스 아키텍처에서 동작 부분이 훨씬 더 많아지면서 자동화는 점점 더 복합해지는 시스템을 관리하기 위한 핵심이 됐다.
  - 컴퓨터는 인간보다 동일한 작업을 반복해서 수행하는 데 훨씬 더 뛰어나다.
- 예를 들어, 특정 스크립트에 특정 권한만 할당하면 인적 오류는 줄이고 최소 권한 원칙을 더 쉽게 구현할 수 있다. 

### 1-4. 제공 프로세스에 보안 주입

- `소프트웨어 제공 software delivery`의 다른 측면과 마찬가지로 보안은 사후에 고려되는 사항으로 간주되는 경우가 너무 흔하다.
- 보안은 종종 소프트웨어를 외부로 내보는는 데 방해가 되는 것으로 여겨져 왔다.
- 하지만 보안도 다른 요소와 다르지 않음.

<br/>

## 2. 사이버 보안의 다섯 가지 기능

- 사이버 보안과 관련된 다양한 활동에 대한 유용한 5개의 모델
1. 잠재적인 공격자가 누구인지, 공격 대상이 무엇인지, 가장 취약한 곳은 어디인지 `식별하라`.
2. 잠재적인 해커로부터 주요 자산을 `보호하라`.
3. 최선의 노력에도 불구하고 공격이 발생했는지 `감지하라`.
4. 나쁜 일이 발생했다는 것을 알게 되면 `대응하라`.
5. 사고 발생 후 `복구하라`.

### 2-1. 식별

- 무엇을 보호해야 하는지 파악하기 전에 누가 우리 것을 노리고 있는지, 그들이 정확히 무엇을 찾고 있는지 알아야 한다.
  - `위협 모델링 threat modeling`
- 눈에 보이는 기술적 문제에 대한 기술적 해결책에는 쉽게 도달한다.
  - 하지만 우리는 모두 제한된 시각으로 바라본다는 문제가 있다.
- 공격자의 입장이 되어 외부에서 내부를 들여다보는 것이 중요하다.
  - 외부인의 관점이 중요. 외부의 도움을 받아 위협 모델링 작업을 진행하는 것이 매우 유용

### 2-2. 보호

- 마이크로서비스 아키텍처는 공격할 수 있는 표면적이 훨씬 넓기 때문에 보호해야 할 대상도 많지만, 심층 방어를 위한 많은 방법이 있다.

### 2-3. 탐지

- 마이크로서비스에서의 장애 감지는 복잡하다. => 모니터링해야 할 네트워크와 감시해야 할 기계가 더 많기 때문에.
- 또한 원천 정보가 크게 증가해 문제 탐지가 더욱 어려워질 수 있다. => 로그 집계가 도움이 된다.
- 그 외에도 불량 행위를 탐지하는 `침입 탐지 intrusion detection` 시스템과 같은 특수한 도구가 존재.

### 2-4. 대응

- 최악의 상황이 발생했다면?
  - 효과적인 사고 대응을 위한 접근법을 이해하는 것은 침해로 인한 손상을 제한하는 데 필수적이다.
- 많은 조직에서 침해 사고의 여파에 잘못 대응함으로써 침해로 인한 영향을 더욱 학화시켜 재정적 처벌이 가중되는 경우가 많다.

### 2-5. 복구

- 공격 발생 후 시스템을 가동하고 실행하는 능력. 문제가 재발되지 않도록 배운 것을 구현하는 능력.

<br/>

## 3. 애플리케이션 보안의 기초

- 자격 증명, 패치, 백업, 재구축

### 3-1. 자격 증명

- `자격 증명 credentials`은 사람(또는 컴퓨터)에게 어떤 형태의 제한된 자원에 대한 액세스 권한을 부여한다.
- 자격 증명은 두 가지 주요 영역으로 나눠서 생각해볼 수 있다.
1. 시스템 사용자(그리고 운영자)의 자격증명
   - 시스템의 가장 약한 지점. 악의적 당사자의 `공격 벡터 attack vector`로 흔히 사용
2. 마이크로서비스를 실행하는 데 중요한 정보인 시크릿

- 두 자격 증명 모두 `교체 rotation`, `폐기 revocation`, `권한 제한 limiting scope`의 문제를 고려해야 한다.

#### 사용자 자격 증명

- 해킹으로 인한 사건의 80%에서 어떤 형태의 자격 증명 탈취가 이뤄짐.
  - `피싱 phishing`, `패스워드 무작위 brute-forced` 공격 메커니즘 등을 사용
- API가 주도하는 시스템의 시대에서 자격 증명은 제삼자 시스템을 위한 API 키와 같은 것을 관리하도록 확장.

#### 시크릿

- 마이크로서비스가 작동하는 데 필수적 정보.
  - TLS용 인증서
  - SSH 키
  - 공개/비공개 API 키 쌍
  - 데이터베이스 액세스를 위한 자격 증명
- 시크릿의 수명주기를 고려하면 다양한 보안 요구 사항이 필요한 암호 관리의 다양한 측면을 구분해 볼 수 있다.
  - `creation`: 처음에 시크릿을 어떻게 만드는가?
  - `distribution`: 시크릿이 생성된 후 어떻게 올바른 장소에(만) 전달되도록 할 수 있는가?
  - `storage`: 권한을 가진 당사자만 액세스할 수 있도록 시크릿이 저장돼 있는가?
  - `monitoring`: 이 시크릿이 어떻게 사용되고 있는지 아는가?
  - `rotation`: 문제없이 스크릿을 변경할 수 있는가?
- 쿠버네티스는 자체 내장된 시크릿 솔루션을 제공.

#### 교체

- 자격 증명을 자주 교체해 누군가 자격 증명에 액세스했을 때 발생할 수 있는 피해를 제한하는 것이 이상적.

#### 폐기

- 긴급 폐기를 처리할 수 있도록 설정

#### 범위 제한

- 자격 증명의 범위를 제한하는 것은 최소 권한 원칙을 수용하는 개념의 핵심이다.

### 3-2. 패치

- 에퀴팩스의 데이터 유출 사건
  - 아파치 스트러츠의 취약점을 확인해 문제를 수정한 관리자가 새 릴리스를 만들었음에도 불구하고 소프트웨어를 업데이트하지 않았다.
- 대규모 환경에서 어떤 마이크로서비스가 알려진 취약성이 있는 라이브러리에 연결돼 있는지 파악하는 것은 매우 어려울 수 있다.
  - `Snyk`나 `Github Code Scanning`과 같은 도구를 사용.

### 3-3. 백업

- 백업을 하는 것 = 치실질을 하는 것.
- 데이터의 가치는 그 어느 때보다 높지만, 기술의 발전으로 인해 백업의 우선순위가 낮아진 것을 아닐까하는 의문.
  - 디스크는 과거보다 안정적. 데이터베이스는 데이터 손실을 방지하기 위해 내장된 복제 기능이 제공될 가능성 높음. 
  - 이런 시스템을 사용하면 백업이 필요하지 않다고 느낄지도 모른다.
- 하지만 치명적인 오류가 발생해 전체 `Cassandra` 클러스터가 지워진다면?
- 코딩 버그로 인해 애플리케이션이 중요한 데이터를 삭제해버렸다면?
- 따라서 중요한 데이터는 항상 백업해둬야 한다. 

### 3-4. 재구축

- 공격이 발생했을 때 해야할 일? 승인되지 않은 당사자의 액세스 권한을 제거하는 일. => 하지만 생각보다 간단하지 않다.
- 존재하는 서버를 지우고 완전히 재구축하는 능력은 알려진 공격뿐 아니라 지속적인 공격자의 영향을 줄이는 측면에서도 상당히 효과적일 수 있다.
- 시스템에 악의적인 당사자가 있는지 알지 못할 수 있지만 정기적으로 서버를 재구축하고 자격 증명을 교체한다면 깨닫지 못하는 사이에 공격자가 할 수 있는 일의 영향을 크게 제한할 수 있다.
 
<br/>

## 4. 암묵적 신뢰 대 제로 트러스트

- 허용 가능한 수준의 신뢰 구축?
  - 애플리케이션 보안과 관련해 모든 접점 간의 신뢰 문제를 고려.

### 4-1. 암묵적 신뢰

- 경계 내부에서 만들어진 서비스에 대한 호출을 암묵적으로 신뢰한다고 가정.
- 데이터의 민감도에 따라 괜찮을 수도 있다.
  - 하지만 공격자가 네트워크에 침투하면 모든 것이 엉망이 된다. (공격자가 내부로 들어온 순간부터 신뢰 대상이 되어버리기 때문)

### 4-2. 제로 트러스트

- 이미 침해당한 환경에서 작업하고 있다고 가정.
- 제로 트러스트에는 `경계 perimeter`의 개념이 없다.
- 시스템이 침해당했다고 가정하고 있으므로 다른 마이크로서비스의 모든 인바운드 호출을 적절하게 평가해야 한다.
  - 이 클라이언트를 정말로 신뢰해도 될까?

### 4-3. 스펙트럼

- 시스템 안에서 다른 당사자를 신뢰하는 수준은 액세스할 정보의 민감도에 따라 변경될 수 있다.
- 모든 보안 구현 비용은 위협 모델에 의해 정당화되고 주도돼야 한다
  - 제로 트러스트의 가치 여부에 대한 결정을 내리는데 도움이 되는 위협과 이와 관련된 영향도를 이해하라.

<br/>

## 5. 데이터 보안

- 모놀리식 소프트웨어를 마이크로서비스로 분해함에 따라 데이터는 이전보다 더 많은 시스템에서 이동한다.
  - 데이터는 네트워크를 통해서만 이동하는 것이 아니라 디스크에도 저장된다.
  - 중요한 데이터가 더 많은 곳에 분산돼 있다는 것은 애플리케이션 보안 측면에서 악몽이 될 수 있다.

### 5-1. 전송 중인 데이터

- 보호의 특성상 선택한 통신 프로토콜의 특성에 크게 좌우된다.
  - HTTP => TLS(Transport Layer Security)
  - Message Broker를 사용할 경우 전송 중인 데이터 보호를 위한 특정 기술의 지원 여부를 확인해야 한다.

#### 서버 신원

- 대화 중인 서버가 누구인지 확인.
  - 악의적인 당사자가 이론적으로 엔드포인트를 사칭하고 사용자가 전송하는 모든 유용한 데이터를 날려버릴 수 있다.
- HTTPS(TLS)를 사용하면 브라우저가 해당 웹 사이트의 인증서를 보고 유효한지 확인할 수 있다.
  - `HTTP Everywhere`
  - HTTPS를 통해 SOAP나 gRPC를 쉽게 실행할 수 있다는 점도 주목

#### 클라이언트 신원

- 업스트림 마이크로서비스의 신원을 확인.
- 서버 신원도 확인하지 않고 클라이언트 신원을 확인하는 상황은 상상하기 어렵다.
  - 둘 다 확인하려면 보통 어떤 `상호 인증 mutual authentication` 형태를 구현하게 된다.
  - 상호 인증을 사용하면 양쪽 당사자가 서로 인증한다.
- 클라이언트와 서버가 모두 인증서를 사용하는 `상호 TLS, mutual TLS`를 사용해 인증을 수행할 수 있다.
  - 공용 인터넷에서 클라이언트 장치의 신원을 확인하는 것은 사용자의 신원을 확인하는 것보다 덜 중요하다.
  - 따라서 상호 TLS는 거의 사용되지 않는다.

#### 데이터 가시성

- 일부 데이터에는 개인 식별 정보(PII)가 포함될 수 있으므로 이를 보호해야 한다.
- 일반적인 HTTPS나 상호 TLS를 사용하면 중간자는 데이터를 볼 수 없다.
  - TLS가 전송되는 데이터를 암호화.

#### 데이터 조작

- 일반적으로 데이터를 안 보이게 만드는 보호 유형은 데이터를 조작할 수 없도록 보장한다.
- 하지만 공개적으로 전송하면서도 데이터가 조작될 수 없도록 하고 싶을 수도 있다.
  - HTTP의 경우에 가능한 방법 중 하나는 `해시 기반 메시지 인증 코드(HMAC)`를 사용해 전송되는 데이터에 서명하는 것이다.

### 5-2. 보관 중인 데이터

- 보관된 데이터에는 책임이 따른다.
  - 심층 방어가 핵심.
  - 데이터를 암호화되지 않은 형태로 저장하기 때문에 문제가 발생.

#### 잘 알려진 것을 사용하라.

- 자체 시스템에서 데이터를 암호화하고 복호화해야 하는 경우 잘 알려져 있으면서 테스트를 거친 구현을 사용해야 한다.
  - 데이터 암호화를 망치는 가장 쉬운 방법 = 자체 알고리즘 구현, 다른 사람의 알고리즘을 구현하려고 시도.
  - 잘못 구현된 암호화 절대 금물

#### 암호화 대상 선택

- 모든 것을 암호화하는 연산 오버헤드는 상당히 부담.
- 테이블 집합으로 제한하는 것이 현명한 접근 방식

#### 절약하라

- 데이터 수집을 검소하게 하면 얻을 수 있는 이점
1. 저장하지 않으면 아무도 훔칠 수 없다.
2. 저장하지 않으면 아무도 데이터를 요구할 수 없다.
- 필요한 데이터만 저장하라.

#### 키가 전부다

1. 별도의 `보안 어플라이언스 security appliance`를 사용해 데이터를 암호화하고 복호화.
2. 서비스가 키를 필요로 할 때 액세스할 수 있는 별도의 키 볼트를 사용.
- 키의 생명주기 관리는 중요한 작업이 될 수 있으며, 이러한 시스템이 그 작업을 대신 처리할 수 있다.

#### 백업 암호화

- 데이터의 백업도 암호화해야 한다.

<br/>

## 6. 인증 및 권한 부여

- `인증 Authentication`
- `권한 부여 Authorization`
- 일반적으로 인증받는 사람이나 대상에 대해 추상적으로 이야기할 때 해당 당사자를 `권한 주체 principal`이라고 한다.
- 권한 부여는 권한 주체를 허용된 행위와 매핑하는 메커니즘이다.

### 6-1. 서비스 간 인증

- 유형
  - 인증 형식을 구현하게 해주는 상호 TLS
  - API 키를 이용한 통신

### 6-2. 사람 인증

- 일반적으로 둘 이상의 요소가 필요한 `Multifactor Authentication, MFA`, 즉 다단계 인증 형태를 취한다.
  - SMS로 코드 발송
  - 이메일을 통한 매직 링크 발송

### 6-3. 일반적인 SSO 구현

- 일종의 SSO 솔루션을 사용해 사용자가 해당 세션 동안 여러 다운스트림 서비스나 애플리케이션과 상호작용하게 되더라도 세션당 한 번만 자신을 인증.
- 자원을 액세스하려고 하면 ID 제공자에서 인증하도록 연결
  - MFA
  - 사용자 이름이나 패스워드 입력

### 6-4. SSO 게이트웨이

- 각 마이크로서비스 내부에서 ID 제공자에 대한 리디렉션과 핸드셰이킹을 처리하도록 정할 수 있다.
  - 외부 당사자의 인증되지 않은 요청은 적절하게 처리된다.
- 방식
  - HTTP Header를 채우도록 게이트웨이를 구성
  - JWT 토큰을 사용 => 서비스 간의 전달이 쉽다.
- 기능이 많아질수록 공격 표면도 늘어난다.

### 6-5. 세밀한 권한 부여

- 직원마다 접근할 수 있는 자원은 다 다를 수 있다.

### 6-6. 혼동된 대리인 문제

- 마이크로서비스가 작업을 완료하기 위해 추가 호출을 해야 한다면 어떻게 될까?
- 다운스트림 서비스가 업스트림 서비스의 호출을 수락해야 할까?
  - 암묵적 신뢰의 입장이라면 가능. (호출이 경계 내부에서 일어나는 경우를 용인.)
  - 만약 고객이 자신의 로그인된 자격 증명으로 호출해 다른 사람의 세부 정보를 요청하도록 웹 쇼핑 UI를 속일 수 있다면 어떻게 될까?

### 6-7. 중앙 집중식 업스트림 권한 부여

- 혼동된 대리인 문제를 피하기 위한 한 가지 방법.
- 시스템에서 요청을 수신하는 즉시 필요한 모든 권한 부여를 수행.
  - SSO 게이트웨이 자체나 업스트림 서비스에서 모두 요청을 인증하는 것을 목표로 한다는 의미.
- 사실상 특정 형태의 암묵적 신뢰를 허용하고 있음을 의미.
- 이 방식은 '독립적'으로 보이진 않는다.
  - 업스트림 엔티티가 다운스트림 마이크로서비스가 제공하는 기능을 알고 있어야 하고 해당 기능에 대한 액세스를 제한하는 방법을 알고 있어야 하기 때문.

### 6-8. 분산식 권한 부여

- 요청하는 사람의 식별자를 마이크로서비스로 보내도록 요구하는 방법.
  - HTTP를 사용한다면 헤더에 사용자 이름을 추가할 수 있다.
  
### 6-9. JSON 웹 토큰

- JWT를 사용하면 개인에 대한 여러 클레임을 전달할 수 있는 문자열에 저장할 수 있다.
- 일단 서명되면 JWT는 다양한 프로토콜을 통해 쉽게 전달될 수 있으면 토큰은 선택적으로 특정 기간 후에 만료되도록 구성할 수 있다.

#### 포맷

- JWT의 기본 페이로드는 JSON 구조.
- JWT의 JSON 페이로드 예시

```json
{
  "sub": "123",
  "name": "Sam Newman",
  "exp": "1606741736",
  "groups": "admin, beta"
}
```

- 페이로드는 `.`으로 구분되며 3 가지로 구분되어 작성된다.
1. 헤더
2. 페이로드
3. 서명

#### 토큰 사용

- 마이크로서비스에서 JWT 토큰을 사용하는 일반적인 방법
1. 고객이 로그인하고 인증되면 클라이언트 장치에 저장되는 로그인 세션을 나타내는 일종의 토큰을 생성(아마도 OAuth2 토큰)
2. 게이트웨이에 도달하면 요청 기간 동안 유효한 JWT 토큰을 생성. 다운스트림 마이크로서비스로 이 JWT 토큰을 전달
3. 다운스트림 서비스는 토큰의 유효성을 검사하고 페이로드에서 클레임을 추출해 어떤 종류의 권한 부여가 필요한지 결정할 수 있다.
4. 그 뒤로도 다운스트림을 호출해야 한다면 요청별로 JWT 토큰을 생성하여 다운스트림 서비스가 요청

#### 문제점

1. 키 문제
- 서명을 검증하기 위해 JWT 토큰 수신자는 별도로 통신해야 하는 일부 정보가 필요(일반적으로 공개 키)
- 수신 마이크로서비스에서 구성 파일에 공개 키를 하드코딩할 수 있지만 공개 키 변경을 처리하는 데 문제가 발생한다.
2. 처리 시간이 오래 걸리는 경우 토큰의 유효 기간을 오바르게 설정하는 것이 까다롭다.
- 요청과 동시에 몇 시간이 걸리는 일련의 비동기 프로세스가 시작된다면?
3. JWT 토큰에 너무 많은 정보가 필요해 토큰 크기 자체가 문제가 될 수 있다.

<br/>

# 참고 자료

- 마이크로서비스 아키텍처 구축, 샘 뉴먼 지음
