# Chapter14. 사용자 인터페이스

- 사용자 인터페이스는 결국 모든 마이크로서비스가 고객에게 의미 있는 무언가로 통합되는 곳이다.

## 1. 디지털을 향해

- 고객이 우리가 제공하는 서비스를 사용하게 하는 가장 좋은 방법은 무엇인가?
  - 시스템 아키텍처에 어떤 영향을 주는가?
- 사용자 인터페이스를 사용자에게 제공하고자 하는 다양한 기능을 한데 엮는 곳이라고 생각하라.
  - 이 문제는 '누가'와 '어떻게'라는 두 가지 측면에서 바라볼 필요가 있다.

## 2. 소유권 모델

- 계층화된 아키텍처는 소프트웨어를 효과적으로 제공하는 측면에서 문제가 될 수 있다.
  - 사용자 인터페이스 계층에 대한 책임은 한 프론트엔드 팀에 있고 백엔드 서비스에 대한 작업은 다른 팀에서 수행?
  - 이 경우 간단한 컨트롤 하나를 추가하려면 서로 다른 세 팀이 작업을 수행해야 한다. => 속도가 느려짐
- 독립적 배포 가능성을 달성하기 위해선 서버 측 구성 요소도 관리하는 팀에서 UI를 분리하고 관리하는 것이다.
  - 한 팀이 새로운 컨트롤을 추가하기 위해 수행해야 하는 모든 변경 사항을 책임지게 된다.
  - 엔드 투 엔드 기능에 대해 완전한 소유권을 가진 팀은 더 빠르게 변경할 수 있다.
- 하지만 아쉽게도 전담 프론트엔드 팀이 마이크로서비스를 사용하는 회사들 사이에서 더 일반적인 조직 패턴이다.

### 2-1. 전담 프론트엔드 팀 추구

- 전담 프론트엔드 팀에 대한 수요는 전문가 부족, 일관성 추구, 기술적 문제라는 세 가지 핵심 문제로 귀결된다.

1. 사용자 인터페이스를 제공하려면 어느 정도의 전문 기술이 필요하다.
2. 일관성이다. 고객과 대면하는 사용자 인터페이스를 제공하는 팀이 있다면, UI가 일관된 `룩앤필 look and feel`을 유지할 수 있다.
3. 일부 사용자 인터페이스 기술은 모놀리스가 아닌 방식으로 작업하기 어려울 수 있다.
    - SPA => 전체 애플리케이션이 하나의 웹 페이지 안에서 제공되기 때문

## 3. 스트림 정렬 팀을 향해

- 전담 프론트엔드 팀? 처리량을 최적화할 때 범하는 일반적인 실수.
  - 조직에 새로운 핸드오프 지점이 생겨 업무 속도가 느려지기 때문
- 필자가 선호나는 모델 => 도메인의 특정 부분에서 기능을 엔드투엔드로 제공하는 전담 팀.

> 스트림 정렬 팀은 가치 있는 단일 업무 스트림에 정렬된다... 팀은 고객이나 사용자 가치를 가능한 한 빠르고 안전하고 독립적으로 구현하고 전달할 수 있는 권한을 부여받는다.
> 또한 업무 중 일부를 수행하기 위해 다른 팀에 핸드 오프를 할 필요가 없다.
> - 매튜 스켈톤과 마누엘 페이스의 "팀 토폴로지"

- 어떤 의미에서는 `풀스택 팀 full stack team`에 대해 이야기하고 있는 것이다.
  - 사용자 대면 기능을 엔드투엔드로 모두 책임지는 팀은 최종 사용자와도 더 분명하고 직접적인 관계를 맺을 수 있다.
- 사용자가 원하는 기능을 막연하게 생각하는 '백엔드 팀' => 새로운 기능을 구현할 때 온갖 종류의 오해를 불러 일으킴.
- 반면 엔드투엔드 팀은 자신이 만든 소프트웨어를 사용하는 사람들과 직접적인 관계를 구축하는 것이 훨씬 더 쉽다는 사실을 알 것이다.

### 3-1. 전문가 공유

- '좁은' 분야에 대해 적절한 깊이의 기술을 가진 사람들은 부족하고, 항상 시간보다 더 많은 일을 해야 할 수도 있다.
- 전통적인 접근 방식 => 같은 기술을 가진 모든 사람을 동일한 팀에 배치 => `고립된 siloed` 조직을 초래
- 전문 기술을 가진 사람들을 자체 전담 팀에 배치하면 다른 개발자는 이렇게 수요가 많은 기술을 습득할 기회도 잃게 된다.
  - ex. DBA 집단
- 전문가를 더 효과적으로 배치하는 방법이 필요
  - 이상적으로 전문가는 팀에 소속되어야 함.
  - 혹은 여러 팀에서 전문가의 시간을 잘 나누는 것이 좋다. => 혹은 이런 기술을 갖춘 전담 팀. 이 팀의 임무 = 다른 팀을 `활성화` (활성화 팀)

### 3-2. 일관성 보장

- 활성화 팀 모델을 사용하는 경우 전문가는 여러 팀과 시간을 보내면서 각 팀에서 수행되는 작업의 일관성을 유지하는 데 도움을 줄 수 있다.
  - 동적인 CSS 스타일 가이드나 공유 UI 컴포넌트와 같은 공유 리소스
  - ex. 개발팀이 디자인 팀과 협업해 웹 컴포넌트 개발

### 3-3. 기술적 문제 극복

- SPA는 사용자 인터페이스를 분해할 때 문제가 된다. 또한 동일한 사용자 인터페이스가 제공될 것으로 기대된 다양한 기기에서는 해결해야 하는 다른 문제가 발생한다.
- 사용자 => 가능한 한 원활한 소프트웨어 사용 요구

<br/>

## 4. 모놀리식 프론트엔드

- 마이크로서비스를 호출함. 모든 UI 상태와 동작이 UI 자체에 정의되는 아키텍처.

### 4-1. 적용 시점

- 몇 가지 단점이 존재

1. 모놀리식 개체의 본질적 특징으로 인해 전담 프론트엔드 팀이 필요하거나, 전담 팀에 의해 만들어질 수 있다.
    - 여러 팀에서 공유하면 경합이 발생함.
2. 다양한 종류의 기기에 맞게 응답을 조정할 수 있는 능력이 거의 없다.
    - 웹 기술을 사용하는 경우 다양한 장치의 제약 조건에 따라 화면 레이아웃을 변경할 수 있지만, 지원하는 마이크로서비스에 대한 호출가지 변경할 필요는 없다.

- 이 패턴은 하나의 배포 가능한 단위에서 UI의 모든 구현과 동작을 처리하고 싶을 때 가장 적합하다.

## 5. 마이크로 프론트엔드

- 여러 부분을 독립적으로 작업하고 배포할 수 있는 조직 패턴.
- 백엔드 마이크로서비스와 지원하는 UI를 모두 소유하려는 스트림 정렬 팀에게 필수 패턴.

### 5-1. 구현

- 위젯 기반 분해 기술에서는 프론트엔드의 여러 부분을 단일 화면으로 함께 연결하는 작업이 필요.
- 반면 페이지 기반 프론트엔드 분해에서는 프론트엔드가 독립적인 웹 페이지로 분리.

### 5-2. 적용 시점

- 계층화된 아키텍처에서 벗어나기 위해 사용.

## 6. 페이지 기반 분해

- UI는 여러 웹 페이지로 분해되고, 서로 다른 마이크로서비스에서 서로 다른 페이지들을 제공할 수 있다.
- 이런 경우 팀은 전체 UI를 전부 렌더링할 수 있으므로 팀의 변경 사항이 사용자에게 미치는 영향을 해당 팀이 쉽게 알 수 있다.

### 6-1. 적용대상

- 모놀리식 프론트엔드나 마이크로 프론트엔드 방식에 모두 유용한 페이지 기반 분해는 사용자 인터페이스가 웹 사이트인 경우 기본 선택지이다.

## 7 .위젯 기반 분해

- 그래픽 인터페이스의 화면에 독립적으로 변경할 수 있는 위젯이 포함.
- 일반적으로 인터페이스의 핵심적인 탐색과 포함돼야 하는 위젯 같은 것들을 정의할 수 있는 `컨테이너 Container` 애플리케이션이 필요하다.

### 7-1. 구현

- 위젯은 UI에 연결하는 방법은 UI가 생성되는 방식에 따라 크게 달라진다.
  - 간단한 웹 사이트의 경우, 클라이언트 측이나 서버 측 템플릿을 사용해 위젯을 HTML `프래그먼트 fragment`로 포함하는 것은 매우 간단하다.
- 다른 기능을 손상시키지 않고 자체 포함된 기능을 UI에 제공하는 방법에 관한 이슈는 단일 페이지 앱에서 특히 문제가 돼 왔는데, 부분적으로 모듈화의 개념이 SPA 프레임워크가 생성된 방식에서는 주요 관심사가 아닌 면도 있기 때문이다.

#### 의존성

- `iFrame`은 과거에 많이 사용돈 기술이지만, 다른 위젯을 하나의 페이지로 연결하는 데 사용하지 않는 편이다.
  - 크기 조정 및 서로 다른 부분 간 통신을 어렵게 만듦.

#### 페이지 내 위젯 간 통신

- 위젯을 독립적으로 빌드하고 배포할 수 있지만, 우리는 여전히 위젯이 서로 상호작용하길 원한다.
- 위젯은 사용자 정의 이벤트를 내보내도록 해야 한다.
  - 브라우저는 이미 동작을 트리거하는 데 사용할 수 있는 여러 가지 표준 이벤트를 지원한다.

### 7-2. 적용 시점

- 서로 다른 팀이 제공한 위젯이 모두 한꺼번에 UI에 공존할 수 있으므로 페이지 기반 분해보다 더 많은 유연성을 제공한다.
- SPA 프레임워크를 활용하고 프론트엔드에 대한 책임을 분리하려는 어떤 상황에서도 위젯을 사용할 것을 강력히 제안.
- SPA의 맥락에서 위젯 분해에 대한 주요 관심사는 개별적인 컴포넌트 번들링을 설정하는 데 필요한 작업과 페이로드 크기에 관련된 문제와 연관이 있다.
  - 한 위젯의 종속성만 변경해도 애플리케이션에 완전히 새로운 종속성이 포함돼 페이지 크기가 크게 늘어날 수 있다.

## 8. 제약

- 기기마다 소프트웨어가 수용해야 하는 서로 다른 제약 조건이 있다.
  - 예를 들어 데스크톱 애플리케이션에서는 방문자가 사용하는 브라우저나 화면 해상도와 같은 제약 조건을 고려한다.
- 따라서 핵심 서비스가 동일하더라도 각 인터페이스 타입과 사용자의 다양한 요구 사항에 대해 존재하는 다양한 제약 조건에 맞춰 이를 조정할 방법이 필요하다.
- 모바일은 기기는 완전히 새로운 제약 조건을 가져왔다. => 서버와 통신하는 방식에 영향을 미칠 수 있다.
  - 모바일 네트워크의 대역폭 문제만이 아니다.
  - 다양한 종류의 상호작용은 배터리를 소모시켜 고객의 불만을 초래
- 기기에 따라 상호작용의 특성도 바뀐다.

## 9. 중앙 집계 게이트웨이

- 외부 사용자 인터페이스와 다운스트림 마이크로서비스 사이에 위치하며 모든 사용자 인터페이스에 대한 호출의 필터링과 집계를 수행한다.
- 집계하지 않는다면 사용자 인터페이스는 필요한 정보를 가져오기 위해 여러 번 호출해야 할 수 있고 검색했지만 필요하지 않은 데이터를 버리는 경우가 많다.
- 이러한 게이트웨이는 `batch` 호출에도 도움이 될 수 있다.

### 9-1. 소유권

- 게이트웨는 분쟁의 소지가 될 가능성이 있다.
- 기본적으로 호출 집계와 필터링은 주로 외부 사용자 인터페이스의 요구 사항에 따라 결정된다.
  - 따라서 게이트웨이는 UI를 만드는 팀이 소유하는 것이 당연하다.
  - 불행히도 전담 프론트엔드 팀이 있는 조직의 경우 해당 팀은 중요한 백엔드 컴포넌트를 구축할 기술을 보유하지 못할 수 있다.
- 중앙 게이트웨이는 배포하는 데 병목 지점이 될 가능성이 있다.
  - 여러 팀이 게이트웨이를 변경해야 하는 경우 해당 팀 간의 조정이 필요하므로 개발 속도가 느려진다.

### 9-2. 다양한 종류의 사용자 인터페이스

- 모바일 기기의 행동 유도성은 천차만별이다.
  - 화면 공간이 작기 때문에 더 적은 데이터를 표시. 서버 측 자원에 대해 많은 연결을 하면 배터리가 소모되고 데이터 플랜이 제한이 됐다.

### 9-3. 여러 문제

- API 호출 처리와 관련해 서버 측에서 해결해야 할 많은 문제가 있다.
  - 호출 집계와 필터링 외에도 API 키 관리나 사용자 인증, 호출 라우팅과 보다 일반적인 문제를 생각할 수 있다.
  - 종종 이러한 일반적인 문제는 API 게이트웨이 제품으로 처리할 수 있다.

### 9-4. 적용 시점

- 단일 중앙 집계 게이트웨이를 채택하기로 결정했다면 그 안에 어떤 기능을 넣을지 신중하게 결정해야 한다.

## 10. 프론트엔드를 위한 백엔드

- `Backend For Frontend, BFF`
- 특정 사용자 인터페이스용으로 개발됐다는 점에서 중앙 집계 게이트웨이와 다르다.
  - 사용장 인터페이스의 다양한 문제를 처리하는 데 매우 성공적인 것으로 입증.
- 여러 팀이 모두 소유권을 공유하려고 하면서 개발의 병목이 되는 것을 피할 수 있다.

### 10-1. 얼마나 많은 BFF가 필요한가?

1. 각기 다른 유형의 클라이언트에 대해 하나의 BFF를 엄격하게 유지.
2. 동일 유형의 사용자 인터페이스를 사용하더라도 두 가지 이상의 클라이언트 유형에 동일한 BFF를 사용할 수 있는 형태
  - BFF가 여러 문제를 처리하도록 비대해지기 쉽다.

### 10-2. 재사용과 BFF

- 사용자 인터페이스당 하나의 BFF를 갖는 것에 대한 우려 중 하나는 결과적으로 BFF 사이에 많은 중복이 발생할 수 있다는 점이다.
  - ex. 동일한 집계 타입에 하위 서비스와 인터페이스하기 위해 동일하거나 유사한 코드가 사용될 수 있다.
  - 하지만, 마이크로서비스 간의 코드 중복에 대해서는 조금 관대해도 되지 않을까..?
- BFF 사이에 재사용이 가능하도록 공통 코드를 추출할 시간이 되면, 두 가지 분명한 옵션이 있다.
1. 비용이 저렴하지만 더 많은 문제가 발생할 수 있는 공유 라이브러리를 추출하는 것.
2. 공유 기능을 추출해 새로운 마이크로서비스를 만드는 것.

### 10-3. 데스크톱과 그 이상을 위한 BFF

- 단지 모바일 개발의 제약을 해결하는 데 사용되는 것으로 생각할 수 있다.
- 데스크톱 앱 => 더 나은 연결성. 여러 다운스트림 호출을 수행하는 데 드는 비용 관리 가능
  - 따라서 BFF 없이도 다운스트림 서비스에 직접 여러 번 호출할 수 있다.
- 하지만 웹에서도 BFF를 사용하는 것이 유용한 상황도 실제로 존재한다.
  - 서버 측에서 웹 UI의 더 많은 부분을 생성할 때 BFF는 최적의 장소가 된다.

### 10-4. 적용 시점

- 웹 UI만 제공되는 애플리케이션이라면, 서버 측에서 상당한 양의 집계가 필요한 경우에만 BFF를 사용하는 것이 합리적.
- 하지만 모바일 UI나 제삼자에게 특정 기능을 제공해야 하는 순간 처음부터 각 클라이언트에 BFF를 사용하는 방안을 적극 고려

## 11. GraphQL

- 클라이언트가 데이터에 액세스하거나 데이터를 변경하기 위해 쿼리를 실행할 수 있는 쿼리 언어다.
- 그래프QL은 원하는 필드를 정확히 요청하는 데 도움이 될 뿐 아니라 `왕복 round trip` 횟수도 줄일 수 있다.
  - 이와 같은 쿼리를 사용하려면 액세스하는 다양한 데이터 타입을 정의해야 한다.
  - 타입을 명시적으로 정의하는 것은 그래프QL의 핵심 부분이다.
- 그래프QL을 구현하려면 쿼리를 처리할 `리졸버 resolver`가 필요하다.
  - 리졸버는 서버 측에 위치해 그래프QL 쿼리를 호출에 매핑함으로써 실제 정보를 가져온다.
- 이와 같은 방법으로 그래프QL을 사용해 집계 게이트웨이나 BFF를 구현할 수 있다.
  - 클라이언트 쿼리를 변경하는 것만으로 원하는 집계와 필터링을 쉽게 변경할 수 있는 이점이 있다.

<br/>

# 참고 자료

- 마이크로서비스 아키텍처 구축, 샘 뉴먼 지음
