# Intro

## JPA를 사용해야 하는 이유?

- SQL이 아닌 객체 중심으로 개발해 생산성과 유지보수성이 좋아진다. => 테스트 작성이 수월해진다.
- 다른 데이터베이스로 옮기더라도 코드를 거의 수정하지 않을 수 있다. (MySQL => Oracle)
- 반복적인 SQL 작업에서 벗어날 수 있다. (개발자는 SQL 매퍼가 아니다!)

## 1. SQL을 직접 다룰 때의 문제점?

- JDBC API를 사용하면 아래와 같은 과정을 거쳐야한다.
  - 조회
    1. SQL을 작성한다.
    2. JDBC API를 사용해서 SQL을 실행한다.
    3. 조회 결과를 객체에 매핑한다.
  - 등록
    1. SQL을 작성한다.
    2. 객체의 값을 꺼내서 등록 SQL에 전달한다.
    3. JDBC API를 사용해 SQL을 실행한다.
- 위와 같은 과정을 계속 반복해야 하면 너무 많은 코드를 작성해야 한다. (DAO 개발은 지루함과 반복의 연속)

### SQL에 의존적인 개발

- 엔티티에 필드를 추가하면 거기에 연관된 모든 SQL을 직접 수정해줘야 하는 번거로움이 있다.
- 근데 휴먼 에러가 과연 발생하지 않을까? 개발자들은 엔티티를 신뢰하고 사용할 수 없게 된다.

> SQL을 직접 다룰 때 발생하는 문제 요약
> - 진정한 의미의 계층 분할이 어렵다.
> - 엔티티를 신뢰할 수 없다.
> - SQL에 의존적인 개발을 하기 어렵다.

### JPA로 문제 해결하기

- JPA를 사용하면 SQL을 따로 작성할 필요가 없다. 단지 추상화된 JPA API를 사용하기만 하면 된다.

<br/>

## 2. 패러다임의 불일치

- 객체지향 프로그래밍은 추상화, 캡슐화, 정보은닉, 상속, 다형성 등 시스템의 복잡성을 제어할 수 있는 다양한 장치들을 제공한다.
- 도메인을 객체로 모델링하면 객체지향 프로그래밍의 장점을 활용할 수 있지만, 도메인은 어떻게 저장할 것인가? 어딘가에 영구 보관해서 영속성있는 서비스를 할 수 있다.
- 관계형 데이터베이스는 어떤가? 데이터 중심으로 구조화되어 있고, 집합적인 사고를 요구한다. 그리고 객체지향의 추상화, 상속, 다형성 같은 개념은 없다.
- 객체와 관계형 데이터베이스는 추구하는 목적이 서로 다르므로 기능과 표현 방법 또한 다르다. => **패러다임의 불일치**

### 상속

- 객체에는 상속이라는 개념이 있지만 데이터베이스에는 존재하지 않는다.
- 그나마 데이터베이스 모델링의 슈퍼타입, 서브타입 관계를 사용하면 객체 상속과 가장 유사한 형태로 테이블을 설계할 수 있다.
  - 예를 들어 슈퍼타입에서는 DTYPE을 가지고 있고, DTYPE과 서브타입이 가지고 있는 외래키를 사용해 조인하는 방식을 사용할 수 있다.
  - 하지만 객체를 저장할 때 2개의 테이블에 INSERT를 해야한다는 점은 불편하다.
- JPA가 이 문제를 해소해줄 수 있다. (Cascade 조건을 걸어두면) 서브 타입을 `persist()`해도 2개의 테이블에 각각 정보가 저장되는 것을 확인할 수 있다.

### 연관관계

- 객체를 참조를 사용해 다른 객체와 연관관계를 맺는다. (참조가 있는 방향으로만 조회 가능)
- 반면 테이블은 외래 키를 사용해 다른 테이블과 연관관계를 갖는다. (양방향 조회 가능)
- 참조와 외래 키의 차이는 객체지향 모델링을 거의 포기하게 만들 정도로 극복하기 어렵다.
  - 객체가 테이블처럼 외래 키 필드를 가지고 있다면? 연관된 객체를 참조를 통해 조회할 수 없다...
  - 그렇다고 객체 모델링을 하자니, 객체를 테이블에 저장하거나 조회하기가 쉽지 않다. 저장할 때 id를 꺼내줘야 하고, 조회할 땐 참조하고 있는 객체 정보를 따로 매핑해줘야하기 때문에 많은 양의 코드 작성이 필요하다.
- JPA는 이런 연관관계를 추상화해 자바 코드로 제공한다. 
  - member가 team을 참조하고 있을 때
  - (cascade 설정이 되어 있으면) member만 저장(persist)해도 team이 자동으로 저장된다.
  - member만 조회해도 team을 자동으로 조회해준다. (Lazy 로딩 등을 통해)

### 객체 그래프 탐색

- SQL에 의존하는 애플리케이션에서는 SQL에 따라 객체 그래프를 어디까지 탐색할 수 있는지가 한계 지어진다. (논리가 SQL에 종속되어 있기 때문) 
  - 개발자에게 너무 큰 제약이다. 비즈니스 로직에 따라 사용하는 객체 그래프가 다른데 언제 끊어질지 모를 객체 그래프를 함부로 탐색할 수는 없기 때문이다.
  - 개발자들은 객체 그래프 탐색의 한계를 예측하기 위해 결국 데이터 접근 계층인 DAO를 직접 볼 수 밖에 없다. (이게 다 비용이다.)
- JPA에서는 이 문제를 어떻게 해결할까?
  - JPA에는 지연 로딩(Lazy Loading)이라는 기능이 있다.
  - 필요한 객체를 호출했는데 그 객체가 조회된 적이 없다면 JPA에서 자동으로 조회 쿼리를 만들어 조회를 실행하고 객체 필드를 매핑해 사용자에게 던져준다.

### 동일성/동등성 비교

- SQL 문과 DAO를 통해 데이터를 가져올 경우 동등성 비교(equals)는 구현이 쉽지만, 동일성 비교(==)에서는 구현 난이도가 굉장히 높다. 
  - 같은 대상을 조회하는 쿼리를 사용했을 때, 같은 인스턴스가 조회되는 것을 보장해주는 추가 로직이 필요하기 때문이다.
- JPA는 같은 트랜잭션일 때 같은 객체가 조회되는 것을 보장하기 때문에 동일성 비교에 성공한다.
  - 영속성 컨텍스트의 개념

<br/>

## 3. JPA

- ORM(Object Relational Mapping)이란? 객채와 관계형 데이터베이스를 매핑한다는 뜻이다.
  - 패러다임 불일치 문제를 해결해주는 시스템이다.
- JPA는 하이버네이트라는 오픈소스 ORM 프레임워크 기반으로 첫 탄생한 기술이다.
  - JPA는 ORM 기술에 대한 API 표준 명세다. (JPA는 그냥 인터페이스일 뿐이다!)
  - JPA의 구현체로 Hibernate가 있는 것이다! (특정 구현 기술에 대한 의존도를 줄일 수 있고 다른 구현 기술로 손쉽게 이동할 수 있다!)
  - 그 외에도 EclipseLink, DataNucleus 등의 API도 지원하지만 보통 Hibernate를 사용한다고 한다. 
- JPA는 애플리케이션과 JDBC 사이에서 동작한다.
  - APP <-> JPA <-> JDBC API <-> DB

### 다시 한 번 더, JPA를 사용해야 하는 이유

- 생산성
- 유지보수
- 패러다임의 불일치 문제 해결
  - 상속, 연관관계, 객체 그래프 탐색, 비교하기 등과 같은 패러다임 불일치 문제 해결
- 성능
  - 영속성 컨텍스트를 통한 조회 성능 개선
- 데이터 접근 추상화와 벤더 독립성
  - 예를 들어, 페이징 처리는 데이터베이스마다 사용법이 각기 다르다. => 애플리케이션이 선택한 데이터베이스 기술에 종속되는 위험이 있다. 
  - 하지만 JPA는 이에 대해 추상화된 API를 제공하기 때문에 데이터베이스 기술이 종속되지 않도록 해준다!
  - JPA는 Dialect Interface를 구현한 여러 구현체를 가지고 있다.

```java
public class MySQLDialect extends Dialect {...}
```

```java
public class OracleDialect extends Dialect {...}
```

```java
public class H2Dialect extends Dialect {...}
```

<br/>

# 참고자료

- 자바 ORM 표준 JPA 프로그래밍, 김영한 지음
