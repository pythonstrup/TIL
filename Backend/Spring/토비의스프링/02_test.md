# Chapter2. 테스트

- 스프링 개발자에게 가장 중요한 가치. => 객체지향과 테스트
  - 스프링의 핵심인 IoC와 DI는 오브젝트의 설계과 생성, 관계, 사용에 관한 기술.
  - 또한 복잡한 애플리케이션을 효과적으로 개발하기 위한 기술이다. 복잡한 애플리케이션을 개발하는 데 필요한 도구 하나는 객체지향 기술이다.
  - 그리고 스프링이 강조하고 가치를 두고 있는 것이 바로 **테스트**
- 애플리케이션은 계속 변하고 복잡해져 간다. 그 변화에 대응하는 방법은 아래의 2가지 방법이다.
1. 확장과 변화를 고려한 객체지향적 설계와 그것을 효과적으로 담아낼 수 있는 IoC/DI 같은 기술
2. 만들어진 코드를 확신할 수 있게 해주고, 변화에 유연하게 대처할 수 있는 자신감을 주는 테스트 기술

## 1. UserDaoTest 다시 보기

### 1-1. 테스트의 유용성

- 테스트란 결국 내가 예상하고 의도했던 대로 코드가 정확히 동작하는지를 확인해서, 만든 코드를 확신할 수 있게 해주는 작업이다.

### 1-2. UserDaoTest의 특징

- 이전에 작성한 예시를 정리해보면 아래와 같다.
  - 자바에서 가장 손쉽게 실행 가능한 `main()` 메소드를 사용
  - 테스트할 대상인 `UserDao`의 오브젝트를 가져와 메소드를 호출한다.
  - 테스트에 사용할 입력 값을 직접 코드에서 만들어준다.
  - 테스트의 결과를 콘솔에 출력한다.
  - 각 단계의 작업이 에러 없이 끝나면 콘솔에 성공 메시지로 출력해준다.

#### 웹을 통한 DAO 테스트 방법의 문제점

- DAO 뿐만 아니라 서비스 클래스, 컨트롤러와 뷰 등 모든 레이어의 기능을 다 만들고 나서야 테스트가 가능하다는 점이 가장 큰 문제다.
  - 하나의 테스트를 수행하는 데 참여하는 클래스와 코드가 너무 많기 때문에 문제가 어디에서 발생했는지 찾기 어렵다.

#### 작은 단위의 테스트

- 테스트하고자 하는 대상이 명확하다면 그 대상에만 집중해서 테스트하는 것이 바람직하다.
  - 한꺼번에 너무 많은 것을 몰아서 테스트하면 테스트 수행 과정도 복잡해지고, 오류가 발생했을 때 정확한 원인을 찾기가 힘들어진다.
  - 따라서 테스트는 가능하면 작은 단위로 쪼개서 집중해서 할 수 있어야 한다. (관심사의 분리는 여기에도 적용!)
- 이렇게 작은 단위의 코드에 대해 테스트를 수행한 것을 `단위 테스트 unit test`라 한다.
- 때로는 애플리케이션의 전 계층이 참여하는 하나의 프로세스 전체를 묶어서 테스트할 필요가 있다.
  - 각 단위 기능은 잘 동작하는데 묶어놓으면 안 되는 경우가 종종 발생하기 때문이다.
  - 하지만 단위 테스트 없이 긴 테스트만 한다면, 수많은 에러를 만나거나 에러는 안 나지만 제대로 기능이 동작하지 않는 경험을 하게 될 것이다. 문제의 원인도 찾기 매우 힘들다.

#### 자동수행 테스트 코든

- `UserDaoTest`의 한 가지 특징은 테스트할 데이터가 코드를 통해 제공되고, 테스트 작업 역시 코드를 통해 자동으로 실행한다는 점이다.
  - 테스트를 자주 수행해도 부담이 없다.

#### 지속적인 개선과 점진적인 개발을 위한 테스트

- 처음 만든 초난감 DAO 코드를, 스프링을 이용한 깔끔하고 완성도 높은 객체지향적 코드로 발전시키는 과정의 일등 공신은 바로 테스트였다.
  - 기능에 문제가 없는지 확인해주는 테스트가 있기에 잘못된 동작을 바로 체크할 수 있었다.

### 1-3. UserDaoTest의 문제점

#### 수동 확인 작업의 번거로움

- 테스트 수행과 데이터의 준비를 모두 자동으로 진행하도록 만들어졌지만 여전히 사람의 눈으로 확인하는 과정이 필요하다.
  - `add()`를 통해 추가하고 `get()`으로 확인할 때 자동으로 확인해주지 않는다. => 휴먼 에러 가능성

#### 실행 작업의 번거로움

- 매번 실행하는 것은 번거로운 일이다.
- `main()` 메소드를 이용하는 방법보다는 좀 더 편리하고 체계적으로 테스트를 실행하고 그 결과를 확인하는 방법이 필요.

## 2. UserDaoTest 개선

- 문제 두 가지 개선

### 2-1. 테스트 검증의 자동화

- 테스트 실패
1. 테스트 진행 중 에러
2. 결과가 기대한 것과 다름

### 2-2. 테스트의 효율적인 수행과 결과 관리

- JUnit. 단위 테스트를 만들 때 유용한 툴

#### JUnit 테스트로 전환

- JUnit은 프레임워크다. 주도적으로 애플리케이션의 흐름을 제어한다. `main()` 메소드도 필요 없고 오브젝트를 만들어서 실행시키는 코드를 만들 필요도 없다.

#### 테스트 메소드 전환

- 토비의 스프링에서 사용하는 JUnit4에서는 @Test를 사용하려면 메소드를 `public`으로 선언해야 했다.
  - 현재 사용하는 JUnit5에서는 default 메소드로 둬도 테스트 실행이 가능하다.

```java
public class UserDaoTest  {

  @Test
  public void addAndGet() throws SQLException {
    ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");

    UserDao userDao = context.getBean("userDao", UserDao.class);
  }
}
```

#### 검증 코드 전환

- `assertThat`의 사용

```java
public class UserDaoTest  {

  @Test
  public void addAndGet() throws SQLException, ClassNotFoundException {
    ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");

    UserDao dao = context.getBean("userDao", UserDao.class);

    User user = new User();
    user.setId("bell");
    user.setName("홍길동");
    user.setPassword("hong1234");

    dao.add(user);

    User user2 = dao.get(user.getId());
    assertThat(user2.getName(), is(user.getName()));
    assertThat(user2.getPassword(), is(user.getPassword()));
  }
}
```

#### 테스트 실행

- JUnit4 러너가 없어서 직접 실행해줘야 하는 불편함이 있다.  
  - JUnit5는 그냥 실행된다. JUnit Platform이 테스트를 발견하고 실행하는 역할을 한다.
- 아래와 같이 JUnitCore 클래스의 main() 메소드를 통해 실행할 수 있다. (`@RunWith` 같은 어노테이션을 붙일 수도 있다.)

```java
public class Main {

  public static void main(String[] args) {
    JUnitCore.main("org.mobilohas.bell.ch1.user.dao.UserDaoTest");
  }
}
```

- 위 테스트를 실행하면 아래와 같은 메시지가 뜨면서 테스트가 성공할 것이다.

```shell
JUnit version 4.12

Time: 0.446

OK (1 test)
```

- 테스트가 실패하면 OK 대신 FAILURES!! 라는 내용을 출력한다.
  - 어떤 것이 실패했는지도 알려준다.

## 3. 개발자를 위한 테스팅 프레임워크 JUnit

- 스프링의 핵심 기능 중 하나인 스프링 테스트 모듈도 JUnit을 이용한다.
  - 스프링의 기능을 익히기 위해서라도 JUnit을 사용할 줄 알아야 한다.

### 3-1. JUnit 테스트 실행 방법

- IDE를 이용해 JUnit 테스트 지원 도구를 사용하면 실행할 수 있다.

#### IDE

- 인텔리제에서는 Run을 실행하면 자체 JUnit Platform Launcher를 사용해 테스트를 실행한다.

#### 빌드 툴

- ANT, Maven, Gradle 등의 빌드 툴과 스크립트를 사용하고 있다면 test 명령을 통해 JUnit 테스트를 실행할 수 있다.

### 3-2. 테스트 결과의 일관성

- 아직 아쉬운 점이 있다. 테스트를 실행하기 전에 DB의 USER 테이블 데이터를 모두 삭제해줘야 한다는 점이다.
- 반복적으로 실행했을 때 테스트가 실패하기도 하고 성공하기도 한다면 이는 좋은 테스트라고 할 수 없다.
  - 코드에 변경사항이 없다면 테스트는 항상 동일한 결과를 내야 한다.

#### 동일한 결과를 보장하는 테스트

- 단위 테스트는 항상 일관성 있는 결과가 보장돼야 한다는 점을 잊어선 안 된다.
- DB에 남아 있는 데이터와 같은 외부 환경에 영향을 받지 말아야 하는 것은 물론이고, 테스트를 실행하는 순서를 바궈도 동일한 결과가 보장되도록 만들어야 한다.

### 3-3. 포괄적인 테스트

- 테스트를 안 만드는 것도 위험한 일이지만 성의 없이 테스트를 만드는 바람에 문제가 있는 코드인데도 테스트가 성공하게 만드는 건 더 위험하다.
  - 특히 한 가지 결과만 검증하고 마는 것은 상당히 위험하다.
- 개발자가 테스트를 직접 만들 때 자주 하는 실수가 하나 있다. 바로 성공하는 테스트만 골라서 만드는 것이다.
  - 조금만 신경써도 코드에서 발생할 수 있는 다양한 상황과 입력 값을 고려하는 포괄적인 테스트틀 만들 수 있다.
  - 스프링의 창시자 로드 존슨은 "항상 네거티브 테스트를 먼저 만들라"는 조언을 했다.
- 테스트를 작성할 때 부정적인 케이스를 먼저 만드는 습관을 들이는 게 좋다.
  - 예외적인 상황을 빠뜨리지 않는 꼼꼼한 개발이 가능하다!

### 3-4. 테스트가 이끄는 개발

#### 기능설계를 위한 테스트

- 테스트에는 만들고 싶은 기능에 대한 `조건`과 `행위`, `결과`에 대한 내용이 잘 표현되어 있다.
  - 이렇게 보면 테스트 코드는 마치 잘 작성된 하나의 기능정의서처럼 보인다.
  - 그래서 보통 기능설계, 구현, 테스트라는 일반적인 개발 흐름의 기능설계에 해당하는 부분을 테스트 코드가 일부분 담당하고 있다고 볼 수도 다.
  - 이런 식으로 추가하고 싶은 기능을 일반 언어가 아니라 테스트 코드로 표현해서, 마치 코드로 된 설계문서처럼 만들어놓은 것이라고 생각해보자.

#### 테스트 주도 개발 TDD

- "실패한 테스트를 성공시키기 위한 목적이 아닌 코드는 만들지 않는다"는 것이 TDD의 기본 원칙이다.
  - 이 원칙을 따랐다면 만들어진 모든 코드는 빠짐없이 테스트로 검증된 것이라고 볼 수 있다.
- 테스트는 자신감을, 한편으로는 마음의 여유를 주는 방법이다.
  - 테스트를 작성하고 이를 성공시키는 코드를 만드는 작업의 주기를 가능한 한 짥게 가져가도록 권장한다.
- 개발자의 머릿속에서는 계속 시뮬레이션이 돌아간다. 사실상 테스트가 미리 만들어지고 개발 중에 계속 실행된다고 볼 수 있지 않을까?
  - 문제가 발생한다면 코드를 수정할 것이다. 테스트가 실패했으니 테스트가 성공하도록 코드를 수정하는 것과 다를 바 없다.
  - 문제는 머릿속에서 진행되는 테스트는 제약이 심하고, 오류가 많고, 나중에 다시 반복하기가 힘들다는 점이다.
  - 차라리 테스트를 작성하면 이것이 TDD가 된다.
- 개발한 코드의 오류는 빨리 발견할수록 좋다. 쉽게 대응이 가능하기 때문이다.
- 혹시 테스트를 자주 실행하면 개발이 지연되지는 않을까 염려할지도 모르겠다.
  - 하지만 테스트는 애플리케이션 코드보다 상대적으로 작성하기 쉽다.
  - 각 테스트가 독립적이기 때문에, 코드의 양에 비해 작성하는 시간이 얼마 걸리지 않는다.
  - 게다가 테스트 덕분에 오류를 빨리 잡아낼 수 있어서 전체적인 개발 속도는 오히려 빨라진다.
  - 테스트 코드가 없으면 언제가는 웹 화면을 통한 테스트라도 하게 될 것이다.

### 3-5. 테스트 코드 개선

- 테스트를 실행할 때마다 반복되는 준비 작업을 별도의 메소드에 넣게 해주고, 이를 매번 테스트 메소드를 실행하기 전에 먼저 실행할 수 있다.

#### @Before

```java
public class UserDaoTest  {

  private UserDao dao;

  @Before
  public void setUp() throws Exception {
    ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");
    this.dao = context.getBean("userDao", UserDao.class);
  }
}
```

- JUnit4가 테스트를 수행하는 방식은 아래와 같다. (`JUnit4`의 `@Before`는 `JUnit5`의 `@BeforeEach`처럼 각 메소드가 실행되기 전에 실행된다. `JUnit5`에는 `@BeforeAll`이라는 개념이 추가되었다.)

1. `@Test`가 붙은 `public void`형의 파라미터 없는 테스트 메소드를 모두 찾는다.
2. 테스트 클래스의 오브젝트를 하나 만든다.
3.  `@Before`가 붙은 메소드가 있으면 실행한다.
4. `@Test`가 붙은 메소드를 하나 호출하고 테스트 결과를 저장해둔다.
5. `@After`가 붙은 메소드가 있으면 실행한다.
6. 나머지 테스트에 대해 2~5번 반복
7. 모든 테스트의 결과를 종합해서 돌려준다.

- 그런데 왜 테스트 메소드를 만들 때마다 새로운 오브젝트를 만드는 것일까?
  - JUnit 개발자는 각 테스트가 서로 영향을 주지 않고 독립적으로 실행됨을 확실히 보장해주기 위해 매번 새로운 오브젝트를 만들게 했다.
  - 어차피 다음 테스트 메소드가 실행될 때는 새로운 오브젝트가 만들어져서 다 초기화될 것이다.
- 하지만 공통적으로 사용되는 코드가 있다면 `@Before`를 사용하기보다는 분리하는 것이 나을 수 있다.

#### 픽스처

- 테스트를 수행하는 데 필요한 정보나 오브젝트를 `픽스처 Fixture`라고 한다.

# 참고자료

- 토비의 스프링, 이일민 저
