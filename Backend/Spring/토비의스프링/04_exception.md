# Chapter04. 예외

## 4-.1 사라진 SQLException

### 4-1-1. 초난감 예외처리

#### 예외 블랙홀

> 초난감 예외처리 코드 예시1

```java
try {
    ...
}
catch (SQLException e) {}
```

- 예외를 잡고는 아무것도 하지 않는다. 예외 발생을 무시해버리고 정상적인 상황인 것처럼 다음 라인으로 넘어가겠다는 분명한 의도가 있는 게 아니라면 연습 중에도 절대 만들어서는 안 되는 코드다!
- catch 블록을 써서 잡아내는 것까지는 정말 좋은데, 아무것도 하지 않는 것은 정말 위험한 일이다.
- 어떤 기능이 비정상적으로 동작하거나, 메모리나 리소스가 소진되거나, 예상치 못한 다른 문제를 일으킬 것이다.
- 최종적으로 오작동을 하거나 시스템 오류가 나서 운영자가 알아차렸을 때는 이미 조치를 취하기엔 너무 늦었다.
- 로그만 남긴다고 해서 해결될 문제는 아니다. 예외처리할 때 반드시 지켜야 할 핵심 원칙은 한 가지다.
  - 모든 예외는 적절하게 복구되든지 아니면 작업을 중단시키고 운영자 또는 개발자에게 분명하게 통보돼야 한다.

#### 무의미하고 무책임한 throws

> 초난감 예외처리 코드 예시2
 
```java
public void method1() throws Exception {
  method2();
}

public void method2() throws Exception {
  method3();
}

public void method3() throws Exception {}
```

- 이런 예외처리로는 의미 있는 정보를 얻을 수 없다.
- 적절한 처리를 통해 복구될 수 있는 예외상황을 제대로 다둘 수 있는 기회를 박탈하는 코드다.

### 4-1-2. 예외의 종류와 특징

- 자바에서 throw를 통해 발생시킬 수 있는 예외는 크게 세 가지가 있다.

#### Error

- `java.lang.Error` 클래스의 서브클래스
- 시스템에 뭔가 비정상적인 상황이 발생했을 경우 사용된다.
  - 그래서 주로 JVM에서 발생시키는 것이고 애플리케이션 코드에서 잡으려고 하면 안 된다.
  - `OutOfMemoryError`나 `ThreadDeath` 같은 에러는 `catch` 블록으로 잡아봤자 아무런 대응 방법이 없기 때문이다.

#### Exception과 체크 예외

- `java.lang.Exception` 클래스와 그 서브클래스
- `Exception` 클래스는 다시 `체크 예외 Checked Exception`와 `언체크 예외 Unchecked Exception`로 구분된다.
  - 전자는 `Exception` 클래스의 서브클래스지만, `RuntimeException`에 속하지 않는 것이고, 후자는 `RuntimeException`을 상속한 클래스다.
- 만약 사용할 메소드가 체크 예외를 던진다면, 이를 `catch` 문으로 잡거나, 다시 `throws`를 정의해 메소드 밖으로 던져야 한다. 그렇지 않으면 컴파일 에러가 발생한다.

#### RuntimeException과 언체크/런타임 예외

- 런타임 에러는 `catch` 문으로 잡거나 `throws`로 선언하지 않아도 된다. (물론 잡아도 된다.)
- 런타임 예외는 주로 프로그램의 오류가 있을때 발생하도록 의도된 것들이다.
  - ex) `NullPointerException`, `IllegalArgumentException`

### 4-1-3. 예외처리 방법

#### 예외 복구

- 예외 상황을 파악하고 문제를 해결해서 정상 상태로 돌려놓는 것이다.
  - ex1) `IOException` => 사용자에게 상황을 알려주고 다른 파일을 이용하도록 안내
  - ex2) 네트워크 문제로 인한 `SQLException` => 일정 시간 대기했다가 재시도.

#### 예외 회피

- 예외처리를 직접 담당하지 않고 자신을 호출한 쪽으로 던져버리는 것.
- 예외를 회피하는 것은 예외를 복구하는 것처럼 의도가 분명해야 한다.
  - 콜백/템플릿처럼 긴밀한 관계에 있는 다른 오브젝트에게 예외처리 책임을 분명히 지게 하거나, 자신을 사용하는 쪽에서 예외를 다루는 게 최선의 방법이라는 분명한 확신이 있어야 한다.

#### 예외 전환

- `Exception translation`
- 발생한 예외를 그대로 넘기는 게 아니라 적절한 예외로 전환해서 던지는 것.
- 예외 전환은 보통 두 가지 목적으로 사용된다.
1. 내부에서 발생한 예외를 그대로 던지는 것이 그 예외상황에 대한 적절한 의미를 부여해주지 못하는 경우에, 의미를 분명하게 해줄 수 있는 예외로 바꿔주기 위해서다. API가 발생하는 기술적인 로우레벨을 상황에 적합한 의미를 가진 예외로 변경하는 것이다.
    - 보통 전환하는 예외에 원래 발생한 예외를 담아서 `중첩 예외 nested exception`로 만드는 것이 좋다.
    - 중첩 예외는 `getCause()` 메소드를 이용해서 처음 발생한 예외가 무엇인지 확인할 수 있다.
2. 예외를 처리하기 쉽고 단순하게 만들기 위해 `포장 wrap`하는 것이다. 
    - 중첩 예외를 이용해 새로운 예외를 만들고 `원인 cause`이 되는 예외를 내부에 담아서 던지는 방식은 같다. 하지만 의미를 명확하게 하려고 다른 예외로 전환하는 것이 아니다.
    - 주로 예외처리를 강제하는 체크 예외를 언체크 예외인 런타임 예외로 바꾸는 경우에 사용한다.

### 4-1-4. 예외처리 전략

#### 런타임 예외의 보편화

- 자바의 엔터프라이즈 서버 환경 
  - 독립형 애플리케이션과 달리 서버의 특정 계층에서 예외가 발생했을 때 작업을 일시 중지하고 사용자와 바로 커뮤니케이션하면서 예외상황을 복구할 수 있는 방법은 없다.
  - 차라리 애플리케이션 차원에서 예외상황을 미리 파악하고, 예외가 발생하지 않도록 차단하는 게 좋다.
  - 또는 프로그램의 오류나 외부 환경으로 인해 예외가 발생하는 경우라면 빨리 해당 요청의 작업을 취소하고 서버 관리자나 개발자에게 통보해주는 편이 낫다.
- 이렇게 자바의 환경이 서버로 이동하면서 체크 예외의 활용도와 가치는 점점 떨어지고 있다.
  - 최근에 등장하는 표준 스펙 또는 오픈소스 프레임워크에서는 API가 발생시키는 예외를 체크 예외 대신 언체크 예외로 정의하는 것이 일반화되고 있다.
  - 예전에는 복구할 가능성이 조금이라도 있다면 체크 예외로 만든다고 생각했는데, 지금은 항상 복구할 수 있는 예외가 아니라면 일단 언체크 예외로 만드는 경향이 있다.

#### add() 메소드의 예외처리

- 예제의 `add()` 메소드는 `DuplicatedUserIdException`과 `SQLException`, 두 가지의 체크 예외를 던지게 되어 있다.
  - `DuplicatedUserIdException`는 충분히 복구 가능한 예외이므로, `add()` 메소드를 사용하는 쪽에서 잡아서 대응할 수 있다.
  - 하지만 `SQLException`은 대부분 복구 불가능한 예외이므로 잡아봤자 처리할 것도 없고, 결국 `throws`를 타고 계속 앞으로 전달되다가 애플리케이션 밖으로 던져질 것이다.
  - 그럴 바에는 그냥 런타임 예외로 포장해 던져버려서 그 밖의 메소드들이 신경 쓰지 않게 해주는 편이 낫다.
- `DuplicatedUserIdException`도 굳이 체크 예외로 둬야 하는 것은 아니다.
  - 어디에서든 잡아서 처리할 수 있다면 굳이 체크 예외로 만들지 않고 런타임 예외로 만드는 게 낫다.
  - 대신 메소드에 런타임 에러를 던진다는 것을 선언해줘야 한다. `public void add() throws DuplicateUserIdException`
  - 그래야 `add()` 메소드를 사용하는 코드를 만드는 개발자에게 의미 있는 정보를 전달해줄 수 있다.

> 아이디 중복 시 사용하는 예외

```java
public class DuplicateUserIdException extends RuntimeException {
  public DuplicateUserIdException(Throwable cause) {
    super(cause);
  }
}
```

> 예외 처리 전략을 적용한 `add()`

```java
public void add() throws DuplicateUserIdException {
  try {
    // JDBC를 이용해 user 정보를 DB에 추가하는 코드
  }
  catch (SQLException e) {
    if (e.getErrorCode() == MysqlErrorNumbers.ER_DUP_ENTRY)
      throw new DuplicateUserIdException(e); // 예외 전환
    else
      throw new RuntimeException(e); // 예외 포장
  }
}
```

#### 애플리케이션 예외

- 런타임 예외 중심 전략 = 낙관적 예외처리 기법
- 체크 예외 중심 전략 = 비관적인 접근 방식
- 반면 시스템 또는 외부의 예외상황이 원인이 아니라 애플리케이션 자체의 로직에 의해 의도적으로 발생시키고, 반드시 catch 해서 무엇인가 조치를 취하도록 요구하는 예외도 있다.
  - 이런 예외를 일반적을 애플리케이션 예외라고 한다.
- 방법은 2가지
1. 예외 상황에 대해 다른 종류의 리턴 값을 돌려주기
2. 정상적인 흐름을 따르는 코드는 그대로 두고, 잔고 부족과 같은 예외 상황에서는 비즈니스적인 의미를 띤 예외를 던지도록 만드는 것이다.
   - `if`문을 남발하지 않아도 되기 때문에 코드를 이해하기 편하다.
   - 이때 사용하는 예외를 `checked exception`으로 만들어 개발자가 잊지 않고 예외 상황에 대한 로직을 구현하도록 강제할 수 있다.


---

# 참고자료

- 토비의 스프링, 이일민 저
