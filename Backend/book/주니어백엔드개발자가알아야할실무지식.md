# 주니어 백엔드 개발자가 알아야 할 실무 지식, 최범균

- 인상적이었던 것. 당장 적용해볼 수 있는 것 위주로 기록

## 2. 느려진 서비스 진단

### 처리량과 응답시간

- 응답 시간 => 처리 시간을 줄여야 함 
  - TTFB(Time to First Byte): 응답 데이터 중 첫 번째 바이트가 도착할 때까지 걸린 시간
  - TTLB(Time to Last Byte): 응답 데이터의 마지막 바이트가 도착할 때까지 걸린 시간
- 처리량 => 동시에 처리할 수 있는 요청 수를 늘려야 함
  - TPS(Transaction Per Second)
  - RPS(Request Per Second)

### 성능 개선 기초

- 병목 지점 판단 => 모니터링 도구 사용해야 한다.
- 수직 확장 vs 수평 확장
- DB 커넥션 풀 크기 조절, DB 커넥션 대기 시간 및 유지 시간
- 서버 캐시 (로컬 vs 리모트)
  - 캐시 스탬피드 문제를 해결하기 위해 캐시를 사전에 적재할 수 있다.
  - 또한 데이터 정합성을 위해 원본이 변경되면 캐시를 무효화하도록 설정 필요. => 리모트 캐시 사용하거나, 로컬 캐시를 사용하되 이벤트 전파를 통해 캐시를 떨궈줘야 함
- 가비지 컬렉터. 상황에 맞는 GC 전략 채택
- 응답 데이터 압축 => gzip으로 압축하면 70% 이상 크기를 줄일 수 있고, 그만큼 전송 시간도 빨라진다.
  - html, css, js, json은 효과적 / 이미지나 zip 파일은 효과 없음
- 정적 자원과 브라우저 캐시 => `Cache-Control` 헤더를 활용
- 정적 자원과 CDN => 요청량 자체가 압도적인 경우 브라우저 캐시가 적용되기 전에 문제 발생 가능성.
  - CDN(Content Delivery Network)을 사용해 오리지 서버가 처리해야 할 트래픽을 상당히 줄일 수 있다.
- 대기 처리 => 트래픽이 폭증하는 경우에는 수용할 수 있는 수준의 트래픽만 받는 방법도 있다.
  - 서버 증설이 필요없다는 장점. 새로고침에 의한 트래픽 폭증 방지.

> #### Accept-Encoding 요청 헤더와 Content-Encoding 응답 헤더
> ```
> Accept-Encoding: gzip, deflate
> ```
> - Accept-Encoding 헤더를 통해 서버에 처리할 수 있는 압축 알고리즘을 알린다.
> - 서버는 Content-Encoding 응답 헤더를 통해 클라이언트에 전달

> #### 트래픽과 비용
> AWS와 같은 클라우드 서비스는 트래픽 양에 비례해 과금 => 데이터 크기를 줄이는 것만으로도 비용 절감

----

## 3. DB

- 핵심은 인덱스 설정
- 카디널리티 고려.
- 커버링 인덱스
- 비정규화. 미리 집계하기
- 오래된 데이터 삭제 혹은 분리 보관

### 페이지네이션 최적화

- `OFFSET`을 사용하면 그만큼 페이지를 읽어야 해서 오버헤드가 발생한다.
- `id` 값을 기준으로 조회할 수 있다면 아래와 같이 쿼리를 짜볼 수 있다.
  - 마지막으로 조회한 `id` 값을 클라이언트로부터 받아 조회하는 방법이다.

```sql
SELECT * FROM survey
WHERE id > 9836
LIMIT 10
```

### count 조회할 때 집계 테이블을 활용하자.

- 데이터가 늘어날 수록 `count` 쿼리의 속도는 느려진다.
- `count`를 조회하지 않는 방식으로 처리하거나, 집계 테이블을 두고 집계 쿼리를 따로 실행하는 방식을 사용할 수 있다.

### 주의사항

- 쿼리 타임아웃
- 상태 변경 기능은 복제 DB에서 조회 X 
  - 순간적으로 데이터가 일치하지 않을 수 있다.
  - 트랜잭션 문제 발생 가능서도 있다. => Primary에서 트랜잭션이 이뤄지는 동안 복제 DB에서 변경 대상에 대한 불일치 문제 가능성
- 배치 쿼리 실행 시간 증가 문제 => 커버링 인덱스 or 데이터를 일정 크기로 나눠 처리(Spring Batch Chunk 처리)
- 타입이 다른 칼럼 조인 주의 => 타입 변환이 자동으로 발생하여 인덱스를 활용하지 못한다.
- 테이블 변경 신중하게 => 서비스가 장시간 중단되는 상황이 발생할 수 있다.
- DB 최대 연결 개수 관리

### 실패와 트랜잭션

- 트랜잭션 범위를 잘 잡아서 원자성이 필요한 작업에 커밋 및 롤백이 한꺼번에 되도록 구성
- 외부 API 연동 작업이 섞이면 트랜잭션 처리 복잡
  - 외부 API는 성공했는데 DB 트랜잭션 실패하면 어떻게 처리할 것인가? 

-----

## 4. 외부 연동이 문제일 때 살펴봐야 할 것들

- 연동 서비스의 문제를 완전히 차단하기는 어렵다. 하지만 그 영향은 줄일 수 있다.

### 타임아웃

- 외부 API에 성능 문제 발생
  - 그런데 외부 API가 연동된 요청이 모든 톰캣 스레드를 점유하고 있다고 가정.
  - 만약 이때 외부 API를 사용하지 않는 요청이 들어오면 어떻게 될까? 외부 API의 지연 때문에 다른 기능도 사용하지 못한다.
  - 또한 사용자는 응답이 올 때까지 기다리지 않는다. 새로 고침과 같은 방법으로 새로운 요청을 보낸다.
- 반응 없는 무한 대기보다는 에러 화면이라도 보는 것이 낫다.
- 대충 아래와 같은 타임아웃 시간을 설정하고 추이를 보면서 조정하는 것이 좋다.
  - `연결 타임아웃`: 3~5초
  - `읽기 타임아웃`: 5~30초
- 타임아웃 시간이 너무 짧으면 연동 서비스가 정상 처리했음에도 불구하고 타임아웃 에러가 발생할 수 있다.
  - 결제처럼 민감한 기능은 읽기 타임아웃 시간을 약간 길게 설정해서 간헐적으로 연동 시간이 길어지더라도 정상적으로 처리할 수 있어야 한다.

### 재시도

- 재시도 가능 조건
  - 단순 조회 기능
  - 연결 타임아웃
  - `멱등성 idempotent`을 가진 변경 기능
- 읽기 타임아웃은 재시도할 때 주의해야 한다.

> #### 멱등성
> - 연산을 여러 번 적용해도 결과가 달라지지 않는 성질을 말한다.

- 재시도에서 `횟수`와 `간격` 2가지 요소를 결정해서 정해야 한다.
  - ex) 간격 - 지수 백오프 전략
- 성능이 느려진 상태에서 새로운 요청까지 더해지는 연동 서비스의 성능은 더 나빠진다.
  - 연동 서비스의 성능 상황을 고려해야 한다.

### 동시 요청 제한

- 순간적으로 트래픽이 몰릴 때 문제 발생 가능성 높아짐.
  - 완화 방법: 연동 서비스에 요청을 일정 수준 이상으로 보내지 않는 것이다.
  - `503 Service Unavailable` HTTP 상태 코드를 사용해 과부하 상황임을 알린다.

> #### 벌크헤드 Bulkhead
> - 벌크헤드 패턴은 각 구성 요소를 격리함으로써 한 구성 요소의 장애가 다른 요소에 영향을 주지 않도록 하는 설계 패턴이다.

### 서킷 브레이커

- 연동 서비스가 장애 상황일 때는 연동 대신 바로 에러를 응답하고, 정상화되었을 때 연동을 재개하면 연동 서비스의 장애가 주는 영향을 줄일 수 있다.
  - `빠른 실패 fail fast`
- 서킷 브레이크의 상태
  - `Closed`
  - `Open`: 연동을 수행하지 않고 바로 에러 응답 리턴.
  - `Half-Open`: 일정 개수 혹은 시간동안 유지하는 상태. 연동에 성공하면 닫힘 상태로 복귀, 실패하면 다시 열림 상태로 전환
- 임계치는 보통 아래 조건 중 하나를 사용
  - 시간 기준 오류 발생 비율
  - 개수 기준 오류 발생 비율

### 외부 연동과 DB 연동

- 트랜잭션 롤백 시, 외부 연동 시스템에 대한 보상 호출

1. 일정 주기로 두 시스템의 데이터가 일치하는지 확인하고 보정하는 방법
2. 성공 확인 API를 호출하는 방식
3. 취소 API를 호출하는 방식 (단 연동 서비스가 제공해줘야 가능)

- 보상 호출 또한 실패할 수 있음을 인지해야 한다.
- 트랜잭션을 외부 연동 시스템과 함께 사용할 때는 주의해야 한다. DB 커넥션 풀이 소진되는 문제가 발생할 수도 있다.
- 따라서 DB 연동과 무관하다면 트랜잭션 밖에서 외부 서비스를 호출할 수도 있다.
  - 하지만 트랜잭션 커밋 이후 외부 연동이 실패하면 롤백이 불가능하다. => 후처리에 대한 고민 필요
  - 보상 트랙잭션, 기능 특성에 따른 데이터 후보정

### HTTP 커넥션 풀

- HTTP 커넥션 풀을 사용할 때는 다음 3가지를 고려해야 한다.
1. HTTP 커넥션 풀의 크기
2. 풀에서 HTTP 커넥션을 가져올 때까지 대기하는 시간
3. HTTP 커넥션을 유지할 시간 (keep alive)

### 연동 서비스 이중화

- 연동 서비스를 이중화할지 여부를 결정할 때는 다음 2가지를 반드시 따져봐야 한다.
1. 해당 기능이 서비스의 핵심인지 여부
2. 이중화 비용이 감당 가능한 수준인지

----

## 5. 비동기 ㅇ녀동, 언제 어떻게 써야 할까?

### 동기와 비동기

- 동기 방식이 외부 연동을 만났을 때 고려해야할 것
  - 외부 연동 실패가 전체 기능의 실패인지 확인. 나중에 후처리할 수 있도록 지급 실패 내역을 따로 남기는 방식으로 코드를 작성
  - 연동하는 외부 서비스의 응답 시간도 고려
- 외부 연동 결과가 필요한 게 아니라면, 동기 방식 대신 비동기 방식으로 연동하는 것을 고민해볼 필요가 있다.
  - ex) 푸시 서비스, 포인트 서비스, 검색 서비스, SMS 발송 서비스
1. 연동에 약간의 시차가 생겨도 문제가 되지 않는 경우
2. 일부 기능은 실패했을 때 재시도 가능
3. 연동에 실패했을 때 나중에 수동으로 처리할 수 있는 기능도 있다.
4. 연동에 실패했을 때 무시해도 되는 기능도 있다.

### 별도 스레드로 실행

- `@Async` 비동기 실행
- 비동기로 실행되는 코드는 에러가 발생해도 `catch` 블록에서 잡히지 않는 것에 주의
- 또한, 비동기로 발생한 exception은 `@Transactional`의 롤백에도 전혀 영향을 미치지 않는다.

> #### 스레드와 메모리
> - 스레드는 자체적으로 일정 크기의 메모리를 사용. 최소 수 백 KB
> - 스레드가 너무 많으면 스케줄링에 많은 CPU 시간을 소모해야 한다. => 실행 시간 느려짐
> - 스레드 풀: 스레드를 일정 개수로 유지. 스레드 부족해지면 대기해야 함.
> - I/O 작업은 가상 스레드나 코루틴 같은 것을 사용하는 것도 방법이다. (경량 스레드)

### 메시징

- 메시징 시스템은 데이터 연동이 필요한 두 시스템 사이에 위치한다.
- 이점
1. 두 시스템이 서로 영향을 주지 않는다. 시스템의 성능에 맞게 메시지를 전달할 수 있다. 즉, 메시징 시스템은 중간에서 메시지를 보관하는 버퍼 역할을 한다.
2. 확장이 용이하다.

- Kafka, RabbitMQ, Redis stream 혹은 pub/sub, pulsa 등의 도구
- 메시지 유실을 고려해야 한다. 오류 처리를 위해 선택할 수 있는 방법들
1. 무시한다.
2. 재시도한다.
3. 실패 로그를 남긴다.

- 메시지마다 고유 식별자를 사용하면 메시지 소비자가 중복 메시지 여부를 판단하는 데 도움이 된다.
- 실패 로그를 남기면 나중에 후처리를 하는 데 사용. 따라서 로그는 후처리에 필요한 데이터를 담고 있어야 한다.
- 또한, 잘못된 메시지가 전송되는 문제를 방지하려면 트랜잭션이 끝난 뒤에 메시지를 전송해야 한다.

#### 메시지 중복 처리 문제

1. 생산자가 같은 데이터를 가진 메시지를 두 번 전송
2. 소비자가 메시지를 처리하는 과정에서 오류가 발생해서 메시지를 재수신

- 메시지에 고유한 ID를 부여해 처리 가능. 메시지 처리 여부는 DB 테이블에 기록하거나 메모리에 `집합 Set`으로 관리
- 혹은 멱등성을 갖도록 API를 구현할 수도 있다.
- 소비자를 구현할 때 고려할 점은 메시지를 잘 소비하고 있는지 모니터링하는 것이다.

#### 이벤트와 커맨드 메시지

- 이벤트: 어떤 일이 발생했음을 알려주는 메시지. 정해진 수신처가 없다. 따라서 소비자 확장에 적합하다.
- 커맨드: 메시지를 수신할 측의 기능 실행에 초점

> #### 궁극적 일관성 eventual consistency
> - 주로 분산 시스템에서 데이터 복제를 다룰 때 사용
> - 비동기 메시징 방식도 이 궁극적 일관성과 유사한 특성

### 트랜잭션 아웃박스 패턴

- 메시지 데이터 자체가 유실되지 않도록 보장하는 방법 => DB에 저장
  - 이 방식이 `트랜잭션 아웃박스 패턴 Transactional Outbox Pattern`의 핵심
- 아래 2가지 작업을 수행
1. 실제 업무 로직에 필요한 DB 변경 작업을 수행
2. 메시지 데이터를 아웃박스 테이블에 추가

- 발송 완료를 표시하는 방법
1. 아웃박스 테이블에 발송 상태 칼럼 (저자의 선호 방식: 모니터링이 쉽다.)
2. 성공적으로 전송한 마지막 메시지 ID를 별도로 기록

#### 아웃 박스 테이블의 구조

- 아래 구조를 참고해 상황에 맞게 변형

| 칼럼            | 타입          | 설명                                                 |
|:--------------|:------------|:---------------------------------------------------|
| `id`          | `big int`   | auto increment                                     |
| `messageID`   | `varchar`   | 메시지 고유 ID                                          |
| `messageType` | `varchar`   | 메시지 타입                                             |
| `payload`     | `clob`      | 메시지 데이터                                            |
| `status`      | `varchar`   | 이벤트 처리 상태<br>WAITING(대기)<br>DONE(완료)<br>FAILED(실패) |
| `failCount`   | `int`       | 실패 횟수                                              |
| `occuredAt`   | `timestamp` | 메시지 발생 시간                                          |
| `processedAt` | `timestamp` | 메시지 처리 시간                                          |
| `failedAt`    | `timestamp` | 마지막 실패 시간                                          |

- '실패함' 상태로 바뀐 메시지는 알맞은 후속 조치 필요.
- `memo`, `remark`와 같은 칼럼을 추가해서 실패 메시지를 아웃박스 테이블에 기록하면, 실패 이유를 파악하는 데 도움

> #### 참고
> - 메시지 발송이 실패했다고 바로 '실패' 상태로 바꾸지는 말자.
> - 일시적으로 문제가 발생한 것이라면 한두 차례 재시도를 통해 성공적으로 메시지를 발송할 수 있다.

### 배치 전송

- 실행 과정
1. DB에서 전송할 데이터 조회
2. 조회한 결과를 파일로 기록
3. 파일을 연동 시스템에 전송

- 같은 조직 내에서 데이터를 전달하고 싶다면, 읽기 전용으로 DB를 열어주는 것도 방법이다.
  - 개발 시간이 부족할 때 선택.

### CDC (Change Data Capture)

- 변경된 데이터를 추적하고 판별해서 변경된 데이터로 작업을 수행할 수 있도록 하는 소프트웨어 설계 패턴
- CDC 처리기에는 롤백된 데이터가 전달되지 않는다. 또한 잘못된 순서로 데이터가 전달되는 일도 없다.
- 크게 2가지 형태로 대상 시스템에 변경 데이터를 전파
1. 변경 데이터를 그대로 대상 시스템에 전파
2. 변경 데이터를 가공/변환해서 대상 시스템에 전파

- 변경 데이터를 그대로 대상 시스템에 전파하는 방법은 두 시스템의 데이터가 거의 1대 1의 관계를 가질 때 적합하다.
- 변경 데이터를 그대로 전파하지 않고 변환해서 전파해야 할 때도 있다.
- 목적에 따라 CDC 처리기는 DB, 메시징 시스템, API 등 다양한 대상에 데이터를 전파할 수 있다.

#### 데이터 위치

- CDC 처리기는 변경 데이터를 어디까지 처리했는지 기록해야 한다.
- MySQL은 바이너리 로그를 통해 CDC 구현. 
  - 각 로그 항목은 변경된 데이터와 로그 파일에서의 위치(포지션) 값을 갖는다. 
  - 이 위치를 기록해야 CDC 처리기를 재시작할 때 마지막으로 조회한 로그부터 읽어올 수 있다.

#### 유용한 경우

- 시스템이 복잡해서 연동 코드를 넣기 부담스러울 때.
- 코드 수정을 하지 않고도 CDC를 사용해 타 시스템에 관련 데이터를 전파할 수 있다.
