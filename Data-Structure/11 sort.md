# 11 정렬 Sort 

## 출처

- C언어로 쉽게 풀어쓴 자료구조(천인국, 공용해, 하상호 저)

<br/>

<hr/>

## 목차

1. [정렬의 개념](#1-정렬의-개념) <br/>
   &nbsp; 1-1. [정렬이란](#1-1-정렬이란) <br/>
   &nbsp; 1-2. [정렬의 분류](#1-2-정렬의-분류) <br/>

<br/>

2. [정렬의 종류](#2-정렬의-종류) <br/>
   &nbsp; 2-1. [선택 정렬](#2-1-선택-정렬-selection-sort) <br/>
   &nbsp; 2-2. [삽입 정렬](#2-2-삽입-정렬-insertion-sort) <br/>
   &nbsp; 2-3. [버블 정렬](#2-3-버블-정렬-bubble-sort) <br/>
   &nbsp; 2-4. [셸 정렬](#2-4-셸-정렬-shell-sort) <br/>
   &nbsp; 2-5. [합병 정렬](#2-5-합병-정렬-merge-sort) <br/>
   &nbsp; 2-6. [퀵 정렬](#2-6-퀵-정렬-quick-sort) <br/>
   &nbsp; 2-7. [기수 정렬](#2-7-기수-정렬-radix-sort) <br/>

<br/>

3. [정렬 알고리즘의 비교](#3-정렬-알고리즘의-비교) <br/>

<br/><br/>

<hr/>

## 1. 정렬의 개념

<br/>

<hr/>

### 1-1. 정렬이란?

<br/>

정렬이란 데이터나 물건을 크기를 기준으로 오름차순이나 내림차순으로 나열하는 것을 의미한다. 정렬은 컴퓨터 공학을 포함한 모든 과학기술 분야에서 가장 기본적이고 중요한 알고리즘이다. 정렬은 특히 **자료 탐색**에 가장 핵심이 된다. 만약 사전이 알파벳으로 정렬되어있지 않다면 특정 단어를 찾는 것은 굉장히 어려운 일이 될 것이다. 

<br/>

정렬시켜야할 대상을 **레코드(record)**라고 부르고, 이 레코드는 다시 **필드(field)**라고 하는 단위로 나누어진다. 여러 필드 중에서 특히 레코드를 식별해주는 역할을 하는 필드를 **키(key)**라고 한다. 정렬이란 키값을 기준으로 순서를 재배열하는 것이다.

<img src="img/sort_term.jpg">

<br/>

<hr/>

### 1-2. 정렬의 분류

<br/>

모든 경우에 최적인 정렬 알고리즘은 없다. 자료의 초기화 여부에 따라 이동 횟수와 비교 횟수가 달라지기 때문이다. 일반적으로 둘은 서로 비례관계는 아니다. 이동 횟수는 적지만 비교 횟수가 많을 수도 있고, 그 반대가 될 수도 있다. 여기서 비교 연산과 이동 연산에 대해 알아보자.

- 비교 연산: for문과 while문의 비교 구문과 그 내부의 비교구문의 연산

- 이동 연산: 대입 연산자를 사용해 요소를 이동시키는 연산 (a = b)

참고로, 비교 연산보다 **이동 연산이 더 많은 오버 헤드가 발생**한다.

<br/>

정렬 알고리즘은 단순하지만 비효율적인 알고리즘, 복잡하지만 효율적인 정렬 알고리즘으로 나눌 수 있다. 단순과 복잡함의 기준을 코드 라인 수라고 생각하면 된다. 

- 단순, 비효율적 알고리즘: 삽입, 선택, 버블 정렬 등

- 복잡, 효율적 알고리즘: 퀵, 히프, 합병, 기수 정렬 등

만약 자료의 개수가 많다면 복잡하고 효율적인 알고리즘을 사용하는 것이 좋다. 

<br/>

외부 메모리 사용 여부에 따라 정렬은 내부 정렬(internal sorting)과 외부 정렬(external sorting)으로 나눌 수 있다. 내부 정렬은 모든 데이터가 메인 메모리에 있으며, 이 데이터만 취급하는 것을 의미한다. 반면, 외부 정렬은 데이터가 너무 많아 SSD, HDD와 같은 외부 기억 장치에 대부분의 데이터가 있고 일부만 메모리에 가져와 정렬하고 외부 기억 장치에 다시 저장하는 방식이다. 당연히 내부 정렬이 외부 정렬보다 빠르다. 

<br/>

정렬 알고리즘은 **안정성(stability)**을 기준으로 분류할 수도 있다. 여기서 안정성이란 동일한 키 값을 갖는 **레코드들의 상대적인 위치가 정렬 후에도 변하지 않는 것**을 의미한다. 즉, 불필요한 이동 연산이 일어나지 않는다는 것을 내포한다. 안정성을 가진 정렬은 삽입 정렬, 버블 정렬, 합병 정렬 등이 있다.

<br/><br/>

<hr/>

## 2. 정렬의 종류

<br/>

<hr/>

### 2-1. 선택 정렬 selection sort

<br/>

선택 정렬은 논리적으로 가장 간단한 정렬이다. 가장 작은 값을 찾아 맨 앞으로 이동시키고, 다음 단계에서는 그 다음으로 작은 값을 찾아 그 뒤의 요소와 교환시킨다. 요소가 n개라고 했을 때, n-1번만큼만 반복하면 된다. 

- 선택 정렬의 pseudo-code

```
selection_sort(A, n) 

for i←0 to n-2 do 
    least ← A[i], A[i+1],..., A[n-1] 중에서 가장 작은 값의 인덱스;
    A[i]와 A[least]의 교환;
    i++;
```

- 선택 정렬의 코드

```c
#define SWAP(x, y, t) ( (t)=(x), (x)=(y), (y)=(t) )

void selection_sort(int list[], int n)
{
    int i, j, least, temp;
    for(i=0; i<n-1; i++) {
        least = i;
        for(j=i+1; j<n; j++) // 최소값 탐색
            if(list[j]<list[least]) 
                least = j;

        SWAP(list[i], list[least], temp);
    }
}
```

코드 링크: [선택 정렬 코드](https://github.com/pythonstrup/TIL/tree/main/Data-Structure/sort/selection.c)

<br/>

선택 정렬의 비교 회수와 이동 횟수를 알아보자.

- 비교: (n-1) + (n-2) + ... + 1 = n(n-1)/2 = O(n^2)

- 이동: 3(n-1)

전체적인 시간복잡도는 O(n^2)이라고 할 수 있다. 또한 안정성을 만족하지 않는다는 것을 알 수 있다.

<br/>

<hr/>

### 2-2. 삽입 정렬 Insertion sort

<br/>

삽입 정렬은 정렬되어 있는 부분에 새로운 레코드를 올바른 위치에 삽입하는 과정을 반복한다.

<img src="img/insertion.jpg">

<br/>

- 삽입 정렬의 pseudo-code

```
insertion_sort(A, n)
    for i ← 1 to n-1 do
        key ← A[i];
        j ← i-1;
        while j ≥ 0 and A[j] > key do
            A[j+1] ← A[j];
            j ← j-1;
    A[j+1] ← key
```

<br/>

코드 링크: [삽입 정렬 코드](https://github.com/pythonstrup/TIL/tree/main/Data-Structure/sort/insertion.c)

<br/>

삽입 정렬이 최선의 경우일 때와 최악일 경우일 때의 비교 회수, 이동 횟수 및 시간복잡도를 알아보자.

- 최선의 경우 O(n): 이미 정렬되어 있을 때
    - 비교만 n-1번 일어난다.

<br/>

- 최악의 경우 O(n^2): 역순으로 정렬되어 있을 때
    - 모든 단계에서 앞에 있는 자료를 전부다 오른쪽으로 이동시켜야한다.
    - 비교: (n-1) + (n-2) + ... + 1 = n(n-1)/2 = O(n^2)
    - 이동: n(n-1)/2 + 2(n-1) = O(n^2)

평균적으로 O(n^2)의 시간복잡도를 가지며, 많은 이동이 필요한 정렬이므로 레코드 수가 많을 경우 불리하다. 그러나 안정된 정렬 방법이고 대부분이 정렬 되어있는 레코드를 정렬할 때 매우 효율적이라는 장점이 있다. 

<br/>

<hr/>

### 2-3. 버블 정렬 Bubble sort

<br/>

버블은 코드로 표현했을 때 가장 쉬운 정렬 방법이다. 정말 단순하다. 인접한 2개의 레코드를 비교하여 순서대로 되어있지 않으면 서로 교환한다.

- 버블 정렬의 pseudo-code

```
BubbleSort(A, n)
    for i←n-1 to 1 do 
        for j←0 to i-1 do 
            j와 j+1번째의 요소가 크기 순이 아니면 교환
            j++;
        i--;
```

<br/>

코드 링크: [버블 정렬 코드](https://github.com/pythonstrup/TIL/tree/main/Data-Structure/sort/bubble.c)

<br/>

버블정렬의 복잡도를 분석해보자.

- 비교 횟수는 최선, 평균, 최악의 경우 모두 똑같다.
    - n(n-1)/2 = O(n^2)
<br/>
- 이동 횟수
    - 최선의 경우(이미 정렬된 경우): 0 회
    - 최악의 경우(역순으로 정렬): 3 * 비교횟수(n-1)
    - 평균: O(n^2)

위에서 말했다시피, 이동연산은 비교연산보다 많은 오버 헤드가 발생하기 때문에 레코드의 이동이 많은 버블 정렬은 효율과는 거리가 멀다.

<br/>

<hr/>

### 2-4. 셸 정렬 Shell sort

<br/>

<br/>

코드 링크: [셸 정렬 코드](https://github.com/pythonstrup/TIL/tree/main/Data-Structure/sort/shell.c)

<br/>

<hr/>

### 2-5. 합병 정렬 Merge sort

<br/>

<br/>

코드 링크: [합병 정렬 코드](https://github.com/pythonstrup/TIL/tree/main/Data-Structure/sort/merge.c)

<br/>

<hr/>

### 2-6. 퀵 정렬 Quick sort

<br/>

<br/>

코드 링크: [퀵 정렬 코드](https://github.com/pythonstrup/TIL/tree/main/Data-Structure/sort/quick.c)

<br/>

<hr/>

### 2-7. 기수 정렬 Radix sort

<br/>

<br/>

코드 링크: [기수 정렬 코드](https://github.com/pythonstrup/TIL/tree/main/Data-Structure/sort/radix.c)

<br/>

<hr/>

## 3. 정렬 알고리즘의 비교

<br/>

<br/>

<hr/>