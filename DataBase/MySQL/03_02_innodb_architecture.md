# Architecture

## 2. InnoDB 스토리지 엔진 아키텍처

- MySQL에서 사용할 수 있는 스토리지 엔진 중 거의 유일하게 레코드 기반의 잠금을 제공.
    - 덕분에 높은 동시성 처리가 가능하고 안정적이며 성능이 뛰어나다.

<img src="img/architecture07.jpg">


### 2-1. 프라이머리 키에 의한 클러스터링

- InnoDB의 모든 테이블은 기본적으로 프라이머리 키를 기준으로 클러스터링되어 저장된다.
    - **프라이머리 키 값의 순서대로 디스크에 저당된다는 뜻**
    - 모든 세컨더리 인덱스는 레코드의 주소 대신 프라이머리 키의 값을 논리적인 주소로 사용한다.
    - 프라이머리 키가 클러스터링 인덱스이기 때문에 프라이머리 키를 이용한 레인지 스캔은 상당히 빨리 처리될 수 있다.
    - 결과적으로 쿼리의 실행 계획에서 프라이머리 키는 기본적으로 다른 보조 인덱스에 비해 비중이 높게 설정된다.
- InnoDB 스토리지 엔진과 달리 MyISAM 스토리지 엔진에서는 클러스터링 키를 지원하지 않는다.
    - 그래서 MyISAM 테이블에서는 프라이머리 키와 세컨더리 인덱스는 구조적으로 아무런 차이가 없다.
    - 프라이머리 키는 유니크 제약을 가진 세컨더리 인덱스일 뿐이다.
    - MyISAM 테이블의 프라이머리 키를 포함한 모든 인덱스는 `물리적인 레코드의 주소 값 ROWID`을 가진다.

## 2-2. 외래 키 지원

- 외래 키에 대한 지원은 InnoDB 스토리지 엔진 레벨에서 지원하는 기능으로 MyISAM이나 MEMORY 테이블에서는 사용할 수 없다.
- 외래 키는 서버 운영의 불편함 때문에 서비스용 데이터베이스에서는 생성하지 않는 경우도 자주 있는데, 그렇다 하더라도 개발 환경의 데이터베이스에서는 좋은 가이드 역할을 할 수 있다.
    - 외래 키 생성 시: 부모 테이블, 자식 테이블 모두 해당 칼럼에 인덱스 생성 필요
    - 변경 시: 반드시 부모 테이블이나 자식 테이블에 데이터가 있는지 체크하는 작업이 필요 => 잠금이 여러 테이블로 전파 => 데드락 발생 가능성 상승(그러므로 주의하는 것이 좋다.)
- `foreign_key_checks` 시스템 변수를 OFF로 설정하면 외래 키 관계에 대한 체크 작업을 일시적으로 멈출 수 있다.

```shell
mysql > SET foreign_key_checks=OFF;
# 작업 완료 후...
mysql > SET foreign_key_checks=ON;
```

- 아래와 같이 세션에서만 멈추게 하는 것을 추천

```shell
mysql > SET SESSION foreign_key_checks=OFF;
# 작업 완료 후...
mysql > SET SESSION foreign_key_checks=ON;
```

- 반드시 일관성을 맞춰준 다음 다시 외래 키 체크 기능을 활성화해야 한다.

### 2-3. MVCC (Multi Version Concurrency Control)

- 일반적으로 레코드 레벨의 트랜잭션을 지원하는 DBMS에서 제공하는 기능이며, MVCC의 가장 큰 목적은 잠금을 사용하지 않는 일관된 읽기를 제공하는 데 있다.
    - InnoDB는 언두 로그(Undo log)를 이용해 이 기능을 구현한다.
    - 여기서 멀티 버전이라 함은 하나의 레코드에 대해 여러 개의 버전이 동시에 관리된다는 의미다.
- 테이블이 `UPDATE`를 하면.
    - InnoDB 버퍼 풀은 업데이트가 되고, 그 이전 기록이 언두 로그에 저장된다. (COMMIT 전이기 때문에 디스크에는 아직 안 들어간 상태)
    - 이 때 격리 수준이 `READ_UNCOMMITTED`인 경우 버퍼 풀을 그대로 읽어오기 때문에 업데이트된 내용이 조회된다. (Dirty Read)
    - `COMMIT` 명령이 실행되면 InnoDB는 더 이상의 변경 작업 없이 지금의 상태를 영구적인 데이터로 만들어 버린다.
    - 하지만 `ROLLBACK`을 실행하면 InnoDB는 언두 영역에 있는 백업된 데이터르르 InnoDB 버퍼 풀로 다시 복구하고, 언두 영역의 내용을 삭제해버린다.
- `COMMIT`이 된다고 언두 영역을 바로 삭제하지는 않는다. 이 언두 영역을 필요로 하는 트랜잭션이 더는 없을 때 비로소 삭제된다.

### 2-4. 잠금 없는 일관된 읽기 (Non-Locking Consistent Read)

- InnoDB 스토리지 엔진은 MVCC 기술을 이용해 잠금을 걸지 않고 읽기 작업을 수행한다.
    - 잠금을 걸지 않기 때문에 InnoDB에서 읽기 작업은 다른 트랜잭션이 가지고 있는 잠금을 기다리지 않고, 읽기 작업이 가능하다.
    - 격리 수준이 `SERIALIZABLE`이 아니라면 `INSERT`와 연결되지 않은 순수한 `읽기 SELECT` 작업은 다른 트랜잭션의 변경 작업과 관계없이 항상 잠금을 대기하지 않고 바로 실행한다.
- 이를 '잠금 없는 일관된 읽기'라고 표현하며, InnoDB에서는 변경되기 전의 데이터를 읽기 위해 언두 로그를 사용한다.
- 오랜 시간 동안 활성 상태인 트랜잭션으로 인해 MySQL 서버가 느려지거나 문제가 발생할 때가 가끔 있는데, 바로 이러한 일관된 읽기를 위해 언두 로그를 삭제하지 못하고 계속 유지해야 하기 때문에 발생하는 문제다.


### 2-5. 자동 데드락 감지

- InnoDB 스토리지 엔진은 내부적으로 잠금이 교착 상태에 빠지지 않았는지 체크하기 위해 `잠금 대기 목록을 그래프 Wait-for List` 형태로 관리한다.
    - 데드락 감지 스레드를 가지고 있어서 데드락 감지 스레드가 주기적으로 잠금 대기 그래프를 검사해 교착 상태에 빠진 트랜잭션들을 찾아서 그중 하나를 강제 종료한다.
    - 우선순위는 언두 로그의 양으로 결정. => 더 적게 가진 트랜잭션이 일반적으로 롤백된다.
- 데드락 감지 스레드가 MySQL 엔진에서 관리되는 테이블 잠금(LOCK TABLES 명령으로 잠긴 테이블)을 볼 수 없다.
    - innodb_table_locks 변수를 활성화하면 테이블 잠금 레벨까지 감지할 수 있게 된다. (특별한 이유가 없다면 활성화!)
- 자동 데드락 감지 스레드 없이도 데드락 상황을 모면할 수 있는 방법이 있다.
    - `innodb_lock_wait_timeout` 변수를 활성화하면 데드락 상황에서 일정 시간이 지나면 자동으로 요청이 실패하고 에러 메시지를 반환하게 된다.

> #### 참고
> - 만약 PK 또는 세컨더리 인덱스를 기반으로 매우 높은 동시성 처리를 요구하는 서비스가 있다면 `innodb_deadlock_detect`를 비활성화해서 성능 비교를 해보는 것도 새로운 기회가 될 것이다.

### 2-6. 자동화된 장애 복구

- InnoDB에는 손실이나 장애로부터 데이터를 보호하기 위한 여러 가지 메커니즘이 탑재돼 있다.
    - MySQL이 시작될 때 완료되지 못한 트랜잭션이나 디스크에 일부만 기록된 (Partial write) 데이터 페이지 등에 대한 일련의 복구 작업이 자동으로 진행된다.
- 만약 자동으로 복구될 수 없는 손상이 있다면 자동 복구를 멈추고 MySQL 서버는 종료돼 버린다.
    - 이때는 MySQL 서버의 설정 파일에 `innodb_force_recovery` 변수를 설정해 MySQL 서버를 시작해야 한다.
    - 이 설정값은 MySQL 서버가 시작될 때 InnoDB 스토리지 엔진이 데이터 파일이나 로그 파일의 손상 여부 검사 과정을 선별적으로 진행할 수 있게 한다.
- `innodb_force_recovery` 옵션에서 설정 가능한 값은 1 ~ 6이다.
    - 1: 테이블스페이스나 데이터나 인덱스 페이지의 손상 무시.
    - 2: 메인 스레드를 시작하지 않고 MySQL 서버 시작.
    - 3: 롤백에 대비해 변경 전의 데이터를 언두 영역에 기록.
    - 4: 인서트 버퍼에 저장해두고 나중에 처리.
    - 5: 언두 레코드를 통해 데이터 페이지를 복구하고, 리두 로그를 적용해 종료 시점이나 장애 발생 시점의 상태를 재현. 커밋되지 않은 트랜잭션에서 변경한 작업은 모두 롤백 처리. 하지만 InnoDB의 언두 로그를 사용할 수 없다면 InnoDB 엔진의 에러로 MySQL 서버를 시작할 수 없다는 함정.
    - 6: 리두 로그를 모두 무시한 채로 MySQL 서버 시작(원래 MySQL 서버는 리두 로그가 손상되면 시작되지 않는다.)
- 위와 같이 진행해도 MySQL 서버가 시작되지 않으면 백업을 이용해 다시 구축하는 방법밖에 없다.

### 2-7. InnoDB 버퍼 풀

- InnoDB 스토리지 엔진에서 가장 핵심적인 부분
    - 디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해 두는 공간.
    - 쓰기 작업을 지연시켜 일괄 작업으로 처리할 수 있게 해주는 버퍼 역할도 같이 한다.
- 일반적인 애플리케이션에서는 `INSERT`, `UPDATE`, `DELETE`처럼 데이터를 변경하는 쿼리는 데이터 파일의 이곳저곳에 위치한 레코드를 변경하기 때문에 랜덤한 디스크 작업을 발생시킨다.
    - 하지만 버퍼 풀이 이러한 변경된 데이터를 모아서 처리하면 랜덤한 디스크 작업의 횟수를 줄일 수 있다.

#### 2-7-1. 버퍼 풀의 크기 설정

- 일반적으로 전체 물리 메모리의 80% 정도를 InnoDB의 버퍼 풀로 설정하라는 내용도 있으나, 그렇게 단순하게 설정해서는 안되는 값이다.
    - 운영체제와 각 클라이언트 스레드가 사용할 메모리도 충분히 고려해서 설정해야 한다.
    - MySQL 서버 내에서 메모리를 필요로 하는 부분은 크게 없지만 아주 독특한 경우 레코드 버퍼가 상당한 메모리를 사용하기도 한다.
    - 레코드 버퍼: 각 클라이언트 세션에서 테이블의 레코드를 읽고 쓸 때 버퍼로 사용하는 공간. 별도 설정 불가. 전체 커넥션 개수와 각 커넥션이 읽고 쓰는 테이블의 개수에 따라서 결정. 동적으로 해제되기도 하므로 정확히 필요한 메모리 공간의 크기를 계산할 수가 없다.
- MySQL 5.7 버전부터는 InnoDB 버퍼 풀의 크기를 동적으로 조절할 수 있게 개선되었다.
    - **버퍼 풀의 크기를 적절히 작은 값으로 설정해서 조금씩 상황을 봐가면서 증가시키는 방법이 최적**
- 권장 설정 방법!!
    - 운영체제의 전체 메모리 공간이 8GB 미만이라면 50% 정도만 InnoDB 버퍼 풀로 설정하고 나머지 메모리 공간은 MySQL 서버와 운영체제, 그리고 다른 프로그램이 사용할 수 있는 공간으로 확보해주는 것이 좋다.
    - 만약 그 이상이라면, InnoDB 버퍼 풀의 크기를 전체 메모리의 50%에서 시작해서 조금씩 올려가면서 최적점을 찾는다. => 50GB라면 15~30GB 정도를 운영체제와 다른 용용 프로그램을 위해서 남겨두고 나머지를 InnoDB 버퍼 풀로 할당하자.
- InnoDB 버퍼 풀은 `innodb_buffer_pool_size` 시스템 변수로 크기를 설정할 수 있으며, 동적으로 버퍼 풀의 크기를 확장할 수 있다.
    - 하지만 버퍼 풀은 크리티컬한 변경이다. 최대한 서버가 한가한 시점을 골라서 진행해야 한다.
- InnoDB 버퍼 풀은 내부적으로 128MB 청크 단위로 쪼개어 관리되는데, 이는 버퍼 풀의 크기를 줄이거나 늘리기 위한 단위 크기로 사용된다.
    - 그래서 버퍼 풀의 크기를 줄이거나 늘릴 때는 128MB 단위로 처리된다.
- InnoDB 버퍼 풀은 전통적으로 버퍼 풀 전체를 관리하는 잠금(세마포어)으로 인해 내부 잠금 경합을 많이 유발해왔는데, 이런 경합을 줄이기 위해 버퍼 풀을 여러 개로 쪼개어 관리할 수 있게 개선됐다.
    - 여러 개의 작은 버퍼 풀로 쪼개지면서 개별 버퍼 풀 전체를 관리하는 잠금(세마포어) 자체도 경합이 분산되는 효과를 내게 되는 것이다.
    - `innodb_buffer_pool_instances` 변수를 통해 여러 개로 분리해서 관리가 가능하다. 각 버퍼 풀을 버퍼 풀을 인스턴스라고 표현한다.
    - 기본적으로 8개로 초기화. 메모리 크기가 1GB 미만이면 버퍼풀 인스턴스는 1개만 생성.
    - 메모리 공간이 40GB 이하 수준이라면 기본값인 8을 유지하고, 메모리가 크다면 버퍼 풀 인스턴스당 5GB 정보가 되게 인스턴스 개수를 설정하는 것이 좋다.

#### 2-7-2. 버퍼 풀의 구조

- 버퍼 풀의 페이지 크기 조각을 관리하기 위해 InnoDB 스토리지 엔진은 크게 `LRU(Least Recently Used)` 리스트와 `플러시 Flush` 리스트, 그리고 `프리 Free` 리스트라는 3개의 자료 구조를 관리한다.
    - Free List는 InnoDB 버퍼 풀에서 실제 사용자 데이터로 채워지지 않은 비어 있는 페이지들의 목록이며, 사용자의 쿼리가 새롭게 디스크의 데이터 페이지를 읽어와야 하는 경우 사용된다.
- 아래는 버퍼 풀 관리를 위한 LRU 리스트 구조이다.

<img src="img/architecture08.jpg">

- LRU 리스트를 관리하는 목적은 디스크로부터 한 번 읽어온 페이지를 최대한 오랫동안 InnoDB머퍼풀의 메모리에 유지해서 디스크 읽기를 최소화하는 것이다.
- InnoDB 스토리지 엔진에서 데이터를 찾는 과정

1. 필요한 레코드가 저장된 데이터가 저장된 데이터 페이가 버퍼 풀에 있는지 검사
   1. InnoDB 어댑티브 해시 인덱스를 이용해 페이지를 검색
   2. 해당 테이블의 인덱스(B-Tree)를 이용해 버퍼 풀에서 페이지 검색
   3. 버퍼 풀에 이미 데이터 페이지가 있었다면 해당 페이지의 포인터를 MRU 방향으로 승급
2. 디스크에서 필요한 데이터 페이지를 버퍼 풀에 적재하고, 적재된 페이지에 대한 포인터를 LRU 헤더 부분에 추가
3. 버퍼 풀의 LRU 헤더 부분에 적재된 데이터 페이지가 실제로 읽히면 MRU 헤더 부분으로 이동(Read Ahead와 같이 대량 읽기의 경우 디스크의 데이터 페이지가 버퍼 풀로 적재는 되지만 실제 쿼리에서 사용되지는 않을 수도 있으며 이런 경우에는 MRU로 이동되지 않음)
4. 버퍼 풀에 상주하는 데이터 페이지는 사용자 쿼리가 얼마나 최근에 접근했었는지에 따라 나이(Age)가 부여되며, 버퍼 풀에 상주하는 동안 쿼리에서 오랫동안 사용되지 않으면 데이터 페이지에 부여된 나이가 오래되고(Aging) 결국 해당 페이지는 버퍼 풀에서 제거. 버퍼 풀의 데이터 페이지가 쿼리에 의해 사용되면 나이가 초기화되어 다시 젊어지고 MRU의 헤더 부분으로 옮겨진다.
5. 필요한 데이터가 자주 접근됐다면 해당 페이지의 인덱스 키를 어댑티브 해시 인덱스에 추가

- 일단 한 번 데이터 변경이 가해진 데이터 페이지는 플러시 리스트에 관리되고 특정 시점이 되면 디스크로 기록돼야 한다.
  - 데이터가 변경되면 InnoDB는 변경 내용을 리두 로그에 기록하고 버퍼 풀의 데이터 페이지에도 변경 내용을 반영한다.
  - 그래서 리두 로그의 각 엔트리는 특정 데이터 페이지와 연결된다.
  - 하지만 리두 로그가 디스크로 기록됐다고 해서 데이터 페이지가 디스크로 기록됐다는 것을 항상 보장하지는 않는다.
  - 때로는 그 반대의 경우도 발생할 수 있는데, InnoDB 스토리지 엔진은 체크포인트를 발생시켜 디스크의 리두 로그와 데이터 페이지의 상태를 동기화하게 된다.
  - 체크포인트는 MySQL 서버가 시작될 때 InnoDB 스토리지 엔진이 리두 로그의 어느 부분부터 복구를 실행해야 할지 판단하는 기준점을 만드는 역할을 한다.

#### 2-7-3. 버퍼 풀과 리두 로그

- InnoDB의 버퍼 풀과 리두 로그는 매우 밀접한 관계다.
  - InnoDB의 버퍼 풀은 서버의 메모리가 허용하는 만큼 크게 설정하면 할수록 쿼리의 성능이 빨라진다.
  - 버퍼 풀은 데이터베이스 서버의 성능 향상을 위해 데이터 캐시와 쓰기 버퍼링이라는 두 가지 용도가 있는데, 버퍼 풀의 메모리 공간만 단순히 늘리는 것은 데이터 캐시 기능만 향상시키는 것이다.
  - 쓰기 버퍼링까지 향상시키려면 InnoDB 버퍼 풀과 리두 로그와의 관계를 먼저 이해해야 한다.
- InnoDB 버퍼 풀은 디스크에서 읽은 상태로 전혀 변경되지 않은 클린 페이지(Clean Page)와 함께 `INSERT`, `UPDATE`, `DELETE` 명령으로 변경된 데이터를 가진 `더티 페이지 Dirty Page`도 가지고 있다.
  - 더티 페이지는 디스크와 메모리(버퍼 풀)의 상태가 다르기 때문에 언젠가는 디스크로 기록돼야 한다.
  - 하지만 더티 페이지는 버퍼 풀에 무한정 머무를 수 있는 것은 아니다.
- 리두 로그는 1개 이상의 고정 크기 파일을 연결해서 순환 고리처럼 사용한다. 
  - 데이터 변경이 계속 발행하면 리두 로그 파일에 기록됐던 로그 엔트리는 어느 순간 다시 새로운 로그 엔트리로 덮어 쓰인다.
  - 전체 리두 로그 파일에서 재사용 가능한 공간과 당장 재사용 불가능한 공간을 구분해서 관리해야 하는데, 재사용 불가능한 공간을 `활성 리두 로그 Active Redo Log`라고 한다.
- 리두 로그 파일의 공간은 계속 순환되어 재사용, 매번 기록될 때마다 로그 포지션은 계속 증가된 값을 갖게 된다.
  - 이를 `LSN(Log Sequence Number)`이라고 한다.
  - 주기적으로 체크포인트 이벤트를 발생시켜 리두 로그와 버퍼 풀의 더티 페이지를 디스크로 동기화하는데, 가장 최근 체크포인트 지점의 LSN이 활성 리두 로그 공간의 시작점이 된다.
  - 체크포인트 에이지는 활성 리두 로그 공간의 크기를 일컫는다.
- InnoDB 버퍼 풀의 더티 페이지는 특정 리두 로그 엔트리와 관계를 가지고, 체크포인트가 발생하면 체크포인트 LSN보다 작은 리두 로그 엔트리와 관련된 더티 페이지는 모두 디스크로 동기화돼야 한다.
  - 물론 당연히 체크포인트 LSN보다 작은 LSN 값을 가진 리두 로그 엔트리도 디스크로 동기화돼야 한다.

> #### 참고
> - 버퍼 풀의 크기가 100GB라고 리두 로그의 공간이 100GB가 돼야 한다는 것은 아니다.
> - 일반적으로 리두 로그는 변경분만 가지고 버퍼 풀은 데이터 페이지를 통째로 가지기 때문에 데이터 변경이 발생해도 리두 로그는 훨씬 작은 공간만 있으면 된다.

<br/>

## 참고자료

- Real MySQL 8.0
