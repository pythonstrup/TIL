# 인덱스

- 각 인덱스의 특성과 차이는 상당히 중요하며, 물리 수준의 모델링을 할 때도 중요한 요소가 될 것이다.

## 1. 디스크 읽기 방식

- "Random I/O"와 "Sequential I/O"의 개념 먼저.
- 데이터베이스 성능 튜닝은 어떻게 디스크 I/O를 줄이느냐가 관건일 때가 상당히 많다.

### 1-1. 하드 디스크 드라이브(HDD)와 솔리드 스테이트 드라이브(SSD)

- 컴퓨터에서 CPU나 메모리 같은 주요 장치는 대부분 전자식 장치지만 하드 디스크 드라이브는 기계식 장치다.
  - 그래서 데이터베이스 서버에서는 항상 디스크 장치가 병목이 된다.
  - 기계식 하드 디스크 드라이브를 대체하기 위해 전자식 저장 매체인 SDD가 떠오르고 있다.
- SDD는 데이터 저장용 플래터(원판)를 제거하고 그 대신 플래시 메모리를 장착하고 있다.
  - 원판 회전 없이 아주 빨리 데이터를 읽을 수 있다.
  - 플래시 메모리는 전원이 공급되지 않아도 데이터가 삭제되지 않는다.
  - 그리고 컴퓨터의 메모리(D-RAM)보다는 느리지만 기계식 하드 디스크 드라이브보다는 훨씬 빠르다.
- 메모리와 디스크의 처리 속도 => 10만 배 차이
- 메모리와 SDD 처리 속도 => 1000배 차이

### 1-2. 랜덤 I/O와 순차 I/O

- Random I/O라는 표현은 하드 디스크 드라이브의 플래터(원판)를 돌려서 읽어야 할 데이터가 저장된 위치로 디스크 헤더를 이동시킨 다음 데이터를 읽는 것을 의미하는데, 사실 순차 I/O 또한 이 작업 과정은 같다.
- 순차 I/O는 3개의 페이지(3 x 16KB)를 디스크에 기록하기 위해 1번 시스템 콜을 요청했지만, 랜덤 I/O는 3개의 페이지를 디스크에 기록하기 위해 3번 시스템 콜을 요청한다.
  - 즉 순차 I/O는 헤드를 1번만 움직이고, 랜덤 I/O는 헤드를 3번 움직여야 한다.
  - 결국 순차 I/O는 랜덤 I/O보다 3배 정도 빠르다고 볼 수 있다. (디스크의 성능은 디스크 헤더의 위치 이동 없이 얼마나 많은 데이터를 한 번에 기록하느냐에 의해 결정)
  - SDD도 마찬가지다.
- 사실 쿼리를 튜닝해서 랜덤 I/O를 순차 I/O로 바꿔서 실행할 방법은 그다지 많지 않다.
  - 일반적으로 쿼리를 튜닝하는 것은 랜덤 I/O 자체를 줄여주는 것이 목적이라고 할 수 있다.
  - 여기서 랜덤 I/O를 줄인다는 것은 쿼리를 처리하는 데 꼭 필요한 데이터만 읽도록 개선하는 것을 의미한다.

> #### 참고
> - 랜덤 I/O나 순차 I/O 모두 파일에 쓰기를 실행하면 반드시 동기화(fsync 또는 flush 작업)가 필요하다.
> - 그런데 순차 I/O인 경우에도 이러한 파일 동기화 작업이 빈번히 발생한다면 랜덤 I/O와 같이 비효율적인 형태로 처리될 때가 많다.
> - 기업용으로 사용하는 데이터베이스 서버에는 캐시 메모리가 장착된 RAID 컨트롤러가 일반적으로 사용되는데, RAID 컨트롤러의 캐시 메모리는 아주 빈번한 파일 동기화 작업이 호출되는 순차 I/O를 효율적으로 처리될 수 있게 변환하는 역할을 한다.
> - 하드 디스크 드라이브뿐만 아니라 SSD를 사용하는 경우에도 여전히 RAID 컨트롤러는 중요한 역할을 하기 때문에 RAID 컨트롤러와 RAID 컨트롤러에 장착된 캐시의 성능을 무시하지 말자.

> #### 참고
> - 인덱스 레인지 스캔은 데이터를 읽기 위해 주로 랜덤 I/O를 사용하며, 풀 테이블 스캔은 순차 I/O를 사용한다.
> - 그래서 큰 테이블의 레코드 대부분을 읽는 작업에서는 인덱스를 사용하지 않고 풀 테이블 스캔을 사용하도록 유도할 때도 있다.
> - 이는 순차 I/O가 랜덤 I/O보다 훨씬 빨리 많은 레코드를 읽어올 수 있기 때문인데, 이런 형태는 OLTP(OnLine Transaction Processing) 성격의 웹 서비스보다는 데이터 웨어하우스나 통계 작업에서 자주 사용된다.

<br/>

## 2. 인덱스란?

- DBMS에서 테이블의 모든 데이터를 검색해서 원하는 결과를 가져오려면 시간이 오래 걸린다.
  - 그래서 칼럼의 값과 해당 레코드가 저장된 주소를 키와 값의 쌍(key-value pair)로 삼아 인덱스를 만들어 두는 것이다.
  - 칼럼의 값을 주어진 순서대로 정렬해서 보관한다.
- SortedList가 DBMS의 인덱스와 같은 자료 구조이며, ArrayList는 데이터 파일과 같은 자료 구조를 사용한다.
  - SortedList는 항상 값이 정렬된 상태로 유지하는 자료 구조
  - ArrayList는 값을 저장하는 순서 그대로 유지하는 자료 구조
- SortedList는 데이터가 저장될 때마다 항상 값을 정렬해야 하므로 저장하는 과정이 복잡하고 느리지만,이미 정렬돼 있어서 아주 빨리 원하는 값을 찾아올 수 있다.
  - DBMS도 마찬가지로 INSERT나 UPDAET, DELETE 문장의 처리가 느려진다. 하지만 SELECT 문은 매우 빠르게 처리할 수 있다.
- 결론적으로 DBMS에서 인덱스는 데이터의 저장(INSERT, UPDATE, DELETE) 성능을 희생하고 그 대신 데이터의 읽기 속도를 높이는 기능이다.
  - 테이블의 인덱스를 하나 더 추가할지 말지는 데이터의 저장 속도를 어디까지 희생할 수 있는지, 읽기 속도를 얼마나 더 빠르게 만들어야 하느냐에 따라 결정해야 한다.
  - 인덱스의 크기가 비대해지면 저장 성능이 떨어지고 역효과를 불러올 수 있다.

#### 역할별 분류

- 인덱스를 역할별로 구분해 본다면 `프라이머리 키 Primary Key`와 `보조 키. 세컨더리 인덱스 Secondary Key`로 구분할 수 있다.
- 프라이머리 키는 이미 잘 아는 것처럼 그 레코드를 대표하는 칼럼의 값으로 만들어진 인덱스를 의마한다. 이 칼럼은 테이블에서 해당 레코드를 식별할 수 있는 기준값이 되기 때문에 우리는 이를 식별자라고도 부른다. 프라이머리 키는 NULL 값을 허용하지 않으며 중복을 허용하지 않는 것이 특징이다.
- 프라이머리 키를 제외한 나머지 모든 인덱스는 세컨더리 인덱스로 분류한다. 유니크 인덱스는 프라이머리 키와 성격이 비슷하고 프라이머리 키를 대체해서 사용할 수도 있다고 해서 대체 키라고도 하는데, 별도로 분류하기도 하고 그냥 세컨더리 인덱스로 분류하기도 한다.

#### 알고리즘별 분류
 
- 상당히 많은 분류가 가능하겠지만, 대표적으로 `B-Tree 인덱스`와 `Hash 인덱스`로 구분할 수 있다.
- B-Tree 알고리즘은 가장 일반적으로 사용되는 인덱스 알고리즘이다. (상당히 성숙)
  - B-Tree 인덱스는 칼럼의 값을 변형하지 않고 원래의 값을 이용해 인덱싱하는 알고리즘이다.
  - MySQL 서버에서는 위치 기반 검색을 지원하기 위한 R-Tree 인덱스 알고리즘도 있지만, 결국 R-Tree 인덱스는 B-Tree의 응용 알고리즘으로 볼 수 있다.
- Hash 인덱스 알고리즘은 칼럼의 값으로 해시값을 계산해서 인덱싱하는 알고리즘으로 매우 빠른 검색을 지원한다.
  - 하지만 값을 변형해서 인덱싱하므로 전방(Prefix) 일치와 같이 값의 일부만 검색하거나 범위를 검색할 때는 해시 인덱스를 사용할 수 없다.
  - Hash 인덱스는 주로 메모리 기반의 데이터베이스에서 많이 사용한다.

#### 중복 허용 여부

- `유니크 인덱스 Unique Index`와 `유니크하지 않은 인덱스 Non-Unique Index`로 구분할 수 있다.
- 실제 DBMS의 쿼리를 실행해야 하는 옵티마이저에게는 유니크함이 상당히 중요한 문제가 된다.
  - 동등 조건으로 검색한다는 건 항상 1건의 레코드만 찾으면 더 찾지 않아도 된다는 것을 옵티마이저에게 알려주는 효과를 낸다.

<br/>

## 3. B-Tree 인덱스

- Balanced Tree
- 여러 변형된 형태의 알고리즘이 있는데, 일반적으로 B+-Tree나 B*-Tree가 사용된다.
- B-Tree는 칼럼의 원래 값을 변형시키지 않고 인덱스 구조체 내에서는 항상 정렬된 상태로 유지한다.
  - 전문 검색과 같은 특수한 요건이 아닌 경우, 대부분 인덱스는 거의 B-Tree를 사용할 정도로 일반적인 용도에 적합한 알고리즘이다.

### 3-1. 구조 및 특성

- B-Tree는 트리 구조의 최상위에 하나의 `루트 노드 Root Node`가 존재하고 그 하위에 자식 노드가 붙어 있는 형태다.
  - 가장 하위에 있는 노드를 `리프 노드 Leaf Node`라 하고, 중간의 노드를 `브랜치 노드 Branch Node`라고 한다.
  - 데이터베이스에서 인덱스와 실제 데이터가 저장된 데이터는 따로 관리되는데, 인덱스의 리프 노드는 항상 실제 데이터 레코드를 찾아가기 위한 주솟값을 가지고 있다.

<img src="img/btree01.jpg">

- 인덱스의 키 값은 모두 정렬돼 있지만, 데이터 파일의 레코드는 정렬돼 있지 않고 임의의 순서로 저장돼 있다.

> #### 참고
> - 대부분 RDBMS의 데이터 파일에서 레코드는 특정 기준으로 정렬되지 않고 임의의 순서로 저장된다.
> - 하지만 InnoDB 테이블에서 레코드는 클러스터되어 디스크에 저장되므로 기본적으로 프라이머리 키 순서로 정렬되어 저장된다.
> - InnoDB에서는 사용자가 별도의 명령이나 옵션을 선택하지 않아도 디폴트로 클러스터링 테이블이 생성된다. 클러스터링이란 비슷한 값을 최대한 모아서 저장하는 방식을 의미한다.

<img src="img/btree02.jpg">

- 위 그림은 MyISAM 테이블의 인덱스와 데이터 파일의 관계다.
  - `레코드 주소`는 MyISAM 테이블의 생성 옵션에 따라 레코드가 테이블에 INSERT된 순번이거나 데이터 파일 내의 위치(Offset)다.
- 반면 InnoDB의 세컨더리 인덱스는 데이터 파일 또한 프라이머리 키를 인덱스 키로 한 루트 노드, 브랜치 노드, 리프 노드 형태로 구성되어 있기 때문에 2번의 검색 과정을 거쳐야 한다.
  - InnoDB 테이블의 성능이 떨어질 것처럼 보이지만 사실은 MyISAM 인덱스 구조와 InnoDB 인덱스 구조는 각각 장단점을 가지고 있다.

### 3-2. B-Tree 인덱스 키 추가 및 삭제

#### 3-2-1. 인덱스 키 추가

- 새로운 키 값이 B-Tree에 저장될 때 테이블의 스토리지 엔진에 따라 새로운 키 값이 즉시 인덱스에 저장될 수도 있고, 그렇지 않을 수도 있다.
  - B-Tree에 저장될 때는 저장될 키 값을 이용해 B-Tree 상의 적절한 위치를 검색해야 한다. 저장될 위치가 결정되면 레코드의 키 값과 대상 레코드의 주소 정보를 B-Tree의 리프 노드에 저장한다.
  - 리프 노드가 꽉 차서 더는 저장할 수 없을 때 리프 노드가 분리(Split)돼야 하는데, 이는 상위 브랜치 노드까지 처리의 범위가 넓어진다.
  - 이러한 작업 탓에 B-Tree는 상대적으로 쓰기 작업(새로운 키를 추가하는 작업)에 비용이 많이 드는 것으로 알려졌다.
- 대략적으로 인덱스를 추가하는 비용 계산하기
  - 테이블에 레코드를 추가하는 작업 비용이 1이라고 가정하면 해당 테이블의 인덱스에 키를 추가하는 작업 비용을 1.5 정도로 예측하는 것이다.
  - 일반적으로 테이블에 인덱스가 3개가 있다면? 1 + 1.5*3 = 5.5의 비용 정도로 예측한다.

#### 3-2-2. 인덱스 키 삭제

- 해당 키 값이 저장된 B-Tree의 리프 노드를 찾아서 그냥 삭제 마크만 하면 작업이 완료된다.
  - 이렇게 삭제 마킹된 인덱스 키 공간은 계속 그대로 방치하거나 재활용할 수 있다.
  - 인덱스 키 삭제로 인한 마킹 작업 또한 디스크 쓰기가 필요하므로 이 작업 역시 디스크 I/O가 필요한 작업이다.
- MySQL 5.5 이상 버전의 InnoDB 스토리지 엔진에서는 이 작업 또한 버퍼링되어 지연 처리될 수도 있다.
  - 처리가 지연된 인덱스 키 삭제 또한 사용자에게는 특별한 악영향 없이 MySQL 서버가 내부적으로 처리하므로 특별히 걱정할 것은 없다.
- MyISAM이나 MEMORY 스토리지 엔진의 테이블에서는 체인지 버퍼와 같은 기능이 없으므로 인덱스 키 삭제가 완료된 후 쿼리 실행이 완료된다.

#### 3-2-3. 인덱스 키 변경

- 인덱스의 키 값은 그 값에 따라 저장될 리프 노드의 위치가 결정되므로 B-Tree의 키 값이 변경되는 경우에는 단순히 인덱스 상의 키 값만 변경하는 것은 불가능하다.
  - 먼저 키 값을 삭제한 후, 다시 새로운 키 값을 추가하는 형태로 처리된다.

#### 3-2-4 인덱스 키 검색

- B-Tree의 루트 노드부터 시작해 브랜치 노드를 거쳐 최종 리프 노드까지 이동하면서 비교 작업을 수행하는데, 이 과정을 "트리 탐색"이라고 한다.
- B-Tree 인덱스를 이용한 검색은 100% 일치 또는 값의 앞부분(Left-most part)만 일치하는 경우에 사용할 수 있다. 또한 부등호 비교 조건에서도 인덱스를 활용할 수 있다.
- 반면 인덱스를 구성하는 키 값의 뒤부분만 검색하는 용도로는 인덱스를 사용할 수 없다.
  - 인덱스의 키 값에 변형이 가해진 후 비교되는 경우에는 절대 B-Tree 검색이 되지 않는다. (함수나 연산을 수행한 결과로 정렬을 하거나 검색)

### 3-3. B-Tree 인덱스 사용에 영향을 미치는 요소

- 칼럼의 크기, 레코드의 건수, 유니크한 인덱스 키 값의 개수 등에 의해 검색이나 변경 작업의 성능이 영향을 받는다.

#### 3-3-1. 인덱스 키 값의 크기

#### 3-3-2. B-Tree 깊이

#### 3-3-3. 선택도 (기수성, Cardinality)

<br/>

## 참고자료

- Real MySQL 8.0
