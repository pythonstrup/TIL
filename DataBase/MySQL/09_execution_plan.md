# 실행 계획

- `EXPLAIN` 명령으로 옵티마이저가 수립한 실행 계획 확인 가능
- MySQL 서버에서 보여주는 실행 계획을 읽고 이해하려면 MySQL 서버가 데이터를 처리하는 로직을 이해할 필요가 있다.
- 주요 정보!
  - 실행 계획에 가장 큰 영향을 미치는 통계 정보.
  - MySQL 서버가 보여주는 실행 계획을 읽는 순서와 실행 계획에 출력되는 키워드
  - 알고리즘

---

## 1. 통계 정보

- 5.7 버전까지는 테이블과 인덱스에 대한 개괄적인 정보를 가지고 실행 계획을 수립했다.
  - 하지만 테이블 칼럼의 값들이 실제 어떻게 분포돼 있는지에 대한 정보가 없기 때문에 실행 계획의 정확도가 떨어지는 경우가 많았다.
- 8.0 버전부터는 인덱스되지 않은 칼럼들에 대해서도 데이터 분포도를 수집해서 저장하는 `히스토그램 Histogram` 정보가 도입됐다.
  - 그렇다고 기존의 테이블이나 인덱스의 통계 정보가 필요치 않은 것은 아니다.

### 1-1. 테이블 및 인덱스 통계 정보

- 비용 기반 최적화에서 가장 중요한 것은 통계 정보
  - 통계 정보가 정확하지 않다면 전혀 엉뚱한 방향으로 쿼리를 실행할 수 있다.
- ex) 1억 건의 레코드가 저장된 테이블의 통계 정보가 갱신되지 않아 레코드가 10건 미만인 것처럼 돼 있다면? 
  - 옵티마이저는 실제 쿼리를 실행할 때 인덱스 레인지 스캔이 아니라 테이블을 처음부터 끝까지 읽는 방식(풀 테이블 스캔)으로 실행해 버릴 수도 있다.
  - 부정확한 통계로 0.1초에 끝날 쿼리가 1시간이 소요

#### 1-1-1. MySQL 서버의 통계 정보

- 5.5 버전까지는 메모리에서만 관리. `SHOW INDEX` 명령으로만 테이블 인덱스 칼럼의 분포도를 볼 수 있었다.
- 5.6 버전부터 InnoDB 스토리지 엔진을 사용하는 테이블에 대한 통계 정보를 영구적으로 관리할 수 있게 개선
  - 각 테이블의 통계 정보를 `mysql` 데이터베이스의 `innodb_index_stats` 테이블과 `innodb_table_stats` 테이블로 관리할 수 있게 개선됐다.
  - 재시작되어도 기존의 통계 정보 유지 가능
- 또한 테이블을 생성할 때 `STATS_PERSISTENT` 옵션을 설정할 수 있음
  - 테이블 단위로 영구적인 통계 정보를 보관할지 말지를 결정할 수 있다.

```shell
mysql> CREATE TABLE test_table(fd1 INT, fd2 VARCHAR(20), PRIMARY KEY(fd1))
       ENGINE=InnoDB
       STATS_PERSISTENT={ DEFAULT | 0 | 1 }
```

- `STATS_PERSISTENT`
  - `0`: 테이블의 통계 정보를 5.5 버전 이전의 방식대로 관리. (메모리에서만 관리)
  - `1`: 테이블의 통계 정보를 테이블에 저장. 
  - `DEFAULT`: 테이블을 생성할 때 별도로 `STATS_PERSISTENT` 옵션을 설정하지 않은 것과 동일하며, 테이블의 통계를 영구적으로 관리할지 말지를 `innodb_stats_persistent` 시스템 변수의 값으로 결정한다.
- `innodb_stats_persistent` 시스템 변수는 기본적으로 `ON(1)`로 설정.

---

- 5.5버전 이전에는 재시작되면 통계 정보가 다시 수집되어야 했다. 
- 또한 사용자나 관리자가 알지 못하는 순산에 아래와 같은 이벤트가 발생하면 자동으로 통계 정보가 갱신됐다.

1. 테이블이 새로 오픈
2. 테이블의 레코드가 대량으로 변경되는 경우(테이블의 전체 레코드 중에서 1/16 정도의 UPDATE 또는 INSERT, DELETE)
3. `ANALYZE TABLE` 명령이 실행되는 경우
4. `SHOW TABLE STATUS` 명령이나 `SHOW INDEX FROM` 명령이 실행되는 경우
5. InnoDB 모니터가 활성화되는 경우
6. `innodb_stats_on_metadata` 시스템 설정이 `ON`인 상태에서 `SHOW TABLE STATUS` 명령이 실행되는 경우

- 자주 테이블의 통계 정보가 갱신되면 응용 프로그램의 쿼리를 인덱스 레인지 스캔으로 처리하던 MySQL 서버가 어느 날 갑자기 풀 테이블 스캔으로 실행되는 상황이 발생할 수도 있다.
  - 하지만 영구적인 통계가 생기며 의도하지 않은 통계 정보 변경을 막을 수 있게 됐다.
  - 또한 `innodb_stats_auto_recalc` 시스템 설정 변수의 값을 `OFF`로 설정해서 통계 정보가 자동으로 갱신되는 것을 막을 수 있다. (기본값 `ON`)
- 통계 정보를 자동으로 수집할지 여부도 테이블을 생성할 때 `STATS_AUTO_RECALC` 옵션을 이용해 테이블 단위로 조정
  - `1`: 5.5 이전 방식
  - `0`: `ANALYZE TABLE` 명령어를 실행할 때만 수집
  - `DEFAULT`: 테이블을 생성할 때 별도로 `STATS_AUTO_RECALC` 옵션을 설정하지 않은 것과 동일하다. 테이블의 통계 정보 수집을 `innodb_stats_auto_recalc` 시스템 설정 변수의 값으로 결정

---

- 5.5 버전에서 통계 정보 수집 시 몇 개의 InnoDB 테이블 블록을 샘플링할지 결정하는 옵션으로 `innodb_stats_sample_pages` 시스템 설정 변수가 제공
- 5.6 버전부터는 이 옵션이 없어졌다. (Deprecated)
  - 대신 이 시스템 변수가 `innodb_stats_transient_sample_pages`와 `innodb_stats_persistent_sample_pages` 시스템 변수 2개로 분리
- `innodb_stats_transient_sample_pages`
  - 기본값은 8. 자동으로 통계 정보 수집이 실행될 때 8개 페이지만 임의로 샘플링해서 분석하고 그 결과를 통계 정보로 활용함을 의미
  - 값이 너무 높으면 수집 시간이 길어지므로 주의.
- `innodb_stats_persistent_sample_pages`
  - 기본값은 20. `ANALYZE TABLE` 명령이 실행되면 임의로 20개 페이지만 샘플링해서 분석하고 그 결과를 영구적인 통계 정보 테이블에 저장하고 활용함을 의미한다.

---

### 1-2. 히스토그램

- 5.7 버전까지는 단순히 인덱스된 칼럼의 유니크한 값의 개수 정도만 가지고 있었는데, 이는 옵티마이저가 최적의 실행 계획을 수립하기에는 많이 부족.
  - 옵티마이저는 이러한 부족함을 메우기 위해 실행 계획을 수립할 때 실제 인덱스의 일부 페이지를 랜덤으로 가져와 참조하는 방식을 사용
- 8.0 버전으로 업그레이드되면서 MySQL 서버도 드디어 칼럼의 데이터 분포도를 참조할 수 있는 히스토그램 정보를 활용할 수 있게 됐다.

#### 1-2-1. 히스토그램 정보 수집 및 삭제

- 8.0 버전에서 히스토그램 정보는 칼럼 단위로 관리.
  - 이는 자동으로 수집되지 않고, `ANALYZE TABLE ... UPDATE HISTOGRAM` 명령을 실행해 수동으로 수집 및 관리된다.
  - 수집된 히스토그램 정보는 시스템 딕셔너리에 함께 저장되고, MySQL 서버가 시작될 때 딕셔너리의 히스토그램 정보를 `information_schema` 데이터베이스의 `column_statistics` 테이블로 로드한다.
  - 실제 히스토그램 정보를 조회하려면 `column_statistics` 테이블을 `SELECT`해서 참조할 수 있다.
- 또한 두 종류의 히스토그램 타입이 지원된다.

1. Singleton Histogram: 칼럼값 개별로 레코드 건수를 관리하는 히스토그램, Value-Based 히스토그램 또는 도수 분포라고 부른다.
2. Equi-Height(높이 균현) Histogram: 칼럼값의 범위를 균등한 개수로 구분해서 관리하는 히스토그램으로 `Height-Balanced` 히스토그램이라고도 불린다.

- 히스토그램은 `버킷 Bucket` 단위로 구분되어 레코드 건수나 칼럼값의 범위가 관리된다. 
  - 싱글톤 히스토그램은 칼럼이 가지는 값별로 버킷이 할당되며 높이 균형 히스토그램에서는 개수가 균등한 칼럼값의 범위별로 하나의 버킷이 할당된다.
  - 싱글톤 히스토그램은 각 버킷이 칼럼의 값과 발생 빈도의 비율의 2개 값을 가진다. 반면 높이 균형 히스토그램은 각 버킷이 범위 시작 값과 마지막 값, 그리고 발생 빈도율과 각 버킷에 포함된 유니크한 값의 개수 등 4개의 값을 가진다.

#### 1-2-2. 히스토그램의 용도

- 히스토그램은 특정 칼럼이 가지는 모든 값에 대한 분포도 정보를 가지지는 않지만 각 범위(버킷)별로 레코드의 건수와 유니크한 값의 개수 정보를 가지기 때문에 훨씬 정확한 예측을 할 수 있다.
  - 히스토그램 정보가 없으면 옵티마이저는 데이터가 균등하게 분포돼 있을 것으로 예측한다.
  - 하지만 히스토그램이 있으면 특정 범위의 데이터가 많고 적음을 식별할 수 있다.
- 또한 옵티마이저 힌트가 없을 때, 옵티마이저는 테이블의 전체 레코드 건수나 단순한 정보만으로 조인의 드라이빙 테이블을 결정하게 된다.
  - 이러한 차이로 인해 쿼리의 성능은 10배 정도 차이를 보일 수 있으며, InnoDB 버퍼 풀에 데이터가 존재하지 않아서 디스크에서 데이터를 읽어야 하는 경우라면 몇 배의 차이가 발생할 수도 있다.
  - 각 칼럼에 대해 히스토그램 정보가 있으면 어떤 테이블을 먼저 읽어야 조인의 횟수를 줄일 수 있을지 옵티마이저가 더 정확히 판단할 수 있다.

#### 1-2-3. 히스토그램과 인덱스

- 인덱스는 부족한 통계 정보를 수집하기 위해 사용된다는 점에서 히스토그램과 어느 정도 공통점을 가지고 있다.
- MySQL 서버에서는 쿼리의 실행 계획을 수립할 때 사용 가능한 인덱스들로부터 조건절이 일치하는 레코드 건수를 대략 파악하고 최종적으로 가장 나은 실행 계획을 선택한다.
  - 이때 조건절에 일치하는 레코드 건수를 예측하기 위해 옵티마이저는 실제 인덱스의 B-Tree를 샘플링해서 살펴본다. 이 작업을 메뉴얼에서는 `인덱스 다이브 Index Dive`라고 표현한다.
- 쿼리의 검색 조건으로 많이 사용되는 칼럼에 대해서는 일반적으로 인덱스를 생성한다.
  - 그런데 이렇게 인덱스된 칼럼에 대해 히스토그램 정보를 수집해 두는 것이 좋을지 고민스러울 수 있다.
- 8.0 버전 이상. MySQL 서버에서는 인덱스된 칼럼을 검색 조건으로 사용하는 경우 그 칼럼의 히스토그램은 사용하지 않고 실제 인덱스 다이브를 통해 직접 수집한 정보를 활용.
  - 이는 실제 검색 조건의 대상 값에 대한 샘플링을 실행하는 것이므로 항상 히스토그램보다 정확한 결과를 기대할 수 있기 때문이다.
  - 그래서 MySQL 8.0 버전에서 히스토그램은 주로 인덱스되지 않은 칼럼에 대한 데이터 분포도를 참조하는 용도로 사용된다.
- 하지만 인덱스 다이브 작업은 어느 정도의 비용이 필요하며, 때로는 (`IN` 절에 값이 많이 명시된 경우) 실행 계획 수립만으로도 상당한 인덱스 다이브를 실행하고 비용도 그만큼 커진다.


<br/>

## 참고자료

- Real MySQL 8.0
