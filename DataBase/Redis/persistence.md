# 레디스 영속성 Redis Persistence

1. RDB (Redis Database)

- 특정한 시간 간격마다 데이터셋의 스냅샷을 생성하여 저장하는 방식
- 설정된 주기에 따라 현재 상태를 파일로 저장하므로 백업 및 복구에 유용

2. AOF (Append Only File)

- AOF는 서버가 받은 모든 쓰기 연산을 로그로 기록하는 방식이다.
- 서버가 다시 시작될 때 이 로그를 이용해 원본 데이터셋을 복원할 수 있다.
- Redis 프로토콜과 동일한 형식으로 명령어가 기록.

3. No Persistence

- 단순한 캐싱 용도로만 사용할 때 영속성을 비활성화하여 성능을 극대화한다.

4. RDB + AOF (혼합 모드)

- RDB는 빠른 백업을 제공. AOF는 더 높은 무결성을 보장하므로, 두 방식을 조합하면 장점이 극대화

----

## RDB

### 장점

#### 1. RDB는 매우 compact한 단일 파일로 특정 시점의 Redis 데이터를 저장할 수 있다.

- 백업에 매우 적합하며, 예를 들어 최근 24시간 동안 매시간 RDB 파일을 저장하거나, 30일 동안 매일 RDB 스냅샷을 저장할 수 있다.
- 이를 통해 데이터 손실이나 장애 발생 시 여러 버전의 데이터 복구가 용이하다.

#### 2. RDB는 장애 복구(Disaster Recovery)에 매우 적합하다.

- RDB는 하나의 단일 파일이므로 AWS S3 같은 원격 스토리지에 쉽게 전송할 수 있으며, 필요하면 암호화하여 저장할 수도 있다.

#### 3. RDB는 Redis 성능을 최적화할 수 있다.

- Redis의 부모 프로세스는 RDB를 저장하기 위해 별도의 자식 프로세스를 fork() 하고, 이후 모든 작업은 이 자식 프로세스가 수행하므로 부모 프로세스는 디스크 I/O
  작업을 하지 않아 성능 저하가 적다.

#### 4. 대용량 데이터셋을 가진 Redis를 재시작할 때 RDB가 더 빠름.

- AOF(Append-Only File) 방식보다 RDB를 사용하면 대량의 데이터를 더 빠르게 복구할 수 있다.

#### 5. Redis 복제(replication) 환경에서 RDB는 재시작 후 부분적인 동기화(partial resynchronization)를 지원한다.

- 즉, 마스터-슬레이브 구조에서 장애 복구 및 페일오버 시 성능적으로 유리하다.

### 단점

#### 1. 데이터 손실 가능성이 있음
    - RDB는 설정된 주기마다 스냅샷을 저장하는 방식이므로, Redis가 갑자기 종료되면 마지막 저장 이후의 데이터가 손실될 가능성이 있다.
    - 예를 들어, 5분마다 RDB 스냅샷을 저장하도록 설정한 경우, Redis가 갑자기 중단되면 최대 5분간의 데이터가 손실될 수 있음.

#### 2. fork() 호출로 인해 성능 저하 발생 가능
    - RDB를 저장할 때 자식 프로세스를 fork()하는 과정이 필요한데, 데이터셋이 클 경우 fork() 과정에서 몇 밀리초에서 1초 이상의 딜레이가 발생할 수 있음.
    - 특히 CPU 성능이 낮은 환경에서는 Redis가 클라이언트 요청을 처리하지 못하는 경우가 발생할 수도 있음.

#### 3. AOF보다 유연성이 부족함
    - AOF(Append-Only File) 방식도 fork()가 필요하지만, AOF는 rewrite(로그 압축) 주기를 조정하여 데이터 지속성(durability)과 성능
      사이에서 유연하게 조절 가능하다.
    - 반면, RDB는 스냅샷 주기를 조정하는 것 외에는 세밀한 튜닝이 어려움.

----

## AOF

### 장점

### 1. AOF를 사용하면 Redis의 데이터 내구성이 훨씬 향상됨

- AOF는 다양한 `fsync` 정책을 지원하며, 선택에 따라 성능과 내구성 간의 균형을 조절할 수 있음.
- 지원하는 `fsync` 옵션:
  - fsync 없음 (최고 성능, 하지만 데이터 유실 가능)
  - 1초마다 fsync (기본값, 성능과 안정성 균형 유지)
  - 모든 명령어 실행 후 fsync (가장 높은 내구성, 성능 저하)
- 기본 설정(1초마다 fsync)에서는 쓰기 성능이 여전히 우수하며, `fsync`는 백그라운드에서 실행되므로 메인 스레드가 I/O 작업으로 막히지 않음.
- 이 경우 최악의 상황에서도 최대 1초 분량의 데이터만 손실될 가능성이 있음. 

#### 2. AOF는 `append-only` 방식으로 기록되므로 데이터 손상이 거의 없음

- AOF는 기존 파일을 수정하는 것이 아니라 단순히 내용을 추가하는 방식이므로, 디스크 탐색(seek) 작업이 없고, 전원 장애 시에도 손상 가능성이 적음.
- 만약 로그가 중간에 깨졌더라도, `redis-check-aof` 도구를 사용하면 쉽게 복구 가능.

#### 3. AOF는 파일 크기가 너무 커지면 백그라운드에서 자동으로 `rewrite` 실행 가능

- 기존 AOF 파일을 유지하면서 새로운 파일을 생성하므로 데이터 손실 위험이 없음.
- Redis는 최소한의 연산만 포함된 새로운 AOF 파일을 생성한 후, 기존 파일을 새로운 파일로 교체하여 쓰기 성능을 유지함.

#### 4. AOF 파일은 직관적인 로그 형식이므로 사람이 쉽게 읽고 수정할 수 있음

- AOF 파일에는 모든 명령어가 순서대로 저장되므로, 로그를 쉽게 이해하고 분석할 수 있음.
- 예를 들어, 실수로 `FLUSHALL`(전체 삭제) 명령어를 실행했더라도, AOF가 다시 쓰여지기 전에 서버를 중단하고 마지막 명령어를 삭제하면 데이터를 복구할 수 있음.

### 단점

#### 1. AOF 파일 크기가 RDB 파일보다 더 큼

- 동일한 데이터셋을 저장할 때 AOF는 모든 명령어를 저장하므로 RDB보다 파일 크기가 커질 가능성이 높음.

#### 2. AOF는 fsync 정책에 따라 RDB보다 성능이 낮을 수 있음

- `fsync`를 매 1초마다 실행하면 성능 저하가 적지만, 모든 명령어 실행 후 fsync를 수행하도록 설정하면 성능이 크게 떨어질 수 있음.
- `fsync`를 비활성화하면 RDB와 비슷한 성능을 낼 수 있지만, 데이터 유실 위험이 커짐.
- 반면, RDB는 대량의 쓰기 부하가 있을 때도 일정한 응답 속도를 보장할 수 있음.

#### Redis < 7.0

#### 3. AOF가 메모리를 많이 사용할 수 있음

- AOF `rewrite` 중에 새로운 쓰기 작업이 발생하면, 이 데이터가 메모리에 버퍼링되었다가 새로운 AOF 파일이 완성된 후에 한꺼번에 기록됨.
- 즉, `rewrite` 중에는 같은 명령이 디스크에 두 번 기록될 수 있음.

#### 4. AOF rewrite 시 Redis가 일시적으로 멈출 수 있음

- AOF `rewrite`이 끝날 때, 새로운 AOF 파일을 디스크에 쓰는 과정에서 Redis가 일시적으로 멈추는 현상이 발생할 수 있음.
- 특히, 쓰기 작업이 많을 경우 이러한 현상이 두드러질 수 있음.

----

## 그럼 어떤 방식을 사용해야 할까?

- PostgreSQL 수준의 데이터 안전성이 필요하다면, RDB와 AOF를 같이 사용하는 것이 좋다.
- 데이터가 중요하지만, 몇 분 정도의 데이터 손실은 감수할 수 있다면 RDB만 사용해도 충분하다.
- AOF만 단독 사용은 권장하지 않는다.
  - 주기적인 RDB 스냅샷을 유지하는 것이 백업, 빠른 재시작, AOF 엔진 버그 발생 시 복구 측면에서 유리하기 때문이다.

---

## Snapshotting

- Redis는 기본적으로 데이터셋의 스냅샷(snapshot)을 디스크에 저장하며, 이 파일은 `dump.rdb`라는 바이너리 파일로 생성된다.
- Redis는 다음과 같은 방식으로 자동으로 데이터셋을 저장하도록 설정할 수 있다.
1. N초마다 M개의 변경이 발생했을 경우, 자동으로 저장
2. 또는 수동으로 SAVE 또는 BGSAVE 명령어를 실행하여 저장 가능
  
- 예를 들어, 아래 설정을 적용하면 60초마다 최소 1,000개의 키가 변경되었을 경우, 데이터셋을 자동으로 디스크에 덤프한다.

```redis
> save 60 1000
```

- 이러한 방식은 `snapshotting` 이라고 불린다.

### 스냅샷 저장 방식

- Redis가 데이터셋을 디스크에 덤프할 때, 다음과 같은 과정이 수행된다.

1. Redis가 `fork()`를 실행하여 자식 프로세스를 생성. 이제 부모 프로세스와 자식 프로세스가 동시에 실행됨.
2. 자식 프로세스가 새로운 RDB 파일을 임시로 생성하여 데이터셋을 저장. 이 과정에서 부모 프로세스는 정상적으로 클라이언트 요청을 계속 처리할 수 있음
3. 자식 프로세스가 새로운 RDB 파일 저장을 완료하면, 기존 파일을 새로운 파일로 교체

---

## Append-Only File

- 스냅샷(Snapshotting) 방식은 데이터 내구성이 높지 않다.
- 즉, Redis가 실행 중인 컴퓨터가 멈추거나, 전원이 꺼지거나, 혹은 실수로 kill -9 명령어로 프로세스를 강제 종료하면 Redis에 마지막으로 기록된 데이터가 손실될 수 있다.
- 어떤 애플리케이션에서는 이러한 데이터 손실이 큰 문제가 되지 않을 수 있지만, 완전한 내구성(full durability)이 필요한 경우에는 스냅샷만으로는 충분하지 않다.

#### AOF(Append-Only File) 개념

- Append-Only File(AOF)은 스냅샷보다 내구성이 뛰어난 대체 전략이다.
- 이 기능은 Redis 1.1 버전부터 도입되었다.
- AOF를 활성화하려면 Redis 설정 파일에서 다음과 같이 설정하면 된다.

```redis
> appendonly yes
```

- 이제 Redis는 데이터셋을 변경하는 모든 명령어(예: SET)를 AOF 파일에 순차적으로 기록(append)하게 된다.
- Redis를 재시작하면, AOF를 다시 실행(re-play)하여 이전 상태를 복구할 수 있다.

#### Redis 7.0 이후 AOF 구조 변경

- Redis 7.0.0부터는 AOF가 "멀티 파트(Multi-Part) AOF" 메커니즘을 사용한다.
- 즉, 기존의 단일 AOF 파일이 "기본 파일(Base File)"과 "증분 파일(Incremental Files)"로 분리된다.

1. `기본 파일 Base File`
- AOF가 `rewrite`될 때 생성되는 초기 스냅샷을 포함한다.
- RDB 또는 AOF 형식 중 하나로 저장된다.
2. `증분 파일 Incremental Files`
- 기본 파일이 생성된 이후의 변경 사항들을 기록한다.
- 여러 개의 증분 파일이 존재할 수 있다.
- 이 모든 파일은 별도의 디렉토리에 저장되며, Manifest 파일이 이를 추적한다.

### Log rewriting

- AOF(Append-Only File)는 쓰기 작업이 수행될 때마다 파일 크기가 점점 커지는 문제가 있다.
- 예를 들어, 카운터를 100번 증가시키면 데이터셋에는 최종값이 저장되지만, AOF에는 100개의 연산 기록이 남는다.
- 이 중 99개는 불필요한 기록이며, 현재 상태를 복구하는 데 필요하지 않다.

####  AOF 리라이트(Rewrite) 과정

- Redis의 AOF 리라이트 기능은 백그라운드에서 안전하게 실행되며, 기존 서비스를 중단하지 않는다.

1. Redis는 기존 AOF 파일에 계속해서 데이터를 추가(append)하면서 새로운 AOF 파일을 생성한다.
2. 새로운 AOF 파일에는 현재 데이터셋을 복구하는 데 필요한 최소한의 연산만 포함된다.
3. 새로운 파일이 완성되면, 기존 AOF 파일을 새로운 AOF 파일로 교체한다.
4. 이제 Redis는 새로운 AOF 파일에 로그를 추가(append)한다.

- 즉, AOF 리라이트를 수행하면 불필요한 명령어가 제거되어 파일 크기가 최적화된다.

#### AOF 리라이트 자동 실행 및 명령어
- Redis 2.2 이전 버전: 사용자가 직접 BGREWRITEAOF 명령어를 실행해야 함.
- Redis 2.4 이후 버전: AOF 리라이트가 자동으로 실행됨 (설정 파일을 통해 조정 가능).
- Redis 7.0 이후 버전:
  - AOF 리라이트가 예약되면, Redis 부모 프로세스가 새로운 증분 AOF(incremental AOF) 파일을 열어 쓰기 작업을 계속 수행.
  - 자식 프로세스가 리라이트 작업을 실행하여 새로운 기본 AOF(base AOF) 파일을 생성.
  - Redis는 임시 매니페스트 파일을 생성하여 새로운 AOF 파일을 추적.
  - AOF 리라이트 실패가 반복되면, 재시도 주기가 점점 길어지는 제한 메커니즘이 적용되어 불필요한 리소스 낭비를 방지함.

### AOF의 내구성(Durability) 설정 (appendfsync 옵션)

- Redis는 AOF 데이터를 디스크에 fsync하는 빈도를 조정할 수 있음.
- 사용자는 데이터 안정성(내구성)과 성능 간의 균형을 설정할 수 있다.

|옵션|설명|성능|내구성|
|:--|:--|:--|:--|
|`appendfsync always`|명령이 추가될 때마다 fsync 수행 (매우 안전하지만 느림)|매우 느림|매우 안전|
|`appendfsync everysec`(기본값)|1초마다 fsync 실행 (성능과 안전성 균형)|빠름|1초 내 데이터 손실 가능|
|`appendfsync no`|fsync를 수행하지 않음, OS가 알아서 디스크에 저장|매우 빠름|데이터 손실 위험|

- 기본 설정(appendfsync everysec)이 가장 권장되는 방법이며, 성능과 데이터 안정성을 모두 고려한 최적의 선택이다.



---

# 참고자료

- [Redis persistence - 공식 문서](https://redis.io/docs/latest/operate/oss_and_stack/management/persistence/)

