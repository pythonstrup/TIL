# 3장 기본 개념

## 자료구조

### string

- 최대 512MB 문자열 저장 가능
- 모든 종류의 문자열은 binary-safe하게 처리

#### string 사용하기

- 숫자 형태의 데이터를 저장하는 것도 가능하다. `INCR`, `DECR`, `INCRBY`, `DECRBY`와 같은 커맨드로 숫자로 저장된 string을 제어할 수도 있다.

```shell
> SET counter 100

> INCR counter
(integer) 101

> INCR counter
(integer) 102

> INCRBY counter 50
(integer) 152
```

- `MSET`과 `MGET`과 같은 커맨드로 한 번에 여러 키를 조작하는 것도 가능하다.

```shell
> MSET a 10 b 20 c 30
OK

> MGET a b c
1) "10"
2) "20"
3) "30"
```

### list

- 순서를 가지는 문자열 목록
- 최대 42억여 개의 아이템을 저장할 수 있다.
  - 일반적으로 서비스에서 스택과 큐로서 사용.

#### list 사용하기

- `LPUSH`: 왼쪽(head)에 데이터 추가
- `RPUSH`: 오른쪽(tail)에 데이터 추가
- `LRANGE`: list에 들어 있는 데이터를 조회
- `LPOP`: list에 저장된 첫 번째 아이템을 반환하는 동시에 list에서 삭제. 숫자와 함께 사용하면 지정한 숫자만큼의 아이템을 반복해서 반환.
- `LTRIM`: 시작과 끝 아이템의 인덱스를 인자로 전달받아 지정한 범위에 속하지 않은 아이템은 모두 삭제. 하지만 값을 반환하지는 않는다.
- `LINDEX` 커맨드를 사용하면 원하는 인덱스의 데이터를 확인할 수 있다.
- `LINSERT`: 원하는 데이터의 앞이나 뒤에 데이터를 추가할 수 있다. 데이터의 앞에 추가하려면 `BEFORE`, 뒤에 추가하려면 `AFTER`

```shell
> LRANGE mylist 0 -1
1) "A"
2) "B"
3) "C"
4) "D"

> LINSERT mylist BEFORE B E
(integer) 5 # 추가 후의 list 길이

> LRANGE mylist 0 -1
1) "A"
2) "E"
3) "B"
4) "C"
5) "D"
```

### hash

- 컬럼이 고정된 관계형 데이터베이스의 테이블과는 달리, hash에서 필드를 추가하는 것은 간단한다.
- hash에서는 각 아이템마다 다른 필드를 가질 수 있으며, 동적으로 다양한 필드를 추가할 수 있다는 특징이 있다.

#### hash 사용하기

- `HSET <key> <field> <value>`: hash에 아이템을 저장
- `HGET <key> <field>`: 값 가져오기
- `HGETALL <key>`: 모든 필드-값 쌍을 차례로 반환

### set

- 정렬되지 않은 문자열의 모음. 중복해서 값을 저장하지 않음.

#### set 사용하기

- `SADD <setName> <value>`: set에 아이템 저장
- `SMEMBERS <setName>`: set에 저장된 전체 아이템 출력
- `SREM <setName> <value>`: 원하는 데이터 삭제
- `SPOP <setName>`: 랜덤으로 하나의 아이템을 반환하고, 그 아이템을 삭제
- `SUNION`: : 합집합
- `SINTER`: 교집합
- `SDIFF`: 차집합

### sorted set

- `score` 값에 따라 정렬되는 고유한 문자열의 집합.
  - 모든 아이템은 스코어-값 쌍.
  - 저장될 때부터 스코어 값으로 정렬돼 저장. 순서가 있다는 뜻이다.
  - 데이터 중복 없이 저장.

> #### list vs sorted set
> - list는 인덱스로 접근할 때 O(n)
> - sorted set은 인덱스로 접근할 때 O(logn)으로 더 효율적이다.


#### sorted set 사용하기

- `ZADD <key> <score> <value>`: 아이템 저장.
- `ZADD`의 옵션들
  - `XX`: 아이템이 이미 존재할 때만 스코어 업데이트
  - `NX`: 아이템이 존재하지 않을 때에만 신규 삽입. 업데이트 X
  - `LT`: 업데이트하고자 하는 스코어가 기존보다 작을 때에만 업데이트. 없으면 삽입
  - `GT`: 업데이트하고자 하는 스코어가 기존보다 클 때에만 업데이트. 없으면 삽입
- `ZRANGE <key> <start> <stop> [BYSCORE | BYLEX] [REV] [LIMIT offset count] [WITHSCORES]`
  - `<start>`, `<stop>`은 범위로 필수 입력

#### 인덱스로 데이터 조회

- `ZRANGE`에서 `<start>`, `<stop>`을 인덱스 삼아 조회
- `WITHSCORE` 옵션을 사용하면 데이터와 함께 스코어 값이 차례대로 출력
- `REV` 옵션을 사용하면 데이터는 역순으로 출력

#### 스코어로 데이터 조회

- `ZRANGE`의 `BYSCORE` 옵션 사용
  - `<start>`, `<stop>`를 최소, 최대 스코어를 입력해야 함.
  - `-inf`: 최솟값. 정순 `<start>`에 사용. 역순(`REV`) `<stop>`에 사용
  - `+inf`: 최댓값. `<stop>`에 사용. 역순(`REV`) `<start>`에 사용

#### 사전 순으로 데이터 조회

- 스코어가 같으면 데이터는 사전 순으로 정렬된다.
  - `BYLEX` 옵션을 사용해 사전식 순서를 이요해 특정 아이템을 조회할 수 있다.

```shell
> ZRANGE mySortedSet (b (f BYLEX
```

- `<start>`, `<stop>`는 사전 순으로 비교하기 위한 문자열을 전달해야 한다.
  - 또한, 반드시 `(`(입력한 문자열 포함)나 `[`(입력한 문자열 비포함) 문자를 함께 입력해야 한다.
  - 가장 처음은 `-`, 가장 마지막은 `+`로 대체 가능

### Bitmap

- 독자적인 자료 구조는 아니며, `string` 자료 구조에 bit 연산을 수행할 수 있도록 확장한 형태다.
  - 참고로 `string`은 `binary safe`하다.
- string => 512MB => 2^32 의 비트를 가지고 있는 비트맵 형태로 볼 수 있다.

#### Bitmap 사용하기

- `SETBIT <bitmapName> <bitIndex> <0 또는 1>`: 비트 저장하기
- `GETBIT <bitmapName> <bitIndex>`: 조회하기
- `BITFIELD <bitmapName> SET <type> <bitIndex> <0 또는 1>`


### Hyperloglog

- 집합의 원소 개수인 카디널리티를 추정할 수 있는 자료 구조
  - 대량의 데이터에서 중복되지 않는 고유한 값을 집계할 때 유용하게 사용할 수 있음.

### Geospatial

- 경도, 위도 데이터 쌍 집합. 지리 데이터를 저장할 수 있는 방법.

### stream

- 레디스를 메시지 브로커로서 사용할 수 있게 하는 자료 구조.
- 전체적인 구조는 카프카에서 영향을 받아 만들어졌으며, 소비자 그룹 개념을 도입해 데이터를 분산 처리할 수 있는 시스템.

<br/>

---

## 레디스에서 키를 관리하는 방법

### 키의 자동 생성과 삭제

- stream, set, sorted set, hash와 같이 하나의 키가 여러 개의 아이템을 가지고 있는 자료 구조에서는 명시적으로 키를 생성하거나 삭제하지 않아도 키는 알아서 생성되고 삭제된다.
- 규칙은 아래와 같다.

1. 키가 존재하지 않을 때 아이템을 넣으면 아이템을 삽입하기 전에 빈 자료 구조를 생성한다.
2. 모든 아이템을 삭제하면 키도 자동으로 삭제한다. (stream은 예외)
3. 키가 없는 상태에서 키 삭제, 아이템 삭제, 자료 구조 크기 조회 같은 읽기 전용 커맨드를 수행하면 에러를 반환하는 대신 키가 있으나 아이템이 없는 것처럼 동작한다.

### 키와 관련된 커맨드

#### 키의 조회

- `EXISTS <key> [key ...]`: 존재 여부 확인
- `KEYS <pattern>`: Glob pattern 스타일로 동작
  - 위험한 커맨드. 엄청나게 많은 키가 저장되어 있어도 모든 키의 정보를 반환하기 때문.
  - 레디스는 싱글 스레드라 다른 클라이언트로부터 들어오는 다른 모든 커맨드는 차단된다. 
- `SCAN <cursor> [MATCH <pattern>] [COUNT <count>] [TYPE <type>]`: 커서를 기반으로 특정 점위의 키만 조회. 비교적 안전
- `SORT`: 키 내부의 아이템을 정렬
- `RENAME`, `RENAMENX`: 키의 이름을 변경하는 커맨드
- `COPY <source> <destination>`: source에 지정된 키를 destination 키에 복사
- `TYPE <key>`: 지정한 키의 자료 구조 타입 반환
- `OBJECT`: 키에 대한 상세 정보를 반환

#### 키의 삭제

- `FLUSHALL`: 레디스에 저장된 모든 키를 삭제
- `DEL`: 키와 키에 저장된 모든 아이템을 삭제하는 커맨드. 동기적으로 작동.
- `UNLINK`: `DEL`과 비슷하게 키와 데이터를 삭제하는 커맨드. 백그라운드에서 다른 스레드에 의해 처리. 먼저, 키와 연결된 데이터의 연결을 끊는다.

#### 키의 만료시간

- `EXPIRE <key> <seconds> [NX | XX | GT | LT]`: 키가 만료될 시간을 초 단위로 정의 가능
  - `NX`: 해당 키에 만료 시간이 정의돼 있지 않을 경우에만 커맨드 수행
  - `XX`: 해당 키에 만료 시간이 정의돼 있을 때에만 커맨드 수행
  - `GT`: 현재 키가 가지고 있는 만료 시간보다 새로 입력한 초가 더 클 때에만 수행
  - `LT`: 현재 키가 가지고 있는 만료 시간보다 새로 입력한 초가 더 작을 때에만 수행
- `EXPIREAT`: 키의 만료 시간 직접 지정.
- `EXPIRETIME`: 키가 삭제되는 유닉스 타임스탬프를 초 단위로 반환
- `TTL`: 몇 초 뒤 만료되는지 반환

<br/>

---

# 참고자료

- 개발자를 위한 레디스, 김가람 지음
