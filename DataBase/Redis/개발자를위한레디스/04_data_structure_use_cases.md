# 04장 레디스 자료 구조 활용 사례

## sorted set을 이용한 실시간 리더보드

- ex) 듀오링고 리더보드
- 리더보드의 유형
  - `절대적 리더보드 absolute leaderboard`: 상위권 목록만 표시
  - `상대적 리더보드 relative leaderboard`: 사용자 기반으로 주변 순위를 비교
- 상대적 리더보드는 여러 수학적 계산이 빠르게 수행돼야 한다.
  - redis의 sorted set에서 데이터는 저장될 때부터 정렬돼 들어간다.
  - 만약 유저의 스코어를 sorted set의 가중치로 설정한다면 스코어 순으로 유저가 정렬되기 때문에 리더보드의 데이터를 읽어오기 위해 매번 데이터를 정렬할 필요가 없다.
- sorted set에 데이터를 저장할 때에는 `ZADD` 커맨드를 사용한다.
- `ZRANGE`를 통해 오름차순으로 정렬할 수 있다.
- 상위 스코어를 3명만 노출하고 싶다면 아래와 같이 `ZREVRANGE` 커맨드를 사용할 수 있다.

```shell
> ZREVRANGE daily-score:2239492 0 2 withscores
```

### 데이터 업데이트

- `ZADD`로 추가하면 신규 입력한 스코어로 값이 저장된다.
  - 스코어에 맞춰 정렬도 자동으로 된다.
- 직접 스코어의 값을 지정해서 변경하지 않고도 `ZINCRBY` 커맨드를 사용해 sorted set 내의 스코어를 증감시킬 수 있다.

```shell
> ZINCRBY daily-score:438924 100 player:33
```

- `player:33`의 스코어를 100만큼 증가시키는 명령어다.
  - 기존에 120점이었다면 220점이 된다. 스코어에 맞춰 정렬도 다시 된다.
- 관계형 데이터베이스만 이용해서 실시간 차트 서비스를 구현하는 것은 까다로운 작업이다.
  - 모든 유저의 변겨 데이터는 실시간으로 업데이트돼야 하며, 점수별로 데이터를 정렬해서 가져오는 작업 자체가 관계형 데이터베이스에 상당한 부하를 줄 수 있기 때문이다.
  - 유저가 증가할수록 계산해야 하는 데이터의 크기는 배로 늘어나며, 이에 따른 처리 시간이 점점 길어질 수 있다.

### 랭킹 합산

- 관계형 데이터베이스에서 주간 누적 랭킹을 구하려면 하나의 테이블에서 일자에 해당하는 데이터를 모두 가져온 뒤 사용자별로 합치고, 이를 다시 정렬하는 작업을 진행해야 한다.
- 반면 redis에서는 `ZUNIONSTORE` 커맨드를 사용해 간단하게 구현할 수 있다.
  - `ZUNIONSTORE`는 지정한 키에 연결된 각 아이템의 스코어를 합산하는 커맨드다.

```shell
> ZUNIONSTORE <생성할 키의 이름> <합산할 키의 개수> <합산할 키 ...>
```

- 위 명령어를 실행하면 새로운 sorted set이 생성되고, 합산된 데이터 순으로 정렬돼 있는 것을 확인할 수 있다.
- 예를 들어 2배 이벤트 같이 가중치가 필요한 경우 아래 명령어와 같이 가중치를 부여할 수도 있다.

```shell
> ZUNIONSTORE my-key 3 d1 d2 d3 WEIGHTS 1 2 1
```

---

## sorted set을 이용한 최근 검색 기록

- 관계형 DB -> 데이터를 가져올 때마다 정렬이 필요하므로, 기록이 늘어날수록 느려진다.
- sorted set! 키워드를 다시 검색했을 때에도 별다른 중복 체크를 진행하지 않아도 된다!
  - 같은 아이템의 데이터를 입력한다면 자동으로 스코어만 업데이트하여 재정렬하면 된다.
- 만약 데이터를 시간순으로 저장한다면? 스코어를 시간으로 두면 된다!
  - 오래된 데이터 삭제? 5개 한도라고 가정했을 때 6번째 데이터가 입력된다면, 가장 오래된 데이터를 지우기 위해 0번 인덱스의 값을 지우면 된다.

---

## set을 이용한 태그 기능

- 블로그 게시글에 태그 추가하기
- 관계형 데이터베이스에서 사용하려면 적어도 2개의 테이블이 추가돼야 한다.
1. 태그 테이블
2. 태그-게시물 테이블

- 레디스에서 set을 사용하면 간단하게 태그 기능을 사용할 수 있다.

```shell
> SADD post:33:tags 개발자 스프링 자바
3
```

- 태그 기능을 사용하는 이유 중 하나? 특정 게시물이 어떤 태그와 연관되어 있는지 확인하는 것뿐만 아니라 특정한 태그를 포함한 게시물들만 확인하기 위해서일 수 있다.

```shell
> SADD post:33:tags 개발자 스프링 자바
3

> SADD tag:개발자:posts 33
1

> SADD tag:스프링:posts 33
1

> SADD tag:자바:posts 33
1
```

- 아래와 같이 `SINTER` 커맨드를 사용해 태그 교집합 포스트들을 확인할 수 있다.

```shell
> SINTER tag:개발자:posts tag:스프링:posts
1) 33
2) 54
3) 65
```

---

## 랜덤 데이터 추출

- 보통 관계형 데이터베이스에서 랜덤 데이터 추출을 사용할 때에는 `ORDER BY RAND()` 함수를 많이 사용한다.
  - 이 함수는 쿼리의 결괏값을 랜덤하게 정렬하지만, 조건 절에 맞는 모든 행을 읽은 뒤 임시 테이블에 넣어 정렬한 다음 랜덤으로 `limit`에 해당할 때까지 데이터를 추출한다.
  - 데이터가 1만 건 이상이라면 부하가 많이 가는 방법이 될 수 있다.
- Redis를 사용해 O(1)의 시간 복잡도로 랜덤 데이터를 추출할 수 있다.
- `RANDOMKEY` 커맨드는 레디스에 저장된 전체 키 중 하나를 무작위로 반환한다.
  - 하지만 보통 하나의 레디스 인스턴스에서는 한 가지 종류의 데이터만 저장하지는 않기 때문에 이 명령은 쓸모가 없을 수 있다.
- `HRANDFIELD`, `SRANDMEMBER`, `ZRANDMEMBER`는 각각 hash, set, sorted set에 저장된 아이템 중 랜덤한 아이템을 추출할 수 있다.
- hash 예시
  - `HRANDFIELD`로 임의의 값 추출
  - 여기서 `COUNT` 옵션을 이용하면 원하는 개수만큼 랜덤 아이템을 반환하며, `WITHVALUES` 옵션을 사용하면 필드에 연결된 값도 반환할 수 있다.

```shell
> HRANDFIELD user:hash 3 WITHVALUES
```

- `COUNT` 값을 음수로 설정하면 중복된 값이 랜덤으로 뽑힐 수 있다. (양수는 고유)

```shell
> HRANDFIELD user:hash -3 WITHVALUES
```

- 이 속성은 `SRANDMEMBER`, `ZRANDMEMBER`도 마찬가지

---

## 레디스에서의 다양한 카운팅 방법

### 좋아요 처리하기

- 실시간 트래픽이 굉장히 많은 사이트라면 하나의 뉴스 댓글에 좋아요가 눌리는 일은 1초에 몇만 개 이상 발생할 수 있다.
  - 관계형 DB 테이블의 특정 행에서 좋아요 개수 데이터를 증가시키는 일은 데이터베이스에 직접적인 영향을 끼칠 수 있다.
- 또한 하나의 유저는 같은 댓글에 한 번씩만 좋아요를 누를 수 있어야 하기 때문에 단순히 좋아요의 개수를 파악하는 것이 아닌, 어떤 유저가 어떤 댓글에 좋아요를 눌렀는지의 데이터 또한 처리할 수 있어야 한다.
- set으로 간단하게 해볼 수 있다.
  - 댓글 ID 3242에 좋아요를 누른 유저 ID 224

```shell
> SADD comment-like:3242 224
```

- `SCARD` 커맨드로 각 댓글별 좋아요 수를 파악할 수 있다.

```shell
> SCARD comment-like:3242
253
```

### 읽지 않은 메시지 수 카운팅하기

- 채팅 애플리케이션. 읽지 않은 메시지 카운팅 및 관리
- 메시지가 도착할 때마다 관계형 DB를 업데이트하기보다는 레디스와 같은 인메모리 DB에 일시적으로 저장한 뒤 필요한 시점에 한꺼번에 업데이트하는 방식을 사용해서 관계형 데이터베이스의 부하를 최소화하고 성능을 향상
- hash 활용
  - 사용자의 ID를 키로 사용하고, 채널의 ID를 아이템의 키로 활용

```shell
> HINCRBY user:333 channel:214 1
(integer) 1
```

- 만약 누군가가 이미 전송한 메시지를 삭제했다면? `HINCRBY`에 음수값을 입력해 데이터 감소

```shell
> HINCRBY user:333 channel:214 -1
(integer) 25
```

### DAU 구하기

- Bitmap을 활요하면 메모리를 효율적으로 줄이면서도 실시간으로 서비스의 DAU를 확인할 수 있다.
- 천만 사용자는 천만 개의 비트로 나타낼 수 있으며, 이는 대략 1.2MB 크기에 해당한다.
  - string은 최대 512MB까지 저장 가능하므로 거뜬.
- 유저 id 14가 서버에 접속?

```shell
> SETBIT uv:20250310 14 1
(integer) 0
```

- 해당 일자에 접근한 유저 수 확인! `BITCOUNT` 커맨드

```shell
> BITCOUNT uv:20250310
(integer) 1023
```

- 비트맵에서 `BITOP` 커맨드를 사용하면 `AND`, `OR`, `XOR`, `NOT` 연산을 할 수 있으며, 레디스 서버에서 바로 계산된 결과를 가져올 수 있어 개별 비트를 가져와 서버에서 처리하는 번거로움을 줄여줄 수 있다.
- 11월 1일~3일 매일 출석한 유저에게 보상 지급?

```shell
> BITOP AND event:202411 uv:20241101 uv:20241102 uv:20241103
(integer) 23
```

- 결과 데이터는 `event:202411`에 담기게 된다.

### hyperloglog를 이용한 애플리케이션 미터링

- `Pay as you go`: 서비스를 사용한 만큼 지불.
- 아래 조건을 만족한다면 hyperloglog를 사용하는 것을 고려할 수 있다.
  - 집합 내의 유일한 데이터의 개수를 카운팅
  - 1% 미만의 오차 허용 가능
  - 카운팅할 때 사용한 정확한 데이터를 다시 확인하지 않아도 괜찮다.
- hyperloglog를 이용할 수 있다면 최소한의 메모리만을 사용해 중복되지 않은 데이터의 개수를 계산할 수 있다.
- 아래 예시는 user ID 245의 호출 횟수 계산

```shell
> PFADD 20250310:user:245 32425
(integer) 1

> PFADD 20250310:user:245 2156
(integer) 1

> PFADD 20250310:user:245 32425
(integer) 1

> PFCOUNT 20250310:user:245
(integer) 2
```

- `PFCOUNT`를 사용하면 중복되지 않은 데이터의 개수를 확인할 수 있다.
  - 위의 예시에서는 `32425`와 `2156` 2건
- `PFMERGE` 커맨드를 이용하면 여러 개의 hyperloglog를 합칠 수 있으므로 분기별 또는 연도별 합산 데이터를 간편하게 계산할 수 있다.

```shell
> PFMERGE 2025:user:245 202501:user:245 202502:user:245 202503:user:245
"OK"

> PFCOUNT 2025:user:245
(integer) 422
```

---

## Geospatial Index를 이용한 위치 기반 애플리케이션 개발

### 위치 데이터란?

- 위치 데이터는 주로 경도와 위도(x, y) 좌표 쌍으로 표현된다.
- 데이터 저장소는 아래와 같은 기능을 제공해야 한다.
  - 사용자의 현재 위치 파악
  - 사용자의 이동에 따른 실시간 변동 위치 업데이트
  - 사용자의 위치를 기준으로 근처의 장소 검색
- 모든 사용자의 정보를 1초마다 업데이트??? 사용자에 증가에 따라 엄청난 부하..

### 레디스에서의 위치 데이터

- 다른 저장소보다 효율적으로 위치 데이터를 처리할 수 있다.
- 레디스를 활용하면 데이터 저장뿐만 아니라 실시간 위치 연산을 직접 수행할 수 있어, 데이터 이동으로 인한 네트워크 트래픽을 감소시키고 애플리케이션 코드의 복잡성을 감소시킬 수 있으므로 빠른 응답 속도를 보장한다.

#### geo set

- 위치 공간 관리에 특화된 데이터 구조. 각 위치 데이터는 경도와 위도의 쌍으로 저장.
- 내부적으로 sorted set 구조로 저장.
- `GEOADD`를 통해 데이터 추가 가능.
  - restaurant이라는 키에 경도, 위도, 식당 이름 순으로 데이터를 저장.

```shell
> GEOADD restaurant 50.0295215218 14.421525127892 uklendu
```

- 또한 1KM 이내의 식당을 찾는 것도 가능
  - `fromlonlat`으로 위도와 경도 지정
  - `byradius`로 반지름 값 기준으로 1KM
  - 직사각형을 원한다면 `BYBOX` 옵션으로 `width`와 `height`를 추가 지정하여 사용하면 된다.

```shell
> GEOSEARCH restaurant fromlonlat 50.0295215218 14.421525127892 uklendu byradius 1 km
```

---

# 참고자료

- 개발자를 위한 레디스, 김가람 지음
