# 6장 레디스를 메시지 브로커로 사용하기

- 서비스 간 통신이 불가능한 상황이 바로 장애로 이어지지 않게, 당장 메시지를 처리하지 못하더라도 보낸 메시지를 어딘가에 쌓아둔 뒤 나중에 처리할 수 있는 채널을 만들어 주는 것. 이것이 메시지 브로커의 핵심 역할이라고 할 수 있다.
- 메시지 브로커는 크게 메시징 큐와 이벤트 스트림이라는 두 가지 형태로 나눌 수 있다.

## 메시징 큐와 이벤트 스트림

<img src="img/messaging_queue01.png">

- `생산자 producer`: 데이터를 생성하는 쪽
- `소비자 consumer`: 데이터를 수신하는 쪽

<img src="img/event_stream01.png">

- `발행자 publisher`: 데이터를 생성하는 쪽
- `구독자 subscriber`: 데이터를 조회하는 쪽

---

- 메시징 큐는 1대1
- 스트림은 다대다

#### 메시징 큐와 이벤트 스트림의 2가지 차이점

1. 방향성
- 메시징 큐의 생산자는 소비자의 큐로 데이터를 직접 푸시.
  - 2개의 서비스에 같은 메시지를 보내야 할 때 메시징 큐를 이용한다면 생산자는 2개의 각각 다른 메시징 큐에 각각 데이터를 `푸시 push`해야 한다.
- 반면 스트림을 이용하면 생산자는 스트림의 특정 저장소에 하나의 메시지를 보낼 수 있고, 메시지를 읽어가고자 하는 소비자들은 스트림에서 같은 메시지를 `풀 pull`해 갈 수 있기 때문에 메시지를 복제해서 저장하지 않아도 된다.

2. 영속성
- 메시징 큐에서는 소비자가 데이터를 읽어갈 때 큐에서 데이터를 삭제
- 이벤트 스트림에서 구독자가 읽어간 데이터는 바로 삭제되지 않고, 저장소의 설정에 따라 특정 기간 동안 저장될 수 있다.
  - 새롭게 추가된 구독자들이 이전 히스토리를 확인할 수 있다는 뜻이다.

---

### 레디스를 메시지 브로커로 사용하기

- 레디스에서 제공하는 pub/sub를 사용하면 빠르고 간단한 방식으로 메시지를 전달할 수 있는 메시지 브로커를 구현할 수 있다.
- 발행자가 특정한 채널에 데이터를 전송하면 이 채널을 듣고 있는 모든 소비자는 데이터를 바로 소비할 수 있다.
- 레디스의 pub/sub에서 모든 데이터느느 한 번 채널에 전파된 뒤 삭제되는 일회성의 특징을 가지며, 메시지가 잘 전달됐는지 등의 정보는 보장하지 않는다.
  - 따라서 완벽하게 메시지가 전달돼야 하는 상황에는 적합하지 않을 수 있다.
  - 하지만 `fire-and-forget` 패턴이 필요한 간단한 알림 서비스에서는 유용하게 사용될 수 있다.

> #### fire-and-forget 패턴
> - 비동기 프로그래밍에서 사용되는 디자인 패턴. 어떤 작업을 실행하고 그 결과에 대한 응답을 기다리지 않고 바로 다음 코드를 실행하는 것을 의미한다.
> - 성능 향상. 비동기. 작업의 완료나 결과에 대한 처리가 필요하지 않을 때 유용.
> - ex) 로깅, 이벤트 발행, 통계 데이터 수집과 같이 작업의 성공 또는 실패에 대한 관심이 없는 경우
> - 신뢰성이 필요한 경우 사용하면 안 된다.

- 레디스의 list 자료 구조는 메시징 큐로 사용하기에 알맞다.
- 레디스의 stream을 사용하면 레디스를 완벽한 스트림 플랫폼으로 사용할 수 있다.
  - 소비자와 소비자 그룹이라는 개념을 이용하면 카프카와 비슷하게 데이터의 분산 처리를 구현할 수 있다.

### 레디스의 pub/sub

- 레디스 노드에 접근할 수 있는 모든 클라이언트는 발행자와 구독자가 될 수 있다.
  - 발행자는 메시지를 채널로 보낼 수 있다. 그러나 어떤 구독자가 메시지를 읽어가는지, 정상적으로 모든 구독자에게 전달됐는지 확인할 수 없다.
  - 구독자 또한 메시지를 받을 수 있으나, 해당 메시지가 언제 어떤 발행자에 의해 생성됐는지 등의 메타데이터는 알 수 없다.
- 만약 정합성이 필요하다면 애플리케이션 단의 로직이 필요

#### 메시지 publish하기

- `PUBLISH` 커맨드를 이용해 데이터를 전파할 수 있다.

```shell
> PUBLISH <channel> <message>
```

#### 메시지 구독하기

- `SUBSCRIBE` 커맨드를 이용하면 특정 채널을 구독할 수 있다.

```shell
> SUBSCRIBE <channel>...
```

- 사용 예시) 여러 채널을 한꺼번에 구독

```shell
> SUBSCRIBE event1 event2
```

- 구독자가 수행할 수 있는 커맨드
  - `SUBSCRIBE`
  - `SSUBSCRIBE`
  - `SUNSUBSCRIBE`
  - `PSUBSCRIBE`: 일치하는 패턴에 해당하는 채널을 한 번에 구독 (`glob-style` 패턴)
  - `UNSUBSCRIBE`
  - `PUNSUBSCRIBE`
  - `PING`
  - `RESET`
  - `QUIT`

#### 클러스터 구조에서의 pub/sub

- 클러스터는 레디스 자체적으로 제공하는 데이터 분산 형태의 구조다.

<img src="img/cluster01.png">

- 하나의 노드에 메시지를 발행하면 메시지는 모든 노드에 전파.
- 사실, 비효율적인 방식으로 여겨질 수 있다.
  - 클러스터는 주로 대규모 서비스에서 데이터를 분산해서 저장하고 처리하기 위해 도입됐으며, 그렇기 때문에 레디스 클러스터 내에서 pub/sub을 사용할 때 메시지가 모든 레디스 노드에 복제되는 방식은 클러스터 화녁ㅇ의 핵심 목표와는 부합하지 않다.
  - 이로 인해 불필요한 리소스 사용과 네트워크 부하 발생 가능성

#### sharded pub/sub

- 레디스 7.0부터 도입된 기능
- 각 채널이 슬롯에 매핑
  - 클러스터에서 키가 슬롯에 할당되는 것과 동일한 방식으로 채널이 할당.
  - 같은 슬롯을 가지고 있는 노드 간에만 pub/sub 메시지를 전파.

<img src="img/shardedpubsub01.png">

- 아래와 같이 `SPUBLISH` 커맨드로 발행된 메시지는 모든 노드에 전파되지 않으며, 노드의 복제본에만 전달된다.

```shell
10.0.0.1:6379> SPUBLISH channel1 apple
-> Redirected to slot [7092] located at 10.0.0.2:6379
10.0.0.2:6379>
```

- 로컬에서 redis-cli 클라이언트를 이용해 데이터를 전파하려고 할 때, 연결된 노드에서 지정한 채널에 전파할 수 없다는 메시지와 함께 연결된 노드로 리다이렉트된다.
- `SSUBSCRIBE`도 마찬가지로 특정한 서버에서만 수행될 수 있다.
- Sharded pub/sub을 이용하면 클러스터 구조에서 pub/sub되는 메시지는 모든 노드로 전파되지 않기 때문에 불필요한 복제를 줄여 자원을 절약할 수 있다는 장점이 있다.

----

## 레디스의 list를 메시징 큐로 사용하기

### list의 EX 기능

- 트위터는 각 유저의 타임라인 캐시 데이터를 레디스의 list 자료 구조로 관리한다.
- 유저 A가 새로운 트윗을 작성하면 그 데이터는 A를 팔로우하는 유저의 타임라인 캐시에 저장된다.
  - A를 팔로우하는 유저 B와 C의 타임라인 캐시 list에 새로운 아이템으로 추가된다.
- 타임라인 캐시를 저장할 때 `RPUSH`가 아닌 `RPUSHX` 커맨드를 사용한다.
  - `RPUSHX` 커맨드는 데이터를 저장하고자 하는 list가 이미 존재할 때에만 아이템을 추가하는 커맨드다.
  - 이미 캐시된 타임라인에만 데이터를 추가할 수 있다.
  - 자주 들어오지 않는 유저 D에게는 타임라인 캐시 데이터를 굳이 관리해야 할 필요가 없기 때문이다.
  - 애플리케이션에서 확인할 필요 없이 레디스에서 제어가 가능해 성능이 향상되는 효과!

### list의 블로킹 기능

- 레디스를 이벤트 큐로 사용할 경우 블로킹 기능 또한 유용하게 사용할 수 있다.

<img src="img/event_queue01.png">

- 이벤트 루프는 이벤트 큐에 새 이벤트가 있는지 체크하며, 새로운 이벤트가 없을 경우 정해진 시간(`polling interval`) 동안 대기한 뒤 다시 이벤트 큐에 데이터가 있는지 확인하는 과정을 반복한다.
  - 폴링 프로세스가 진행되는 동안 애플리케이션과 큐의 리소스가 불필요하게 소모될 수 있다.
  - 또한 이벤트 큐에 이벤트가 들어왔을 수 있지만, 폴링 인터벌 시간 동안 대기한 뒤 다시 확인하는 과정을 거치기 때문에 이벤트를 즉시 처리할 수 없다는 단점이 있다.
- 이때 list의 블로킹 기능을 사용하면 이와 같은 불필요함을 줄일 수 있다.
- `BRPOP`이나 `BLPOP`을 사용하면 데이터를 요청했을 때 즉시 반환. 없으면 데이터가 들어올 때까지 기다린 후 들어온 값을 반환 혹은 클라이언트가 설정한 타임아웃이 지나면 nil값 반환. 
  - `BRPOP`: `RPOP`에 블로킹 추가
  - `BLPOP`: `LPOP`에 블로킹 추가
- 아래 예시는 `queue:a`에 대해 5초 동안 대기하고 5초가 경과하면 nil 반환
  - 타임아웃 값을 0으로 설정하면 데이터가 리스트에 들어올 때까지 제한 없이 기다리라는 의미로 쓰인다.
  - 하나의 리스트에 대해 여러 클라이언트가 블로킹될 수 있으며, 리스트에 데이터가 입력되면 가장 먼저 요청을 보낸 클라이언트가 데이터를 가져간다.
  - 또한 `BRPOP`은 `RPOP`과는 다르게 키와 데이터 2개의 값을 반환한다.

```shell
> BRPOP queue:a 5
1) "queue:a"
2) "data"
```

- 여러 리스트에서 대기할 수 있게 하기 위해서다.

<img src="img/event_queue02.png">

- 아래 커맨드 `BRPOP`는 1,000초 동안 `queue:a`, `queue:b`,`queue:c` 중 어느 하라도 데이터가 들어올 때까지 기다린 뒤, 그중 하나의 리스트에 데이터가 들어오면 해당 값을 읽어온다.

```shell
> BRPOP queue:a queue:b queue:c timeout 1000
1) "queue:b"
2) "DATA"
(19.89s)
```

### list를 사용한 원형 큐

- 여러 개의 클라이언트가 병렬적으로 같은 아이템에 접근해야 하는 경우, `원형 큐 circular queue`를 이용해 아이템을 처리하고 싶을 수 있다.
- list에서 `RPOPLPUSH` 커맨드를 사용하면 간편하게 원형 큐를 사용할 수 있다.

---

## Stream

# 참고자료

- 개발자를 위한 레디스, 김가람 지음
