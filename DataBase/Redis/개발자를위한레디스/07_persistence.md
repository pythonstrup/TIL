# 07장 레디스 데이터 백업 방법

## 레디스에서 데이터를 영구 저장하기

- 인스턴스 재시작 => 데이터 손실
- 레디스가 복제 구조를 사용할 경우, 데이터가 실시간으로 복제본에 전달되고 있으니 따로 데이터를 백업할 필요를 느끼지 못할 수도 있다.
  - 하지만 백업과 복제는 목적부터 다르다는 점을 유의
  - 복제: 가용성을 위한 것.
  - 백업: 장애 상황에서 데이터의 복구를 위해 필요.
- 디스크에 주기적으로 백업하는 것이 안전. 데이터를 안정하게 저장하기 위한 방법으로 RDB와 AOF 두 가지 백업 방식을 지원.
    - `AOF(Append Only File)`: 레디스 인스턴스가 처리한 모든 쓰기 작업을 차례대로 기록. 복원 시에는 파일을 다시 읽어가며 데이터 세트 재구성
    - `RDB(Redis Database)`: 일정 시점에 메모리에 저장된 데이터 전체를 저장 (snapshot 방식)
- 아래와 같이 명령어를 진행했다고 가정하자.

```redis
> SET key1 a
> SET key1 apple
> SET key2 b
> DEL key2
```

- 위의 커맨드를 실행하고 나면 AOF와 RDB에는 각각 아래와 같이 저장될 것이다.
  - 사실 AOF는 `레디스 프로토콜 RESP` 형태로 저장되고, RDB는 바이너리 형태로 저장되어 우리가 읽고 해석할 수 없다.

<img src="img/persistence01.png">

- 그렇다면 어떤 백업 방법을 사용하는 것이 좋을까?
  - RDB의 경우, 시점 단위로 여러 백업본을 저장할 수 있고, AOF보다 복원이 빠르다는 장점이 있지만 특정 시점으로의 복구는 불가능하다.
  - AOF는 RDB 파일보다 크고 주기적으로 압축해 작성해야 하지만, 원하는 시점으로 복구할 수 있다는 장점이 있다.
- 하나의 인스턴스에서 RDB와 AOF 옵션을 동시에 사용하는 것도 가능하며, 권장된다.
- 레디스에서 데이터를 복원할 수 있는 시점은 서버가 재시작될 때뿐이며, 레디스 인스턴스의 실행 도중에 데이터 파일을 읽어올 수 있는 방법은 없다.
  - 재시작될 때 AOF 파일이나 RDB 파일이 존재하는지 확인한 뒤, 파일이 있을 때에는 파일을 로드한다.
  - 레디스는 RDB 파일보다 AOF 파일이 더 내구성이 보장된다고 판단하기 때문에 2개의 파일이 모두 존재할 때에는 AOF의 데이터를 로드한다.

---

## RDB 방식의 데이터 백업

- 레디스에서 데이터를 백업하기 위한 가장 단순한 방법.
- RDB 파일이 저장될 때마다 원격 저장소로 파일을 옮겨 2차 백업을 수행한다면 데이터 센터 장애 등 더 큰 장애에도 대처할 수 있다.
- 하지만 장애가 발생했을 때 손실 가능성을 최소화해야 하는 서비스에는 RDB 파일을 이용한 백업만 사용하는 것은 적절하지 않다.
  - 사용자가 지정한 시간 단위로 파일이 저장되기 때문에 저장 시점부터 장애가 발생한 직전까지의 데이터는 손실될 수 있다는 것을 알아둬야 한다.
- RDB 파일을 생성할 수 있는 방법은 크게 세 가지다.
1. 설정 파일에서 특정 조건에 파일이 자동으로 저장되도록 지정
2. 사용자가 원하는 시점에 커맨드를 이용해 수동으로 파일을 생성
3. 복제 기능을 사용해 레디스가 자동으로 RDB 파일을 생성

### 1. 특정 조건에 자동으로 RDB 파일 생성

```
save <기간(초)> <기간 내 변경된 키의 개수>
dbfilename <RDB 파일 이름>
dir <RDB 파일이 저장될 경로>
```

- 레디스 설정 파일에서 `save` 옵션을 사용해 원하는 조건에 RDB 파일을 저장하도록 설정할 수 있다.

```
save 900 1
save 300 10
save 60 10000
```

- `redis.conf`에서 위와 같은 조건으로 save 옵션을 설정한다면 인스턴스는 다음과 같은 상황에서 RDB 파일을 생성한다.
  - 900초(15분) 동안 1개 이상의 키가 변경된 경우
  - 300초(5분) 동안 10개 이상의 키가 변경된 경우
  - 60초(1분) 동안 10,000개 이상의 키가 변경된 경우
- 만약 RDB 파일을 저장하고 싶지 않다면 `save ""`와 같이 빈 문자열로 설정해서 옵션을 비활성화할 수 있다.
  - 이미 레디스 인스턴스가 실행 중인 상태에서 RDB 저장을 비활성화하고 싶다면 `CONFIG SET` 커맨드를 이용해 `save` 파라미터를 ""로 초기화시키면 된다.

```redis
# 현재 적용된 save 옵션 확인
> CONFIG GET save
1) "save"
2) "900 1 300 10 60 10000"

# save 옵션 초기화
> CONFIG SET save ""
OK
```

### 2. 수동으로 RDB 파일 생성

- `SAVE`, `BGSAVE` 커맨드를 사용하면 원하는 시점에 직접 RDB 파일을 생성할 수 있다.
  - 두 커맨드 모두 실행 시점의 메모리 스냅샷을 생성하는 커맨드지만 동작하는 방식에 차이가 있다.
- `SAVE`는 동기 방식으로 파일을 저장. 
  - 해당 명령어가 실행되면 파일 생성이 완료될 때까지 다른 모든 클라이언트의 명령을 차단. 
  - 따라서 일반적인 운영 환경에서는 실행 X
- `BGSAVE`는 `fork`를 호출해 자식 프로세스를 생성하며 생성된 자식 프로세스가 백그라운드에서 RDB 파일을 생성한 뒤 종료된다.
  - 레디스를 이용하는 다른 클라이언트는 원래대로 부모 프로세스를 이용하므로 파일 저장에 영향을 받지 않는다.
  - 만약 이미 백그라운드에서 데이터가 저장되고 있을 때 이 커맨드를 수행하면 에러를 반환한다.
    - 이런 상황에서는 `BGSAVE`와 `SCHEDULE` 옵션을 사용.
- RDB 파일이 정상적으로 저장됐는지는 `LASTSAVE` 커맨드로 확인할 수 있으며, 마지막으로 RDB 파일이 저장된 시점을 유닉스 타임스탬프로 반환한다.

### 3. 복제를 사용할 경우 자동으로 RDB 파일 생성

- 복제본에서 `REPLICAOF` 커맨드를 사용해 복제를 요청하면 마스터 노드에서는 RDB 파일을 새로 생성해 복제본에 전달한다.

<img src="img/persistence02.png">

- 혹은 이미 복제 연결이 돼 있는 상태에서 네트워크 등의 이슈로 인해 일정 시간 이상 복제가 끊어졌다가 복구된 경우 복제 재연결이 발생하며, 이럴 경우에도 마스터 노드는 복제본으로 RDB 파일을 전송한다.
  - 따라서 복제 연결을 처음 시작했을 때뿐만 아니라 이미 복제 연결이 돼 있는 상테에서도 상황에 따라 마스터에서는 언제든지 RDB 파일을 재생성할 수 있다.

---

## AOF 방식의 데이터 백업

- AOF는 레디스 인스턴스에서 수행된 모든 쓰기 작업의 로그를 차례대로 기록한다.
  - 실수로 `FLUSHALL` 커맨드로 데이터를 모두 날려버렸다 해도, AOF 파일을 직접 열어 `FLUSHALL` 커맨드만 삭제한 뒤 레디스를 재시작시킨다면 커맨드를 실행하기 직전까지로 데이터를 바로 복구할 수 있다.
- 설정 파일에서 `appendonly` 옵션을 `yes`로 지정하면 AOF 파일에 주기적으로 데이터가 저장된다.
  - AOF 파일은 `appenddirname`에서 지정한 경로와 `appendfilename` 옵션에 설정한 이름으로 생성된다.

```
appendonly yes
appendfilename "appendonly.aof"
appenddirname "appendonlydir
```

- 아래 명령어가 실행되면 어떤 식으로 AOF 파일이 저장될까?

```
> SET key1 apple
> SET key1 beer
> DEL key1
> DEL non_existing_key
```

- 1, 2, 3번째 명령어는 서버의 메모리에 영향을 끼치는 작업이기 때문에 AOF 파일에 저장된다.
  - 4번째는 저장되지 않는다.
- AOF에서 모든 커맨드의 실행 내역은 아래와 같이 `레디스 프로토콜 RESP` 형식으로 저장된다.

```
*3
$3
set
$4
key1
$5
apple
*3
$3
set
$4
key1
$4
beer
*2
$3
del
$4
key1
```

- 하지만 항상 AOF 파일이 사용자가 실행한 커맨드를 그대로 저장하는 것은 아니다.
- list에서 블로킹 기능을 지원하는 `BRPOP` 커맨드는 AOF 파일에 저장될 때에는 `RPOP`로 기록
  - AOF 파일에는 블로킹 기능을 굳이 명시해줄 필요가 없기 때문.
- string 값에 사용자가 입력한 부동소수점 값을 더해주는 `INCRBYFLOAT` 명령어도 AOF 파일에는 그대로 기록되지 않는다.

```redis
> SET counter 100
OK
> INCRBFLOAT counter 50
"150"
```

- 레디스가 실행되는 아키텍처에 따라 부동소수점을 처리하는 방식이 다를 수 있기 때문에 AOF 파일에는 증분 후의 값을 직접 `SET`하는 커맨드로 변경돼 저장된다.

```resp
*3
$3
SET
$7
counter
$3
100
*4
$3
SET
$7
counter
$3
150
$7
KEEPTTL
```

- AOF는 Append-Only File이라는 이름 뜻 그대로 실행되는 커맨드가 파일 뒤쪽에 계속 추가되는 방식으로 동작한다.
  - 따라서 인스턴스가 실행되는 시간에 비례해서 AOF 파일의 크기는 계속 증가하게 된다.
  - INCR 커맨드를 사용해 counter 키를 100번 증가시킨다면 실제 레디스의 메모리에서 counter라는 키는 100이 증가된 값을 저장하고 있지만, AOF 파일에는 키를 증가시킨 100번의 실행 내역이 그대로 남아 있게 된다.

### AOF 파일을 재구성하는 방법

- 

---

# 참고자료

- 개발자를 위한 레디스, 김가람 지음
