# 12장 클라이언트 관리

- 클라이언트 연결의 성능을 향상시키기 위한 파이프라이닝과 클라이언트 사이드 캐싱

## 클라이언트 핸들링

- 레디스는 클라이언트 연결을 수락하는 데 TCP 포트와 유닉스 소켓을 사용할 수 있다.
  - 일반적으로 사용자 연결을 받기 위해 TCP 포트를 사용하지만, 설정 파일에서 `unixsocket` 및 `unixsocketperm` 매개변수를 설정하면 원하는 경로에서 소켓 파일을 생성하고 해당 파일의 권한을 지정할 수 있다.

```
unixsocket /tmp/redis.sock
unixsocketperm 777
```

- 이렇게 설정한 뒤 레디스를 시작하면 원하는 경로에 파일이 생성되며, 소켓 통신이 활성화된다.
  - 이후에는 클라이언트가 해당 유닉스 소켓 파일의 경로를 사용해 레디스 서버에 연결할 수 있다.

```shell
$ redis-cli -s /tmp/redis.sock
```

- 레디스는 `멀티플렉싱 Multiplexing` 방식을 사용하며, 이로 인해 하나의 통신 채널을 통해 여러 데이터 스트림을 전송할 수 있다.
  - 하나의 스레드에서 여러 소켓을 감시하고, 소켓 이벤트가 발생하는지 지속적으로 확인할 수 있기 때문에 효율적인 다중 클라이언트 지원을 가능하게 한다.
  - 또한, 많은 클라이언트 요청을 동시에 처리하는 데 블로킹 문제를 피할 수 있다.
- 또한 Non-Blocking을 활용해 I/O 작업 완료될 때까지 대기하지 않고 다른 작업을 처리할 수 있어서, 클라이언트 요청을 비동기적으로 처리하고 다수의 클라이언트 요청을 동시에 처리할 수 있다.
- 레디스는 클라이언트 커넥션을 생성할 때 `TCP_NODELAY` 옵션을 사용
  - 작은 데이터라도 버퍼링하지 않고 지연 없이 가능한 한 빨리 패킷으로 전송하려 시도.
  - 이는 주로 작은 데이터 조각을 실시간으로 전송해야 하는 경우에 사용. => 클라이언트의 연결 지연을 최소화

> #### 참고
> - 버전 7을 기준으로, 레디스와 클라이언트가 통신할 때 `TCP_NODELAY` 옵션을 해제할 수는 없다.
> - 하지만 레디스 노드 간 복제 연결을 할 때 에는 다음 설정 값을 변경해 TCP_NODELAY 옵션을 해제할 수 있다.
> ```
> repl-disable-tcp-nodelay yes
> ```
> - `yes`로 설정하면 복제본에 데이터를 전송할 때 더 작은 수의 TCP 패킷과 대역폭을 사용 => 40ms까지의 지연이 발생할 수 있다.
> - `no`로 하면 마스터와 복제본 간 데이터 지연을 최소화해서 데이터를 복제본에서 좀 더 빨리 확인할 수 있지만, 데이터 복제를 위해 더 많은 대역폭 사용
> - 레디스는 지연 시간을 최소화하기 위해 `no`로 설정하고 있지만, 대규모 트래픽 상황 또는 마스터와 복제본 간의 거리가 멀 경우에는 `yes`로 변경하는 것이 도움이 될 수 있다.

- 클라이언트가 초기화되면 `maxclients` 설정값과 비교해 현재의 클라이언트 수가 `maxclients` 값에 도달했는지 확인.
  - 이 값을 초과하면 새로운 클라이언트의 접속을 거부
- 레디스 버전 2.6 이후 버전부터는 기본적으로 `maxclients` 수가 10000으로 설정되며, 설정 파일에서 별도로 변경하지 않는 한 이 값이 유지
  - 그러나 레디스가 시작될 때 운영체제의 설정 값을 확인해 클라이언트의 수를 제한할 수 있다.
  - 레디스 서버 내부적으로 32개의 파일 디스크립터 수를 사용한다고 예약했기 때문에 설정한 `maxclients` 값은 운영체제에 맞게 변경돼 레디스 인스턴스가 시작된다.

### 클라이언트 버퍼 제한

#### 출력 버퍼

- 레디스는 클라이언트에 반환할 데이터를 임시로 저장하기 위해 각 클라이언트마다 `클라이언트 출력 버퍼 client output buffer`를 생성한다.
  - 연결된 클라이언트가 1,000개라면 1,000개의 출력 버퍼를 생성한다.
  - 만약 출력 버퍼의 크기는 가변적이라면 무제한으로 늘어날 수 있음.
- 특히 pub/sub 클라이언트에서 발행자가 메시지를 발행하면 해당 메시지는 모든 구독자에게 전달
  - 일반적으로 pub/sub 연결의 경우 발행자가 보낸 새로운 메시지를 구독자가 처리하는 속도가 충분하지 않은 상황에서 발생하는 경우가 많다.
- 따라서 레디스는 출력 버퍼 크기에 대한 제한을 둬서, 버퍼 크기가 일정 수준 이상으로 증가할 경우 클라이언트 연결을 종료하게 된다.
- 두 가지 종류의 제한값을 사용할 수 있다.
1. 하드 제한: 고정된 제한값. 도달하면 레디스는 클라이언트 연결을 가능한 한 빨리 닫는다.
2. 소프트 제한: 시간에 따라 다르며, 이를테면 10초 동안 지속적으로 32MB보다 큰 출력 버퍼를 유지한 경우 연결을 닫는다.

- pub/sub 클라이언트의 경우 기본 하드 제한이 32MB, 소프트 제한은 60초당 8MB
  - pub/sub 클라이언트가 빠르게 처리되는 메시지들을 처리하기 위해 더 많은 메모리 공간이 필요하기 때문
- 복제본을 위한 출력 버퍼 크기 제한은 기본이 하드 제한은 256MB, 소프트 제한은 60초당 64MB
  - 복제본이 마스터 서버로부터 대량의 데이터를 받아들이는 경우가 많아, 더 큰 출력 버퍼가 필요하기 때문
- `CONFIG SET`을 통해 변경 가능.

```redis
> CONFIG SET client-output-buffer-limit <class> <hard-limit> <soft-limit> <soft-limit-duration>
```

- `class`: `normal`, `slave(replica)`, `pubsub` 중 하나
  - `normal`: 일반 레디스 클라이언트
  - `salve(replica)`: 복제본 클라이언트
- `hard-limit` & `soft-limit`: 하드 제한 및 소프트 제한 값. 바이트 단위로 지정
- `soft-limit-duration`: 소프트 제한이 적용되는 시간 간격. 초 단위

- 아래 명령어는 모든 limit 값을 제거하는 예시

```redis
> CONFIG SET client-output-buffer-limit "slave 0 0 0"
OK
```

#### 클라이언트 쿼리 버퍼 (내부 버퍼)

- 클라이언트에서 받은 커맨드를 레디스에서 잠시 보관하는 내부 버퍼의 역할.
- 기본적으로 1GB로 설정
  - 클라이언트에서 발생하는 버그로 인해 클라이언트 쿼리 버퍼가 무한히 증가하는 것을 방지하기 위한 조치
- 특별한 상황에서 조정이 필요하다면 `client-query-buffer-limit` 설정을 변경

### 클라이언트 이빅션

- 클라이언트 연결 수 증가 => 메모리 사용량 증가 => 메모리 과다 사용으로 인한 OOM 및 데이터 이빅션 유발
  - `maxmemory-policy` 설정을 한차례 확인한 적이 있음
- 레디스 7.0부터는 `maxmemory-clients` 설정값을 사용해 모든 클라이언트 연결이 사용하는 누적 메모리의 양을 제한할 수 있게 되었다.
  - 임계치에 도달하면 레디스는 서버에서 클라이언트 연결을 해제해 메모리를 확보한다.
  - 서버는 가장 많은 메모리를 사용하는 연결부터 해제하려고 시도하며, 이 기능을 `클라이언트 이빅션 client eviction`이라고 한다.
- `redis.conf`나 `CONFIG SET`으로 변경 가능
- 이 값을 0으로 지정하면 기능을 사용하지 않음을 의미
- 퍼센트 기호를 사용해 `maxmemory`의 비율로 설정하는 것도 가능하다.

```
maxmemory-clients 1G
maxmemory-clients 10%
```

- 대규모 트래픽 환경에서는 5%나 10%로 설정하는 것을 권장한다.
- 복제 연결에 사용되는 복제본과 마스터 커넥션은 클라이언트 이빅션 기능에 영향을 받지 않기 때문에 복제 과정에서 사용하는 메모리 양이 매우 많더라도 이 설정에 의해 복제 연결은 자동으로 끊어지지 않는다.
- 특정 클라이언트만 기능에서 제외하는 것도 가능하다.
- 아래 명령어를 사용하면 강제로 연결이 끊기 지 않으며 `off`로 바꿔줘야 이전 상태로 복원 가능하다.

```redis
> CLIENT NO_EVICT on
```

### Timeout과 TCP Keepalive

- 레디스 서버에 클라이언트가 연결되면, 장기간 동안 커맨드를 수행하지 않더라도 연결은 계속 유지된다.
- 특정 시점에서 활동이 없는 클라이언트를 정리하려면 타임아웃 설정을 사용해 유휴 연결을 해제할 수 있다.
  - `redis.conf` 파일에서 `timeout` 설정값을 지정하거나, 레디스 서버가 동작 중일 때 `CONFIG` 커맨드를 사용해 설정을 변경할 수 있다.

```redis
> CONFIG SET timeout 600
OK
```

- 타임아웃 파라미터를 설정하면 클라이언트 소프트웨어의 버그로 인해 레디스에 유휴 연결이 쌓여서 서비스 장애가 발생하는 상황을 방지할 수 있다.
  - 이 설정은 pub/sub 클라이언트에는 영향을 주지 않는다.
- 기본적으로 타임아웃의 설정이 0으로 돼 있기 때문에 유휴 연결이 있더라도 강제로 클라이언트 연결을 해제하지 않는다.
- `tcp-keepalive`는 연결된 클라이언트에게 주기적으로 TCP ACK를 보내고, 클라이언트로부터 응답이 없는 경우에 연결을 끊는 설정이다.
  - 타임아웃과 달리 클라이언트가 활동이 없을 때 즉시 연결을 끊지 않고, 실제로 클라이언트가 정상적으로 응답할 수 있는 상태인지를 우선적으로 확인한 다음 응답하지 않을 때에만 연결을 끊는 방식으로 동작한다.
- `timeout`과 유사하게 클라이언트의 이상 동작을 감지할 수 있으며, 정기적으로 TCP ACK를 보내면 레디스 서버와 클라이언트 사이의 네트워크 장비에서 이 연결이 계속 유지되고 있음을 확인할 수 있다.
  - 이를 통해 네트워크 장비로 인한 예기치 않은 연결 종료를 방지하고, 네트워크 문제를 조기에 감지할 수 있다.
  - 버전 3.2.0부터 기본적으로 이 값이 300초로 설정되어 있어서, 서버는 연결된 클라이언트에게 5분마다 한 번씩 TCP ACK를 보낸다.

---

## 파이프 라이닝

- 레디스 서버와 클라이언트는 네트워크를 통해 연결돼 있으며, 요청과 응답 사이의 `왕복 시간 RTT, Round Trip Time`은 성능에 큰 영향을 끼친다.
  - 네트워크 통신 시간만 줄여도 성능을 크게 향상시킬 수 있다.
- 파이프라이닝은 클라이언트가 연속적으로 여러 개의 커맨드를 레디스 서버에 보낼 수 있도록 하는 기능이다.
  - 일반적으로 하나의 커맨드를 보내고, 서버에서 그 커맨드를 처리한 결과를 받은 후에 다음 커맨드를 보내는 방식으로 동작.
  - 파이프라이닝을 사용하면 한 번에 여러 개의 커맨드를 일괄적으로 처리할 수 있는 방식으로 동작 => 응답 속도를 줄이고 처리량을 늘릴 수 있다.
- 커맨드를 통한 파이프라이닝

```shell
$ (printf "PING\r\nPING\r\nPING\r\n"; sleep 1) | nc localhost 6379
+PING
+PING
+PING
```

- Java 진영의 경우 `RedisTemplate`의 `executePipelined` 메소드를 이용해 Pipeline을 시작할 수 있다.

```java
redisTemplate.executePipelined((RedistCallback<Object>) connection -> {
  // ...  
})
```

- 파이프라인을 효과적으로 활용하면 네트워크 I/O를 최소화하여 상당한 성능 향상을 이룰 수 있다.
- 하지만 주의할 점이 있다.
  - 한 번에 너무 많은 쿼리를 파이프라인을 이용해 레디스에 보내게 되면 네트워크 대역폭 한계로 인해 속도가 저하될 수 있으며, 레디스의 클라이언트 쿼리 버퍼 제한에 걸려 오류가 발생할 수도 있다. 
  - 그러므로 명령을 일정한 개수로 나눠 `배치 batch` 형태로 서버에 보내는 것이 좋다. 
- 배치 사이즈는 충분한 테스트를 통해 결정하는 것이 좋다.
  - 한 번에 너무 많은 커맨드를 처리하면 네트워크 대역폭을 너무 많이 차지하거나, 레디스의 CPU 부하나 클라이언트 버퍼로 인한 메모리 증가로 인해 성능 문제가 발생할 수 있다.
- 레디스는 파이프라인으로 들어온 명령을 처리할 때 하나의 파이프라인에 속하더라도 원자성을 보장하지 않는다.
  - 파이프라인은 여러 개의 커맨드를 동시에 보낼 수 있는 방법을 제공하며, 파이프라이닝을 통해 커맨드를 실행할 때 다른 클라이언트의 접근을 차단하지 않고 파이프라인 내부의 각 커맨드만이 원자적으로 수행된다.
- 파이프라이닝을 이용한 연결은 원자적이지 않으며 트랜잭션의 개념이 아니기 때문에 하나의 파이프라인 내에 속한 여러 커맨드 중 일부에 오류가 발생하더라도 전체적인 커맨드가 롤백되지 않는다.
  - 대신, 오류를 발생시킨 커맨드만 수행되지 않으며 그 외의 커맨드는 정상적으로 수행된다.

---

## 클라이언트 사이드 캐싱

- 레디스 버전 6부터 클라이언트 사이드에서 캐싱을 할 수 있는 기능이 추가됐다.
- 데이터베이스 성능도 최적화했고, 레디스 같이 빠른 캐시를 사용하고 있음에도 만족할 만한 성능이 나오지 않는다면 클라이언트 사이드 캐시의 도입을 고려해볼 수 있다.
- 클라이언트 측에서의 캐시? => 네트워크 I/O. 즉 왕복 시간을 줄일 수 있는 최고의 방법
  - 레디스에 접근하지 않고도 데이터를 반환하기 때문에 레디스 서버의 부하도 줄일 수 있다.
- 하지만 대부분의 캐싱 패턴이 가지는 문제와 마찬가지로, 데이터의 정합성 즉 업데이트된 데이터를 처리하는 방법을 고려해야 한다.
  - 레디스의 클라이언트 사이드 캐싱에서 이를 처리하는 방법을 트래킹이라 부른다.
- 기본 모드에서는 레디스 서버가 클라이언트가 액세스한 키를 기억해서, 동일한 키가 수정될 때 무효 메시지를 전송한다.
  - 레디스의 서버에서 이를 기억해야 하기 때문에 메모리 비용이 들지만 정확하게 클라이언트가 갖고 있는 키에 대해서만 무효한 메시지를 보낼 수 있다는 장점이 있다.
- 브로드캐스팅 모드에서는 레디스 서버가 모든 키에 대한 액세스를 기억하려고 시도하지 않으며, 특정 프리픽스에 대해 접근한 클라이언트만 기억하기 때문에 사용하는 메모리가 적다!
  - 대신 클라이언트는 특정 프리픽스를 가진 키를 기억해야 하며, 자신이 소유하지 않은 키라 하더라도 해당 프리픽스와 일치하는 키가 변경될 때마다 변경 메시지를 수신하는 단점이 존재한다. => CPU 자원 소비
- 클라이언트 사이드 캐싱은 자주 요청되지만 매우 드물게 변경되는 키를 대상으로 하는 것이 좋다.

---

# 참고자료

- 개발자를 위한 레디스, 김가람 지음

