# 13장 레디스 운영하기

## 프로메테우스

.. 생략 ..

----

## 레디스 버전 업그레이드

- `EOL(End Of Life)`가 상당히 짧은 편.
  - 보안 취약점을 방지하기 위해 최소한 `EOL`되지 않은 버전의 레디스를 사용할 수 있도록 주기적으로 버전을 업그레이드하는 것이 좋다.
- 운영 중인 레디스를 업그레이드하는 방법!
1. 업그레이드할 버전의 레디스 인스턴스를 새로운 서버에 설치한 뒤, 기존 버전의 레디스의 데이터를 복제하는 방식.
   - 운영 중인 레디스로의 접속 정보를 변경해야 한다. 하지만 접속 정보를 변경하는 것 외에는 다운타임이 존재하지 않는다는 장점이 존재한다.
2. 실행 중인 레디스 인스턴스를 중지한 다음, 신규 버전의 레디스 소스 파일로 재실행하는 방식.
   - 접속 정보를 변경하지 않아도 된다는 장점이 있지만, 싱글 구성의 레디스였다면 다운타임이 발생한다는 점을 고려해야 한다.

- 보통 센티널 혹은 클러스터 구조의 고가용성 구성으로 이뤄진 인스턴스라면 복제본부터 하나씩 업그레이드해나가면서 전체 레디스의 버전을 업그레이드할 수 있지만, 싱글 혹은 센티널을 사용하지 않는 복제 구성이라면 다운타임이 발생되거나 접속 정보를 변경해야 하기 때문에 상황에 맞는 방법을 선택해야 한다.
- 현재 운영 중인 버전은 아래와 같이 확인 가능!

```shell
$ bin/redis-server -version
Redis server v=7.2.5 sha=00000000:0 malloc=jemalloc-5.3.0 bits=64 build=3cb957b67cc84a8c
```

### 센티널 구성의 레디스 버전 업글에ㅣ드

- 센티널 구성에서는 다음과 같은 방법으로 다운타임 없이 전체 인스턴스를 업그레이드할 수 있다.

1. 신규 버전의 레디스 바이너리 파일 다운로드
2. 3대의 센티널 인스턴스 모두 중단
3. 신규 버전 폴더에 기존의 `sentinel.conf` 복사
4. 신규 바이너리 파일을 이용해 3대의 센티널 인스턴스 시작
5. 복제본 인스턴스 중단
6. 신규 버전 폴더에 기존의 `redis.conf` 복사
7. 신규 바이너리 파일을 이용해 복제본 인스턴스 시작
8. 센티널에서 수동 페일오버 수행
9. 기존 마스터 인스턴스 중단
10. 신규 버전 폴더에 기존의 `redis.conf` 복사
11. 신규 바이너리 파일을 이용해 기존 마스터 인스턴스 시작
12. 센티널에서 수동 페일오버 수행(페일백)

> #### 그런데 여기서! 만약 컨테이너 환경이며 어떻게 해야 하지...?
> - 모르겠다..

### 클러스터 구성의 레디스 버전 업그레이드

- 클러스터 구성이라면 센티널보다 더 간단하게 버전을 업그레이드할 수 있다.
- 센티널 인스턴스에 대한 고려 없이 레디스 인스턴스에 대한 업그레이드만 진행하면 된다.
- 복제본을 먼저 버전 업그레이드하고, 각각을 페일오버해 기존의 마스터 노드를 업그레이드하면 된다.

---

## 레디스 운영 가이드

- 운영 중 마주할 수 있는 장애와 성능 저하 요소
  - 설정값으로 인한 장애
  - 운영 시 잘못된 방법으로 레디스 레디스를 사용

### 장애 또는 성능 저하를 유발할 수 있는 레디스의 설정 항목

#### maxmemory-policy

- 기본 설정값인 `noeviction`은 서비스 장애로 이어질 수 있다! 
- `allkeys-lru`로 설정할 것을 권장

#### stop-writes-on-bgsave-error

- 스냅샷이 정상적으로 저장되지 않았을 때 레디스로의 모든 쓰기 작업을 중지하는 역할을 한다.
  - 최신 백업이 실패한 것을 인지하고 서버에 문제가 있음을 알려줘 큰 장애를 방지할 수 있다.
- 그러나 레디스 서버에 이미 다른 모니터링 기능이 활성화돼 있어 디스크 문제가 발생해도 이를 신속하게 감지할 수 있으며, 레디스의 쓰기 작업은 중단하지 않고 계속되기를 원한다면 이 설정을 비활성화하는 것이 좋다.
- 기본 설정값은 `yes`. `no`로 변경하면 백업 파일 생성 실패 시에도 레디스로의 쓰기 작업이 계속 수행될 수 있다.

#### 자동 백업 옵션

- 백그라운드에서 백업이 실행되면 `COW` 방식으로 작동하기 때문에 메모리 사용량이 최대 `maxmemory`의 두 배까지 증가할 수 있다.
  - OOM 주의
- 대규모 트래픽의 경우 RDB 파일 백업 빈도를 줄일 필요가 있다.

<br/>

### 레디스 운영 및 성능 최적화

#### 오래 걸리는 커맨드 사용

- 클라이언트의 모든 요청은 이벤트 루프를 이용해서 순차적으로 실행되는 특징을 갖고 있다. (싱글 스레드)
- `KEYS`나 `FLUSHALL`과 같이 한 번에 여러 키에 접근하는 커맨드의 수행 시간만 오래 걸린다고 생각할 수 있지만, set, list, hash와 같이 하나의 자료 구조 안에 여러 개의 아이템을 가지고 있는 경우, 해당 자료 구조에 대한 커맨드도 아이템의 개수에 비례해 실행 시간이 증가하는 방식으로 동작한다.
  - 지연 시간이 크게 증가할 수 있다.
- O(N) 이상의 시간 복잡도를 갖는 커맨드를 알아보자.

#### 키스페이스 커맨드

- 여기서 N은 전체 키의 개수

##### KEYS

- 모든 키에 한 번씩 접근
- `SCAN` 커맨드로 대체하는 것이 좋다.

##### FLUSHALL

- 옵션 없이 사용하면 `SYNC` 방식으로 동작. 
- 모든 키를 삭제한 뒤 OK를 반환
- `ASYNC`로 동작하게 만들 수 있다. 백그라운드에서 실행되므로 블락이 발생하지 않고, `FLUSHALL` 실행 중에 새로 생선된 키는 삭제되지 않는다.

##### FLUSHDB

- 옵션 없이 실행하면 `SYNC` 방식으로 동작. 
- - `ASYNC`로 동작하게 만들 수 있다. 백그라운드에서 실행되므로 블락이 발생하지 않고, `FLUSHDB` 실행 중에 새로 생선된 키는 삭제되지 않는다.

#### 자료 구조 공통 커맨드

- 여기서 N은 자료 구조 내부의 아이템 개수

##### DEL

- string key를 삭제하면 O(1)의 시간 복잡도를 갖지만, list나 set, sorted set, hash와 같은 자료 구조를 삭제할 경우에는 자료 구조 내의 아이템 개수에 따라 선형적으로 시간이 증가하는 O(N)을 갖는다.
- DEL 커맨드는 foreground 방식으로 삭제하기 때문이며, 너무 많아서 백그라운드 방식을 사용하고 싶다면 `UNLINK` 커맨드를 사용하는 것이 좋다.

##### SORT / SORT_RO

- list, set, sorted set에서만 사용할 수 있는 커맨드. 키 내부의 아이템을 정렬해 반환.
- `LIMIT` 옵션을 사용하면 일부 데이터만 조회할 수 있으며, `ASC/DESC` 옵션을 사용하면 정렬 순서를 변경할 수 있다.
  - 정렬할 대상이 문자열일 경우 `ALPHA` 옵션을 사용하면 데이터를 사전 순으로 정렬해 조회할 수 있다.
- `SORT` 커맨드: O(N + M log(M)). N은 내부의 아이템 수. M은 반환되는 아이템 수.
  - `LIMIT`으로 오프셋 지정 가능
- `SORT_RO` 커맨드: `SORT`와 동일하게 동작. `SORT`에 있는 `STORE` 옵션 사용 불가.
  - `SORT`는 `STORE` 때문에 쓰기가 가능한 커맨드로 분류 -> 복제본에서 사용 불가.
  - 버전 7.0에 읽기 전용으로 사용하기 위한 `SORT_RO`가 나온 것!

#### set 관련 커맨드

- 카디널리티에 비례해 수행시간 증가

##### SDIFF / SDIFFSTORE

- 차집합 수행. O(N).

##### SUNION / SUNIONSTORE

- 합집합 수행. O(N).

##### SINTER / SINTERSTORE / SINTERCARD

- 교집합 수행. O(N*M). N은 가장 작은 집합의 카디널리티. M은 연산을 수행하는 집합의 수.
- `SINTERCARD`는 교집합 연산으로 얻어진 집합의 카디널리티만 반환.
  - `LIMIT` 옵션 사용 가능

#### list 관련 커맨드

- 특정 인덱스에 접근할 때까지의 아이템 수에 비례해 수행 시간 증가.

##### LINDEX

- 인덱스 위치에 있는 아이템을 리턴. O(N).

##### LINSERT

- `BEFORE`와 `AFTER`라는 `피봇 pivot` 값을 필수 인자로 입력. 해당 피봇 값의 이전 또는 이후에 신규 아이템을 입력하도록 동작. 
- O(N).

##### LSET

- 특정 인덱스의 신규 입력한 문자열로 변경. O(N)

##### LPOS

- 6.0.6 버전에 신규 추가
- 문자열을 인자로 받아, list를 순회하며 문자열이 있는지 확인하고, 해당 아이템의 인덱스를 리턴. O(N)

#### hash 관련 커맨드

##### HGETALL

- 모든 아이템 반환. O(N)

##### HKEYS

- 모든 키 반환. O(N).

##### HVALS

- 모든 아이템의 값 반환. O(N).

#### sorted set 관련 커맨드

- 자동으로 정렬되므로 기본적으로 O(log(N))의 시간 복잡도를 갖는다.
  - 덕분에 아이템 수가 증가해도 실행 시간이 빠르게 증가하지 않는다.
- 하지만 집합 연산을 할 때는 set과 마찬가지로 아이템 개수에 비례해 수행 시간이 증가한다.

##### ZDIFF / ZDIFFSTORE

- 차집합 수행. O(L+(N-K)log(N)).
  - L: 모든 집합의 총 아이템 개수
  - N: 첫 번째 set의 크기
  - K: 결과 set의 크기

##### ZUNION / ZUNIONSTORE

- 합집합 수행. O(N) + O(M*log(M))
  - N: 모든 집합의 총 아이템 수
  - M: 결과 집합의 아이템 수

##### ZINTER / ZINTERSTORE / ZINTERCARD

- 교집합 수행. O(N*K) + O(M*log(M)).
  - N: 가장 작은 집합의 카디널리티.
  - K: 연산을 수행하는 집합의 수
  - M: 결과 집합의 카디널리티.

<br/>

### 레디스에서의 트랜잭션 사용과 주의 사항

- 레디스에서도 트랜잭션을 사용할 수 있다.
  - 싱글 스레드로 동작하기에 주의해야 한다.
  - 2가지 방식으로 사용 가능

#### 1. MULTI / EXEC

- `MULTI`: 트랜잭션 시작.
- `EXEC`: 커맨드를 원자적으로 실행하고, 트랜잭션이 성공하면 결과를 반환.
  - <s>트랜잭션 도중 오류가 발생하면 트랜잭션 내의 모든 커맨드를 롤백(????)하고 트랜잭션을 종료.</s>

> #### 잠깐만..?
> - Redis의 트랜잭션에서는 롤백을 지원하지 않는다고 했는데...? 뭐지..?
> - 공식문서에는 아래와 같이 서술

> #### What about rollbacks?
> Redis does not support rollbacks of transactions since supporting rollbacks would have a significant impact on the simplicity and performance of Redis.


#### 2. 루아 스크립트

- 데이터 조작 및 계산과 같은 작업을 위임.
- 루아 스크립트는 레디스 내에서 원자적으로 실행되므로 여러 명령을 한 번에 실행하고, 중간에 다른 클라이언트 요청을 수용하지 않아 데이터 일관성을 유지할 수 있다.
- 트랜잭션과 비슷한 원자성을 갖지만, 트랜잭션과 달리 일부 명령어가 실패하더라도 다음 명령어로 진행되며 롤백이 발생하지 않는 특징이 있다.

#### 트랜잭션과 루아 스크립트를 사용할 때 주의점

- 트랜잭션과 루아 스크립트를 사용하는 도중에 다른 클라이언트의 커맨드는 모두 대기하게 되므로, 트랜잭션의 길이가 길어지지 않도록 각별한 주의가 필요하다.
- 트랜잭션이나 루아 스크립트 내부에서는 블로킹 커맨드(`BLPOP`, `BRPOP`)를 사용할 수 없도록 강제하고 있는데, 트랜잭션 내부에서 블로킹될 경우 레디스는 무한 대기 상태에 빠질 수 있기 때문이다.


<br/>

### has-get / has-del 패턴

- 레디스에서 데이터 조회 또는 삭제 시 `EXISTS` 커맨드를 사용해 데이터 존재 여부를 확인한 뒤 처리하는 `has-get` 및 `has-del` 패턴은 지양하는 것이 좋다.
  - 부하를 증가시키며, 성능 저하의 원인!
- 레디스에서는 `GET`과 같은 조회 커맨드에서 키가 존재하지 않으면 `nil` 값을 반환하고, `DEL` 커맨드는 키가 없어도 에러를 반환하지 않으며 아무런 문제 없이 동작한다.
  - 대규모 트래픽 환경에서는 1초의 차이도 누적되어 중요한 영향을 미친다.

<br/>

### 클라이언트 출력 버퍼 사이즈

- `클라이언트 출력 버퍼 client output buffer`는 클라이언트가 서버로부텅 응답을 받을 때 이를 일시적으로 저장하는 역할을 한다.
- 많은 클라이언트의 요청을 처리해야 한다면 출력 버퍼의 크기를 늘리는 것이 좋다.
- 특히, 복제를 사용하는 경우에는 출력 버퍼의 크기를 늘리는 것이 필수적! -> 큰 데이터를 복제할 때 기본값으로 설정된 출력 버퍼 크기가 부족할 수 있기 때문!

```
client-output-buffer-limit <클래스> <hard limit> <soft limit> <soft seconds>
```

- redis.conf 파일에서 아래와 같이 설정 구성 가능

```
client-output-buffer-limit normal 0 0 0 
client-output-buffer-limit replica 256mb 64mb 0
client-output-buffer-limit pubsub 32mb 8mb 0
```

- 0으로 설정하면 제한이 비활성화 되어 제한 없이 데이터가 수신 가능함을 뜻한다.

<br/>

### 특정 프리픽스를 가진 키 삭제하기

- 제공 X. 하지만 일반적으로 특정한 프리픽스를 사용해 키를 구분하는 경우가 많으며, 때로는 특정 프리픽스를 가진 키를 일괄적으로 삭제해야 할 상황이 발생하기도 한다.
- 프리픽스를 가진 키를 한 번에 삭제할 수 없기 때문에 다음과 같은 방법을 사용할 수 있다.
1. `SCAN` 명령어를 통해 특정 프리픽스를 가진 키를 검색
2. 검색된 키를 삭제

- 루아 스크립트를 사용하면 네트워크 I/O를 줄이면서 같은 작업을 효율적으로 수행할 수 있다.

<br/>

### 레디스 모니터링

#### 슬로우 로그

- `슬로우 로그 Slow Log`는 실행 속도가 느린 커맨드를 기록하는 로그다.
- `redis-cli`에서는 `SLOWLOG GET` 커맨드를 이용해서 슬로우 로그를 확인할 수 있다.
- `slowlog-log-slower-than`은 10,000으로 설정되어 있는데, 10,000ms를 의미한다.
  - 10초 이상 수행되는 커맨드를 슬로우 로그에 기록한다는 의미!
- `slowlog-max-len`은 슬로우 로그에 유지되는 레코드의 개수를 제한한다.
  - 기본값은 128.
  - 오래된 레코드는 새로운 레코드로 대체된다.

#### 그래프 지표

- CPU, 메모리 및 네트워크와 같은 중요한 컴퓨팅 자원을 얼마나 쓰고 있는지 확인하는 것이 중요.

##### CPU

- 백업 파일 저장 및 `UNLINK`와 같은 백그라운드 작업 시에서는 다른 CPU를 활용할 수 있다.
  - 따라서 CPU 사용량을 모니터링하는 것이 중요.

##### 메모리

- `used_memory`: 현재 할당한 메모리.
- 현재 메모리 사용량 `ByteUsedForCache`와 `maxmemory`의 백분율을 계산하는 `DatabaseMemoryUsagePercentage`와 같은 메트릭을 활용할 수 있다.
- `DatabaseMemoryUsagePercentage`가 100%에 도달하면 레디스의 `maxmemory` 정책이 작동하며, 설정된 정책에 따라 이빅션 작업이 발생할 수 있다.
- `used_memory_rss`: 운영체제가 레디스 프로세스에 할당한 실제 물리적인 메모리 양.
- 레디스에서는 메모리 단편화를 관리하기 위해 `active defragmentation` 기능을 활성화할 수 있다. (버전 4.0 이상)
  - 기본적으로 비활성화. 단편화가 심한 경우에만 아래와 같이 활성화. (단편화 문제가 없다면 굳이 활성화할 필요 X)

```redis
> CONFIG SET activedefrag yes
```

##### 네트워크

- 트래픽 양이 예상치를 초과하지 않는지 확인.
- 가상 머신, 도커, 쿠버네티스 등의 환경에서 레디스를 사용하는 경우, 레디스가 실행되는 노드의 네트워크 처리 대역폭 한계에 도달하면 레디스 성능에 영향을 끼칠 수 있다.
  - 네트워크 모니터링을 통해 네트워크 지표가 어느 정도로 상승하는지 확인하는 것이 중요.

##### 커넥션

- 클라이언트 연결 추이 모니터링.
- 갑작스럽게 활성 연결 수가 증가한다면, 애플리케이션 문제를 의심! (연결이 올바르게 종료되고 있는지 등!)
  - `tcp-keepalive` 설정을 활용하면 이러한 유휴 연결로 인한 문제를 예방할 수 있다.

##### 복제

- 마스터 노드는 복제본이 하나 이상 있는 경우 지속적으로 데이터 명령 스트림을 전송한다.
- 복제 구성의 경우 복제 지연이 발생하는지 확인하는 것이 중요!
  - 복제 지연의 급증은 마스터 노드의 속도를 복제본이 따라가지 못하는 것을 의미
  - 전체 동기화를 유발하여 스냅샷을 생성해야 하고 이는 레디스의 성능 저하로 이어짐.

---


# 참고자료

- 개발자를 위한 레디스, 김가람 지음

