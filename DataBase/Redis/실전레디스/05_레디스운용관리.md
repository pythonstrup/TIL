# Chapter 05 레디스 운용 관리

## 1. 데이터 영속성

- 레디스는 인메모리 데이터베이스의 특성상 기본적으로 모든 데이터를 메모리에서 처리하기 때문에 서버가 재시작되면 데이터가 유실될 수 있다.
  - 단순한 캐시 서버로 사용한다면 아키텍처나 성능에 영향. but 대부분의 경우 데이터 휘발성과 관련된 문제는 없다.
- 현업에서는 레디스를 캐시 서버가 아닌 데이터 저장소처럼 데이터 영속성을 전제로 운용하는 경우가 있다.
  - 영속성 관련 기능을 모두 활성화하는 것은 권장하지 않는다.
  - 성능과 내구성의 타협점을 찾고 그에 맞춰 설정해야 한다.
  - 트레이드오프를 고려하여 적절한 영속성 전략을 짜는 것이 중요!
- RDB(스냅샷)은 아래 조건이 기본값
  - 1시간 이내에 하나 이상의 키가 저장
  - 5분 내에 최소 100개 이상의 키가 변경
  - 1분 내에 최소 10,000개 이상의 키가 변경
- AOF는 모든 데이터 차례대로 기록

### 1-1. RDB

- 자동 혹은 수동 저장
  - 수동으로 저장할 때 `SAVE`(동기 방식) 혹은 `BGSAVE`(비동기 방식 - 백그라운드 실행) 명령어 사용
- `BGSAVE` 명령어는 백그라운드에서 아래와 같은 처리를 수행한다.
1. 요청을 처리 중인 프로세스에서 RDB 파일을 덤프하기 위한 자식 프로세스를 `포크 fork` 처리하여 생성합니다.
2. 자식 프로세스는 데이터 세트 전체를 임시 RDB 파일로 덤프
3. 덤프 처리가 완료되면 설정된 RDB 파일 이름으로 변경한다.

- `BGSAVE`는 요청을 처리하는 스레드와는 별도로 스냅샷을 생성하기 때문에 요청 처리에 미치는 영향을 줄일 수 있다.
- RDB 파일을 덤프하기 위한 자식 프로세스를 생성할 때는 `CoW(Copy on Write)`의 매커니즘을 사용하여 메모리를 확보한다.
  - 따라서 부모 프로세스 및 자식 프로세스에 쓰기 작업을 수행할 때 내용 차이가 발생하는 경우에는 그 차이만큼 메모리 영역을 추가로 사용하게 된다.
- `BGSAVE` 명령어처럼 RDB를 생성하여 백업하는 방식은 포크로 처리할 때 성능에 영향을 줄 수 있다. 아래 사항을 확인하자.
1. 스냅샷을 사용하기 위한 메모리가 충분한지 확인
2. 문제없이 레플리카에서 스냅샷을 가져올 수 있는지 확인
3. 서비스에 지장이 없는 시간에 스냅샷을 생성하는지 확인

- 생성한 파일을 cron 작업이나 `system.timer`를 통해 복원하기 위해 정기적으로 S3 등에 저장하는 운영 방식도 있다.
  - 복원을 위해 지정한 디렉터리에 RDB 파일을 배치하여 실행한다.
- 튜닝도 가능
  - LZF 압축: 크기를 줄이지만, CPU 사용량 증가.
  - CRC64 체크섬 사용: 파일 손상 확인. 대신 RDB 파일 저장하고 읽을 때 10% 정도 성능 저하.
- 스냅샷 저장 처리에 실패하게 되면, 레디스는 기본적으로 쓰기 작업 요청을 수락하지 않는다.
  - 데이터 손실의 가능성 -> 영속성을 위해 관리자에게 알리려고 하기 때문.
  - 영구 저장 처리를 모니터링할 수 있다면 해당 기능을 비활성화하고 생성이 실패해도 쓰기 요청을 수락하게 할 수 있다. (`stop-writes-on-bgsave-error`로 설정)
- 4MB의 데이터가 생성될 때마다 `fsync`를 수행할 수 있다.
  - 파일에서 디스크로 데이터 커밋을 단계적으로 진행 -> 지연 줄이기.
  - `rdb-save-incremental-fsync` 매개변수로 제어

### 1-2. AOF

- 계속 기록하는 특성 덕분에 내구성이 높다.
  - 대신 RDB 파일보다 크기가 커지는 경향이 있음.
  - 그리고 메모리 복구 시간이 오래 걸림.
- 레디스 서버는 요청받은 명령어를 파일에 기록하기 위해서 우선 파일을 버퍼에 유지하는데, 이 버퍼를 AOF 버퍼라 한다.
  - 이후 레디스 혹은 운영체제가 버퍼에 있는 데이터를 플러시 하여 디스크 내의 파일에 영구적으로 저장한다.
- AOF는 자동 생성만 가능.
  - 기본적으로 활성화 X
  - 활성화하기 위해 `appendonly` 지시자 지정.
- `appendfsync` 지시자는 자동생성 시점을 정할 수 있다.
  - `always`
  - `everysec`
  - `no`
- 대량의 입출력 중에는 요청을 처리하는 프로세스에서 호출되지 않도록 운영체제에서 `no-appendfsync-on-rewrite` 지시자로 제어.
  - 이때 백그라운드에서 스냅샷 생성이나 AOF 재작성 처리 중에는 `appendfsync` 지시자의 값이 `no` 상태가 된다.
  - 지연 시간 같은 문제가 특별히 없다면 데이터 손실의 내구성 관점에서 이 기능을 비활성화하는 것이 좋다.
- 파일 크기가 커지만 자동으로 AOF 재작성을 위해 `BGREWRITEAOF` 명령어 처리가 수행된다.
  - 이미 삭제되거나 만료된 키, 같은 키에 여러 작업을 하는 경우 등을 통합하여 파일 크기를 줄이는 작업 수행
  - AOF 재작성은 파일 변경을 감지하여 실행. 시작 시 파일 크기 혹은 이전 파일 크기와 현재 파일 크기 비교 -> 설정값을 초과하면 재작성
  - 또한 최소값을 설정해 파일이 너무 작아도 재작성 안 하게 할 수 있다. (for 성능)
  - `auto-aof-rewrite-percentage`: 트리거 비율
  - `auto-aof-rewrite-min-size`: 파일 최소 크기

#### AOF 메커니즘

- 7.0 이후 멀티파트 AOF 기능 도입. (Hybrid AOF)
  - 데이터 세트 전체를 보유하는 기본 파일과 이후에 추가된 부분을 보유하는 추가 파일로 분할. 
  - 재작성을 처리할 때 메모리 소비나 디스크의 입출력이 많아지는 문제 개선.
- 하지만 백업 시 AOF 재작성을 일시적으로 비활성화하지 않으면 파일이 망가질 수 있다. 따라서 AOF 재작성이 실행되고 있지 않은지를 확인한 후에 AOF 파일을 복사해야 한다.
- `auto-aof-rewrite-percentage` 지시자의 값을 0으로 설정하여 AOF 재작성을 비활성화한다. 그 이후 `INFO persistence` 명령을 실행하여 `aof-rewrite-in-progress`의 값이 1이면 0이 될 때까지 AOF 재작성 처리가 완료될 때까지 대기

### 1-3. 스냅샷과 AOF 비교

- 오픈소스 레디스는 기본적으로 스냅샷/AOF 혼합 형식이 활성화되어 있다.
- 레디스는 먼저 AOF 파일의 첫 다섯 글자를 확인한다. `REDIS`라는 문자열로 시작하는 경우 AOF 파일은 혼합 형식으로 간주한다.
  - 그러면 레디스 서버는 먼저 스냅샷을 읽고, 그다음에 AOF를 읽는다.
  - 이 동작을 통해 데이터 손실 위험을 최소화하면서도 레디스 재시작 시간을 단축한다.
- AOF를 활성화하지 않은 경우 AOF 파일에 명령이 추가되지 않으며, 혼합 형식으로도 설정할 수 없다.
- `aof-use-rdb-preamble` 지시자로 설정할 수 있으며, 기본적으로 활성화되어 있다.
- 기본적으로 스냅샷을 정기적으로 생성하는 것을 추천.

### 1-4. 데이터 삭제 패턴

- 레디스는 데이터 영속화 기능이 있지만, 데이터가 메모리에만 저장된 상태에서는 예기치 않게 데이터가 삭제될 가능성이 있다.
  - 원인 특정이 필요. 의도하지 않은 조작이나 장애 때문일 수 있다.
- 데이터가 손실될 수 있는 몇 가지 상황
  - 엔진 재시작
  - 레디스 서버 전체 장애
  - 명령어 실행
    - `DEL` / `HDEL` / `XDEL`
    - `FLUSHALL` / `FLUSHDB`
    - `UNLINK`
  - TTL 만료
    - `EXPIRE` / `EXPIREAT` / `PEXPIRE` / `PEXPIREAT`
    - `SET` 명령어 `EX` 옵션
  - 강제 제거
  - 비동기 레플리케이션
  - 레디스 클러스터의 네트워크 단절
  - 기타
    - 키 이름 재설정
    - 잘못된 데이터베이스 선택
    - 데이터가 아예 삽입되지 않은 경우

----

## 2. 캐시 서버로서 레디스 아키텍처

- 최소한! `지연 로딩 Lazy Loading/Cache-Aside` 패턴과 Write-Through 패턴을 숙지하고 있어야 한다.

### 2-1. 읽기 관점의 아키텍처

#### 지연 로딩 패턴(= Look Aside = Cache Aside)

- 원본 데이터는 MySQL과 같은 RDBMS에 저장하고, 레디스는 그 앞단에 배치하는 형태로 사용한다. 애플리케이션은 다음과 같은 흐름으로 처리한다.

1. 애플리케이션이 레디스에 데이터를 요청한다.
2. 요청된 데이터가 레디스 서버에 존재하는지, 유효 기간 내인지에 따라 처리 내용을 분기한다.
   1. 요청된 데이터가 레디스 서버에 존재하고 유효 기간 내에 있는 경우라면 레디스에서 애플리케이션으로 응답한다.
   2. 요청된 데이터가 레디스 서버에 존재하지 않거나, 존재하더라도 유효 기간이 지난 경우라면 다음과 같이 응답한다.
      1. 애플리케이션은 데이터베이스에서 데이터를 가져온다.
      2. 애플리케이션은 가져온 데이터를 레디스의 캐시에 업데이트한다.

<img src="img/cache_strategy01.png">

- 장점
  - 캐시 노드 장애 시 다운타임을 줄일 수 있으며, 백엔드로의 데이터 접근에 수반되는 지연 시간의 영향을 최소화할 수 있다.
  - 요청된 데이터만 캐시에 저장하므로, 사용하지 않는 데이터를 캐시로 사용하는 공간이 작다.
- 단점
  - 가져온 데이터가 오래되었을 수 있다.
  - 캐시 미스 시 오버헤드가 크다.

#### Read-Through 패턴

- 지연 읽기 패턴의 변형과 같은 아키텍처
- 레디스에 데이터를 요청하고 캐시 미스가 발생했을 때 데이터베이스에서 캐시로 데이터를 읽어오는 방식을 사용.
- 지연 읽기 패턴과 가장 큰 차이점은 데이터베이스에서 데이터를 읽어오는 작업을 애플리케이션에서 직접 처리할 필요가 없다는 점이다.
  - 대신 라이브러리 등을 사용하여 데이터베이스에서 레디스로 데이터를 읽어오는 과정을 처리해야 한다.
- 레디스 내장 기능으로는 제공되지 않으므로, 서드파티 소프트웨어나 모듈 등을 통해 이러한 기능이 가능한지 확인할 필요가 있다.

<br/>

### 2-2. 쓰기 관점 아키텍처

#### Write-Through 패턴

- 아래와 같은 흐름으로 처리된다.

1. 애플리케이션은 데이터베이스에 데이터를 저장한다.
2. 애플리케이션은 1번과 같은 데이터를 레디스 서버에도 저장한다.

<img src="img/cache_strategy02.png">

- 장점
  - 레디스 서버 내의 캐시 데이터가 항상 최신 상태를 유지
  - 읽기 작업 시 오버헤드 적다.
- 단점
  - 사용하지 않는 캐시 데이터 생성 가능성이 있다.
  - 쓰기 작업 시 데이터베이스와 캐시에 모두 쓰기를 해야 하므로 오버헤드가 크다.

- 쓰기 작업 때 지연 시간이 다소 증가해도 괜찮은 경우에 효과적인 방법이다.
  - 하지만 데이터베이스가 변경될 때마다 레디스 서버에 쓰기 작업을 수행하기 때문에 사용하지 않는 데이터가 레디스에 저장될 수 있다.
- 새로 시작하거나 캐시 노드에 장애가 발생해 새로운 캐시 노드를 추가한 경우에는 캐시에 데이터가 존재하지 않게 된다.
  - 데이터베이스에서 미리 데이터를 가져와 복사해두는 방법(캐시 워밍)을 생각해볼 수 있다.

#### Write-Back

- 캐시에 저장한 후, 일정 시간이 지연되면 데이터베이스를 비동기 방식으로 주기적인 업데이트!
- 데이터베이스가 RDBMS인 경우, 데이터를 영구적으로 저장하는 시점에 정규화하여 테이블에 저장

<img src="img/cache_strategy03.png">

- Look-Aside나 Write-Through 패턴과 같은 아키텍처에서 쓰기/읽기 작업 시 발생하는 오버헤드를 줄일 수 있어 쓰기 작업을 빠르게 처리할 수 있다.
  - 하지만, 레디스에서 장애가 발생하는 경우 데이터 손실의 위험이 있기 때문에 애플리케이션의 특성, 데이터의 특성, 복구 방법 등을 사전에 충분히 검토해야 한다.
  - 성능을 우선하지만, 데이터 손실이 발생하는 상황을 가정해도 큰 문제가 없는 경우에 고려하는 패턴이다.
  - 복구할 때는 사전에 계획적으로 생성한 스냅샷으로 데이터를 복원한다.
- Write-Back의 변형인 `마이그레이션 Migration` 패턴도 있다.
  - ex) 이벤트 등의 이유로 일시적으로 많은 요청이 발생하는 기간에는 레디스에 데이터를 저장. 이벤트 종료 후 등의 특정 시점에는 데이터베이스에 영속화
- 장점
  - 레디스 서버 내의 캐시 데이터가 항상 최신 상태를 유지할 수 있다.
  - 쓰기 작업을 빠르게 처리할 수 있다.
- 단점
  - 데이터 손실 위험이 높다.

#### Write-Around

- 데이터를 직접 데이터베이스에 저장하는 방식
- AWS DMS와 같은 CDC(Change Data Capture) 기능을 사용하여 데이터베이스에서 레디스로 변경 내용을 레플레케이션하고, 레디스에서 직접 데이터를 읽어올 수 있다.

<img src="img/cache_strategy04.png">

- 장점
  - 데이터 손실 위험이 낮다
- 단점
  - 구현 방법과 읽기 관점의 아키텍처에 따라 달라질 수 있다.

<br/>

### 2-3. 아키텍처 안티 패턴

- 캐시 노드의 다운으로 애플리케이션을 사용할 수 없는 경우가 있다.
- 만약 이런 상황이 발생한다면 아키텍처를 제대로 설계했는지 검토할 필요가 있다.
  - 애플리케이션과 데이터의 특성, 요구사항 등을 다시 확인하고, 재시도 처리 등 애플리케이션의 구현이나 아키텍처도 재검토해야 한다.
- 지연 로딩 아키텍처에서 캐시 노드가 다운된 경우에 미치는 영향도 사전에 고려해야 하는 대상이다.
  - 데이터베이스로 동작할 때 지연 시간이 최소화되도록!

<br/>

### 2-4. 데이터 저장소로서의 레디스 아키텍처

- 레디스 고유 기능을 활용해 관계형 데이터베이스에서 구현하기 어려운 요구사항이나 작은 데이터의 빈번한 쓰기 작업이 필요할 경우가 있을 수 있다.
- 이때 레디스를 데이터 저장소로 사용하며, 목적에 따라 관계형 데이터베이스와 병행하여 사용하는 것도 고려해볼 수 있다.
- 대신 아래의 주의사항이 있다.
  - 사용하는 레디스의 기능이 데이터 저장소로서의 요구사항을 충족하는지 확인해야 한다.
  - 문제 발생 시 복구 방법을 확인해야 한다.
  - 다른 관계형 데이터베이스 등과 결합하여 사용할 경우 롤백 발생 시 데이터의 일관성 측면에서 애플리케이션 구현에 문제가 없는지 여부를 고려해야 한다.
  - 레디스의 레플리케이션 기능이나 스냅샷 생성을 사전에 준비해야 한다.
- 레디스의 자료 구조나 기능을 반드시 사용해야 하는 상황을 제외하고는 RDBMS가 적합한 경우가 많다.

----

## 3. 모범 사례

### 3-1 . TTL 설정

- 필요한 기간 이상으로 데이터를 저장하는 것은 좋지 않다.
- 그렇다고 TTL을 너무 짧게 설정하면 DB에 부담을 줄 수 있다.
- `SET` 명령어의 `EX`/`PX` 옵션 또는 `EXAT`/`PXAT` 옵션 등을 사용하면 된다.
- `SET` 명령어를 사용할 수 없다면 `EXPIRE`, `PEXPIRE`, `EXPIREAT`, `PEXPIREAT` 등의 명령어로 TTL을 설정할 수 있다.
- 설정된 TTL을 비활성화하려면 `PERSIST` 명령어를 사용하면 된다.

#### TTL 확인

- 각 데이터베이스 내 키의 TTL 설정 상태는 `INFO Keyspace` 명령어 실행 결과로 확인할 수 있다.

```redis
127.0.0.1:6379> INFO Keyspace
# Keyspace
db0:keys=22,expires=0,avg_ttl=0
```

- 0번 데이터베이스에 22개의 키가 저장되어 있지만, TTL이 설정된 키가 없다는 것을 확인할 수 있따.
- `avg_ttl` 값으로 데이터베이스 내의 평균 TTL을 밀리 초 단위로 확인할 수 있는데, 값이 너무 크게 설정되어 있지는 않은지 등을 확인할 수 있다.
- 캐시 서버는 쓰기 빈도는 낮고 읽기 처리가 중심일 때 가장 효과적이므로 애플리케이션의 쓰기 빈도 비중이 높다면 레디스를 캐시 서버로 사용하는 것이 과연 효과가 있는지 다시 고려해보는 것이 좋다.

### 3-2. 제거 정책 설정

- `maxmemory`와 `maxmemory-policy`
- 캐시 서버를 사용하는 경우 다음과 같은 정책 중에서 선택하는 것을 고려해볼 수 있다.
  - TTL이 설정된 키를 대상으로 하는 `volatile-`로 시작하는 정책을 선택
  - 데이터 저장소로도 사용하는 경우, 모든 키를 대상으로 하는 `allkeys-`로 시작하는 정책을 선택
- LRU, LFU, 랜덤, TTL을 기반으로 한 정책 선택은 애플리케이션과 데이터의 특성을 고려하여 설정해야 한다.

### 3-3. 백업

- 스냅샷(RDB)과 AOF(Append Only File)
- 스냅샷을 생성할 때 중요한 것들
  - 메모리 확보
  - 생성 시점
  - 레플리카로부터 생성하기
- 스냅샷은 요청을 처리하는 스레드로부터 일반 포크 처리를 통해 생성된 새로운 스레드로 RDB 파일이 생성되는 방식으로 만들어진다.
  - 백업 등 데이터 세트 이외의 메모리 할당에는 CoW 방식을 사용한다.
  - 포크 처리로 생성된 스레드는 포크 처리 직후 부모 스레드와 같은 범위의 메모리 영역을 사용한다.
  - 그후 마스터와 레플리카에서 변경이 발생하면 각각 개별적으로 메모리 영역을 준비해서 기존에 공유하던 메모리 영역에서 분리하여 사용한다.
  - 따라서 읽기 작업만 하는 워크로드라면 스냅샷 생성 중에도 메모리 사용량이 크게 증가하지 않지만, 쓰기 작업이 많은 워크로드에서는 최대 두 배 가까이 메모리 소비가 증가할 수 있다.
  - 따라서 레디스를 사용할 때는 데이터 영역에 사용하는 메모리양은 레디스가 사용할 수 있는 메모리양의 50% 정도를 여유로 두는 게 바람직하다.
- 관리형 서비스를 사용하는 경우
  - 데이터 이외의 용도로 사용하는 메모리 영역을 예약할 수 있는 설정. -> 활용 고려
  - `ElasticCache`는 `reserved-memory-percent` (또는 `reserved-memory`) 지시자를 제공한다.
  - `ElasticCache`에서는 일반적으로 메모리가 부족할 때 포크 처리 없이 스냅샷을 생성하는 기능을 제공한다.
  - 이 기능을 사용하면 포크 작업 중 쓰기 작업이 많아질 때 발생하는 문제들(CoW로 인한 메모리 사용량 증가, OOM 등)을 예방할 수 있다.
  - CoW로 메모리 사용이 증가해도 두 배까지 증가하지는 않으니 25% 정도의 메모리만 확보해도 충분하다.
- 레플리카에서 스냅샷 생성
  - 포크 처리하여 새로운 스레드에서 RDB 생성.
  - 포크 작업 자체 및 환경에 영향을 받아 처리 시간 문제가 발생할 수 있다.
  - 스냅샷은 마스터보다 레플리카에서 생성하는 방식이 쓰기 작업을 수행하는 서비스에 미치는 영향을 줄일 수 있다.
  - 단, 레디스의 레플리케이션은 비동기 방식이므로, 마스터와 레플리카 간에 약간의 차이가 있을 수 있다는 점을 주의

### 3-4. 커넥션 풀링

- 클라이언튼에게 `커넥션 풀링 Connection Pooling` 기능 제공
- 연결을 재사용하여 처리 효율성을 높임.
- 사용 중인 레디스 클라이언트에서 이 기능을 지원하는지 확인하고, 지원한다면 활용하는 것이 좋다.
- 최대 동시 연결 수뿐만 아니라, 새로운 연결이 많은 경우에도 문제가 발생하여 지연 시간에 영향을 줄 수 있으므로 이 부분을 모니터링해야 한다.
- 최대 동시 연결 수는 `maxclients` 지시자로 설정할 수 있으며, 기본값은 10,000이다.
  - 레디스가 열 수 있는 파일 디스크립터의 최대 개수는 커널에 의해 소프트 제한이 걸려 있다. (32개) => 파일 디스크립터 수를 `maxclients + 32개`로 설정

### 3-5. 재시도 처리

- 클라이언트와 레디스 서버 간 통신이 일시적으로 중단되었을 때, 클라이언트 측에서 재시도를 수행하는 것은 효과적일 수 있다.
- 재시도 처리 
  - 재시도 횟수
  - 타임아웃 값
  - 재시도 간격
  - 재시도 횟수의 상한선
- 경우에 따라서는 `지터 Jiter`라고 불리는 무작위성을 추가하여 재시도를 분산시키는 방법도 사용
- 저자가 추천하는 방법. `지수 백오프 Exponential Backoff` 알고리즘에 기반한 방법
  - 처음 접속 시도에 실패하면 짧은 시간 동안 대기한 후 다시 시도. 성공하면 종료되지만 실패할 경우 이전 대기 시간의 두 배를 기다린 후 다시 시도. 재시도 간격을 지수적으로 늘려가는 방법.
  - 무한으로 재시도하지 않도록 재시도 횟수의 상한선도 설정하는 것이 일반적이다.
  - 여러 클라이언트가 동시에 재시도를 할 경우, 레디스 서버에 집중적인 부하가 발생할 수 있는데 이때 지터를 활용할 수 있다.
  - 지터는 재시도 간격 시간을 단순히 두 배 증가시키는 것뿐 아니라, 무작위로 짧은 시간을 추가하여 여러 클라이언트에서 동시 접소하는 반복 상황을 피하고, 레디스 서버의 과부하를 줄일 수 있다.
- 애플리케이션과 데이터의 특성을 고려하여 각종 매개변수 값을 적절하게 설정해야 한다.
  - 레디스 클라이언트 자체적으로 지수 백오프 기능을 제공하기도 하니 참고!

### 3-6. 기타 모범 사례

- 클라이언트의 소켓 타임아웃 값을 확인하면 좋다.
  - 이 값은 적어도 1초 이상으로 설정하는 것을 권장
  - 너무 작으면 레디스 서버에 대한 부하가 증가할 때마다 소켓을 통한 데이터 송수신에 시간이 걸려, 타임아웃 오류를 자주 발생시킬 수 있다.
  - 하지만 값이 너무 크면 연결 문제를 감지하는 데 시간이 오래 걸릴 수 있으므로 요구사항에 맞춰 균형 잡힌 값으로 설정해야 한다.ㄴ

----

## 4. 캐시 노드 크기 조정

### 4-1. 크기 조정 기준

- 캐시 노드 크기 결정 기준!

#### 레디스 클러스터

- 먼저 레디스 클러스터의 필요성을 생각해본다.
  - 클러스터를 구축하는 경우, 최소 세 개의 캐시 노드를 마스터로 설정해야 한다.

1. 레디스 클러스터를 사용할 필요가 있는지 결정 (일반 레디스 서버만으로도 충분한지)
2. 사용 중인 클라이언트가 레디스 클러스터를 지원하는지 확인

- 레디스 클러스터는 주로 부하가 높은 쓰기 작업을 처리하는 경우나 높은 가용성이 요구되는 경우에 필요하다.
  - 요구되는 메모리 용량이 매우 큰 경우에는 캐시 노드를 늘려 메모리 용량을 확장할 수 있는 레디스 클러스터가 필요하기도 하다.
- 클러스터를 사용하기로 결정했다면, 캐시 노드의 개수도 늘어나지만 내부 동작 방식 등 이해해야 할 내용이 늘어난다.
  - 용도와 부하를 고려했을 때 레디스 클러스터 없이도 충분히 처리할 수 있는 경우가 있으므로 레디스 클러스터가 꼭 필요한 것이 아니라면 사용하지 않아도 된다.
- 사용하려고 해도 클라이언트가 지원하지 않는다면?
  - 해당 기능이 준비되어 있는지 확인하되, 호환되는 클라이언트를 찾아야 함.

#### 실제 용도에 맞는 요구사항 추정

- 제공하는 서비스의 요구사항을 고려하여 레디스 서버가 다음 항목에 대해 어느 정도로 데이터를 처리해야 하는지 고려해야 한다.

1. 전체 데이터양
2. 최대치일 때 총 키의 개수
3. 하나의 키 당 평균 크기 및 최대 크기
4. 초당 키의 작업 수
5. 네트워크 트래픽
6. 실행되는 명령어 내역

- 가장 중요한 것은 데이터양이다.
  - 캐시 노드 전체에 데이터를 다 저장하지 못하면 메모리가 부족해진다.
  - 레디스 클러스터가 아닌 레디스를 서버로 사용하는 경우, 전체 데이터양을 저장할 수 있는 메모리가 장착된 캐시 노드를 사용해야 한다.
- 데이터가 샤드 간에 균등하게 분산된다고 하면 전체 데이터양을 샤드 수로 나눈 메모리 크기를 가진 캐시 노드를 사용하면 된다.
  - 그러나 실제로 샤드 간에 데이터가 균등하게 분산되는 경우느느 매우 세심하게 설계한 경우를 제외하고는 거의 없으므로 메모리 용량의 여유가 있는 노드를 선택하는 것을 권장한다.
  - 메모리가 큰 캐시 노드의 샤드 수를 줄일지, 메모리가 작은 캐시 노드의 샤드 수를 늘릴지도 검토
- 캐시 노드를 선택할 때 캐시 노드가 너무 작으면 노드가 처리할 수 있는 네트워크 대역폭이나 처리량이 한계를 초과할 수도 있다.
  - 따라서 전체 데이터양을 대략적이라도 파악하고, 여유를 갖고 처리할 만큼 큰 캐시 노드를 사용해야 한다.
  - 키 하나 당 크기가 큰 경우도 고려해야 한다. 예를 들어 Hash형인 키 하나에 매우 큰 해시가 저장되어 있는 경우, 샤드가 여러 개 있어도 데이터 분산이 어려울 수 있다.
- 확장성과 운영 측면을 고려하면 다루는 데이터 모델에 따라 자료형을 선택하는 것이 중요하다.
  - 특히 대규모 데이터를 다룰 경우, String형 이외의 자료형을 사용할 때는 신중해야 할 필요가 있다.
  - 바로 사용하기보다는 String형을 통해 데이터를 쉽게 분산하여 관리할 수 있는 방법을 찾는 것이 좋다.
- 사용하는 명령어의 유형도 고려해야 할 사항이다.
  - O(N) 복잡도 고려.
  - 샤드 수 등을 결정한 후 실제로 처리할 수 있는지를 실제 환경과 동일하거나 그에 가까운 워크로드로 테스트하는 것이 가장 좋다.
- 처음에는 대략적인 규모를 파악하는 것도 좋은 접근 방법이다.
  - 개별 캐시 노드에 벤치마크를 수행하고, 각 노드가 처리할 수 있는 요청 개수를 살펴보는 것도 방법이다.
  - 초당 얼마나 많은 데이터 요청을 처리해야 하는지에 따라 필요한 캐시 노드의 개수를 대략적으로 계산하다.
  - 그 후 레디스 서버를 시작하여 전체적으로 벤치마크를 다시 수행한 후 검증해야 한다.
- 특히 OSS 버전의 레디스 클러스터의 경우, 반드시 노드 수에 비례하여 성능이 향상되는 것은 아니다.
  - 대규모 환경에서도 레디스 클러스터는 많이 사용되고 있다.
  - 그러나 대규모 클러스터에서는 헬스 체크를 위한 메시지의 양이 많아지므로 약간의 성능 저하나 운영의 불안정성이 발생할 수도 있다.

#### 클라우드의 크기 조정

- 클라우드 서비스를 사용하는 경우에는 백업 기능 지원 여부, 노드 크기별 특성, 레디스 버전별로 서비스 특유의 엔진 기능 등도 고려해야 한다.
- 기능과 제한 사항을 확인하고 레디스 클러스터를 사용하는 데 있어서 비즈니스 요구사항을 충족하는지 사전에 문서를 통해 확인해야 한다.

----

## 5. 설정 파일 redis.conf

- 설정을 통해 동작을 커스터마이징.
- 각종 기능의 활성화/비활성화 및 튜닝에 주로 사용.
- 특별한 요구사항이 없다면 무분별하게 여러 매개변수를 조정하기보다는 기본 설정 상태로 사용하는 것이 좋다.
  - 요구사항이나 환경에 따라 필요한 부분만 변경하여 사용하자.

----

## 6. 보안

- 레디스는 신뢰할 수 있는 환경에서만 접근할 수 있도록 설계되었다. 완전한 인증 기능이나 접근 제어는 고려되지 않았고, 성능의 극대화 및 구현의 단순성에 초점을 맞춰 개발되었다.
- 신뢰할 수 없는 환경에서 레디스에 접근할 때는 `ACL(Access Control List)`(접근 제어 목록) 기능을 사용하거나 사용자 입력을 검증하는 중간 계층을 추가하는 방식을 권장한다.
  - 의도치 않은 접근으로 인한 취약점을 방지한다.
- 일반적으로 ACL 기능은 특정 리소스에 대해 접근 권한과 가능한 작업을 지정한 목록으로 제어한다.
  - 레디스는 버전 6부터 ACL 기능을 지원하며, 독립적으로 사용할 수 있다.
  - ACL 기능은 신뢰할 수 없는 환경으로부터의 접근을 방지하는 데 사용할 수 있으며, 신뢰할 수 있는 환경에서 접근하더라도 최소한의 접근 수준만 부여하여 보안을 강화할 수 있다.
  - 사용자 입력을 검증하는 계층의 역할은 웹 애플리케이션 등이 맡게 된다.

### 6-1. 보안 설정

#### 네트워크 보안

- `bind` 지시자를 통해 IP 주소 지정.
- 데이터 전송 시 암호화 (버전 6.0 이상)
- TLS 통신 기능 제공.
- 기본적으로 `보호 모드 protected mode`가 활성화되어 있다.
  - 이 모드가 활성화되어 있을 때는 루프백 인터페이스와 유닉스 도메인 소켓에서만 접근할 수 있다.

#### 명령어 제한

- 외부로부터 명령어 실행을 방지하기 위해 특정 명령어를 비활성화할 수 있다.
  - 명령어 이름을 예측할 수 없는 이름으로 변경하는 방식으로 실행된다.
  - ex) 일반 사용자에게 필요하지 않은 `CONFIG`/`FLUSHALL`/`FLUSHDB` 같은 명령어의 실행을 제한.
- `rename-command` 지시자를 사용하여 `CONFIG` 등의 명령어 이름을 암호화하여 저장한다.
  - 그러나 레디스 6.0 이후 ACL 기능으로 `CONFIG` 명령어에 제한을 둘 수 있으므로, `rename-command`는 곧 폐지될 예정이라고 한다. 

#### 인증

- `requirepass` 명령어를 통해 설정 파일에 패스워드를 설정함으로써 인증할 수 있는 기능 제공.
  - 클라이언트는 `AUTH` 명령어를 사용하여 패스워드를 지정하고 연결한다.
  - 그러나 `AUTH` 명령어의 전송 자체는 암호화되지 않기 때문에 도청에는 효과가 없다.

#### 외부 클라이언트에서 공격

- 외부 클라이언트에서 시스템 취약점을 노리고 만든 특별한 데이터로 공격할 수도 있다.
  - ex) 해시 테이블에서 동일한 버킷으로 해시되는 문자열을 입력하여 CPU 소모의 복잡도가 O(N)만큼 증가하거나, DoS 공격을 유발할 수 있다.
  - 이를 방지하기 위해 의사 난수 함수의 시드를 사용하는 방법이 있다.
- 문자열 `이스케이핑 escaping` 및 NoSQL 삽입에 대한 고려도 필요하다.
  - 레디스 프로토콜에서는 문자열 이스케이핑 개념이 없어 일반적으로는 삽입을 할 수 없지만 신뢰할 수 없는 소스를 사용한 루아 스크립트의 본문을 작성하는 것을 피해야 한다.

#### 코드 보안

- 레디스는 버퍼 오버플로우, 포맷 버그, 기타 메모리 손상 문제를 방지하기 위해 설계되었다.
  - 그러나 `CONFIG` 명령어를 통해 RDB 파일 디렉토리 등의 경로를 변경할 수 있으므로 이것이 보안 문제로 이어질 수 있다.
  - 레디스 운영에는 기본적으로 루트 권한이 필요하지 않다. => 불필요한 권한이 없는 레디스 전용 사용자를 생성하여 이 사용자의 권한으로 운영함으로써 대처할 수 있다.

### 6-2. ACL 기능

- 6.0부터 도입
- 다양한 보안 모델을 도입하기 쉬워졌다.

----

# 참고자료

- 실전 레디스, 하야시 쇼고 지음, 서대원 옮김, 정격석 감수, 한빛미디어
