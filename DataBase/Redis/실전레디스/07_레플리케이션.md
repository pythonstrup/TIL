# 07 레플리케이션

- 데이터 레플리케이션은 일반적으로 쓰기 작업이 있을 때마다 업데이트된 데이터를 다른 서버로 계속 보내 복제하는 것을 말한다.
- 이러한 방식을 통해 서버를 추가하고 리소스를 확장하여 읽기 쿼리의 부하를 관리할 수 있으며, 데이터 `중복성 Redundancy`을 통한 `페일오버 Failover`로 가용성을 얻을 수 있다.

## 1. 레플리케이션 기능

- 레디스는 여러 노드로 운영하기 위한 레플리케이션 기능을 제공하고 있다.
- 마스터-레플리카 모델에서는 지속적으로 마스터의 업데이트 내용을 여러 레플리카에 반영한다. 이 방식은 RDBMS에서 사용하는 방식과 유사하다.
- 레플리케이션 기능의 주요 목적은 읽기 작업 확장과 고가용성을 위한 중복성 확보다.

### 1-1. 비동기 처리를 통한 구현

- 이벤트 루프의 비동기 `논블로킹 Non-Blocking` 방식으로 구현되어있다.
- 비동기 방식으로 인해 지연이 발생하는 경우, 마스터와 레플리카 내의 데이터가 동일하다고 보장할 수 없다.
  - 즉, 마스터에 데이터를 저장한 직후 레플리카에 접근하면 데이터가 존재하지 않을 수도 있다.

### 1-2. 레플리케이션을 사용할 때 레디스를 연결하는 방법

- 레플리케이션을 사용할 때는 각 캐시 노드의 IP 주소나 엔드포인트를 기록해두고, 레디스 클라이언트에서 직접 접근하거나 `twemproxy`와 같은 프록시를 활용해 여러 레플리카의 요청 라우팅 과정을 자동화할 수 있다.
- `ElastiCache`를 사용하는 경우, 클러스터 모드가 비활성화된 레디스 클러스터에서는 다음과 같은 엔드포인트를 사용할 수 있으므로 프록시 등을 직접 준비하고 관리하는 수고를 덜 수 있다.
  - 마스터에 대한 요청 라우팅은 `프라이어머리 엔드포인트 Primary Endpoint`아더,
  - 레플리카에 대한 요청 라우팅은 `리더 엔드포인트 Reader Endpoint`다.

### 1-3. 기본적으로 읽기 전용인 레플리카

- 레플리케이션을 활용하는 방법 중에는 레플리카를 추가하여 읽기 작업의 부하를 관리하는 방법이 있다.
  - 레플리카에서 직접 쓰기 작업을 수행할 수도 있지만, 문제가 발생할 위험을 고려해야 한다.
  - 만약 실행 시간이 많이 소요되는 작업을 처리해야 한다면 레플리카에 쓰기 작업을 활성화하여 임시 데이터를 저장해두고 여러 번 참조하도록 하는 유스케이스를 고려해볼 수 있다.
  - 그러나 레플리카에 쓰기 작업이 가능한 상태에서는 데이터의 일관성이 깨질 위험이 있으므로, 앞서 설명한 유스케이스처럼 특별한 이유가 있을 경우에만 사용하는 것이 좋다.
- `replica-read-only` 지시자를 통해 변경 가능. 신중하게 변경해야 한다.

### 1-4. 마이그레이션으로 활용하기

- 새로운 레디스 서버로 마이그레이션할 때, 다운타임을 최소화하기 위해 레플리케이션 기능을 활용할 수 있다.
  - 기존 레디스 서버에서 마이그레이션할 레디스 서버로 레플리케이션을 생성한 후에 마이그레이션한 서버를 독립시키는 방식으로 수행.
  - 이때 다운타임은 페일오버 시간만큼으로 최소화할 수 있다.

### 1-5. 레플리케이션 주의사항

- 레플리케이션 작업을 실행할 때 마스터에 영속성이 설정되어 있지 않은 경우, 엔진을 재실행하거나 종료하면 데이터 세트가 초기화된 상태로 실행된다.
  - 또한 레플리카도 초기화되므로 주의해야 한다.

---

## 2. 레플리케이션을 시작할 때의 메커니즘

1. 레플리카는 `PSYNC` 명령어로 마스터에 연결을 요청하며, 해당 시점까지는 처리한 레플리케이션 ID와 오프셋을 전송한다.
2. 마스터는 요청받은 마스터의 레플리케이션 ID와 자신의 레플리케이션 ID가 일치하는지 확인하고, 오프셋이 레플리케이션 백로그의 버퍼에 있는지 확인한다.
3. 요청받은 오프셋이 레플리케이션 백로그에 있는지에 따라 처리가 달라진다.
   1. 레플리케이션 백로그에서 동기화가 가능한 경우: 요청된 오프셋이 레플리케이션 백로그에 있고, 레플리케이션 백로그에서 동기화가 가능한 경우에는 부분 동기화를 실행한다.
   2. 레플리케이션 백로그에서 동기화가 불가능한 경우: 레플리케이션 중단 중에 마스터가 받은 쓰기 작업 요청의 크기가 버퍼 크기를 초과하여 부분 동기화가 불가능한 경우에는 전체 동기화를 실행한다.

- 전체 동기화 vs 부분 동기화
  - 전체 동기화가 요청 처리에 미치는 영향은 매우 크다. 프로세스가 포크 처리되어 마스터의 메모리 데이터를 덤프하고 디스크에 RDB 파일을 저장하므로, 이러한 작업으로 영향이 크다. 덤프한 모든 데이터를 전소하여 네트워크 대역폭을 압박할 수도 있다. 
  - 반면 부분 동기화는 요청 처리에 미치는 영향이 작지만, 조건을 충족하지 못하면 사용할 수 없는 방법이다.

### 2-1. 전체 동기화

#### 세부사항

- 마스터가 RDB를 전송하기 시작할 때 레플리카에 RDB 파일이 있다면 데이터의 일관성을 위해 레플리카에 있는 파일은 삭제된다.
- 또한 레플리카가 마스터로 레플리케이션 시작을 요청한 후 RDB 파일 데이터를 수신하는 동안, 레플리카는 클라이언트로부터 요청받는 경우도 있다.
  - 이러한 경우, 레플리카는 기본적으로 요청에 응답하게 되어 있어서 동기화 이전의 데이터가 반환될 수 있으므로 레플리카에서 마스터로 처음 동기화할 때 데이터 세트가 비어 있는 상황이 발생할 수 있다.
  - 이 동작 방식은 `replica-serve-stale-data` 지시자의 값을 조정해서 변경할 수 있다.
    - 기본값 `yes`

#### 여러 개의 레플리카가 있을 때의 동작

- `BGSAVE`의 처리 완료 시점에 따라 달라짐.
  - 완료되기 전에 동기화 요청 => 첫 번째 레플리카와 동일한 내용으로 복제.
  - 완료된 후 => 전체 동기화 과정이 처음부터 다시 시작.

#### 연결이 끊길 때의 동작

- 출력 버퍼가 초과되면 연결이 끊어지고 재동기화를 시도하게 된다.
- 출력 버퍼는 `client-output-buffer-limit` 지시자로 설정
  - 기본은 `256mb 64mb 60`으로 설정
  - `256mb`: 하드 리미트. 즉시 연결 끊음.
  - `64mb 60`: 소프트 리미트. 60초 지속되면 연결 끊음 

#### TTL이 설정된 키의 레플리케이션 동작

- 레플리카에서는 자체적으로 만료 X
  - 마스터에서 모든 레플리카로 `DEL` 전파

#### 디스크 없는 레플리케이션

- 디스크 백업 레플리케이션  
  - 마스터의 메모리 데이터를 RDB 파일로 덤프하여 디스크에 쓰는 방식.
  - 디스크 속도가 느리면 부하가 크다.
- 디스크 없는 레플리케이션
  - 프로세스가 포크된 후, RDB 파일을 직접 소켓으로 전송.
  - `repl-diskless-sync` 지시자 값을 `yes`로 변경하여 이 기능을 활성화할 수 있다. 기본값은 `no`

#### 그 외 레플리케이션 최적화를 위한 확인 사항

- 레플리카 소켓의 `TCP_NODELAY` 설정 비활성화가 있다.
- 트래픽이 높거나 마스터/레플리카 간의 거리가 먼 경우, `TCP_NODELAY`를 비활성화하면 효과적일 수 있다.
  - 비활성화를 하려면 `repl-disable-tcp-nodelay` 지시자를 `yes`로 변경하면 된다.
- 최적화를 위해서는 성능에 미치는 영향도 고려해야 한다.
  - 레플리카는 마스터 내에서 추가 프로세스를 실행하기 때문에 레플리카 수가 증가하면 마스터의 성능에 영향을 줄 수 있다.
- 또한 레플리카 수가 많을 경우 네트워크 대역폭 소비가 증가할 수 있으므로, 이를 감안하여 다단계 레플리케이션 구조를 고려할 수 있다.

### 2-2. 부분 동기화

- 레플리케이션 연결이 끊어진 동안의 모든 쓰기 작업이 레플리케이션 백로그에서 레플리카로 전송된다.
- 레플리케이션의 마스터에는 `레플리케이션 백로그 Replication Backlog`라고 불리는, 고정 길이의 리스트 위에 있는 메모리 영역이 있다.
  - 레플리케이션 연결이 끊어진 동안에는 이 백로그에서 쓰기 작업 정보를 일정 시간 동안 관리한다.
- 백로그의 크기는 `repl-backlog-size` 지시자로 설정할 수 있으며, 기본값은 1MB이다.
  - 만약 쓰기 작업이 1MB를 초과하면 레플리카의 `PSYNC` 요청에서 오프셋이 백로그에 포함되지 않기 때문에 부분 동기화를 실행할 수 없으며 대신 전체 동기화를 시작하게 된다.
- 연결이 끊어진 후 일정 시간이 지난 백로그가 해체되도록 동작한다.
  - `repl-backlog-ttl`, 기본값 3,600(1시간)
  - 값을 0으로 설정하면 무기한으로 보관

#### 동기식 레플리케이션 강제

- 기본적으로 비동기다.
  - 그러나 레플리케이션을 강제로 동기식으로 수행하려면 레디스 3.0 이후부터 사용 가능한 `WAIT` 명령어를 사용한다.
- 데이터 손실에 대한 안전성을 높일 수 있으며, 특히 페일오버 도중에 스기 작업을 받은 레플리카를 새로운 마스터로 효율적으로 승격시킬 수 있다.
- `WAIT` 명령어는 클라이언트가 지정한 개수만큼의 레플리카로부터 응답을 받을 때까지 현재 클라이언트를 차단하도록 동작한다.
  - 이를 통해 데이터 손실을 방지할 수 있다.
  - 또한 `WAIT` 명령어는 부분 동기화를 통해 마스터로 보내는 핑에 레플리카가 이미 처리한 오프셋을 포함할 수 있게 되었으며, 이를 통해 레플리카의 타임아웃을 감지하는 데 활용한다.
- 비동기 레플리케이션의 특성상, 마스터에 쓰기 작업을 수행한 후 레플리카에 해당 데이터를 저장하기 전에 마스터에서 장애가 발생할 가능성이 있다.
  - 이러한 경우 레플리카에 저장되지 않은 데이터가 손실될 수 있다.
- 이러한 가능성을 고려한다면 애플리케이션에서 재시도를 처리하거나 RDBMS와 같은 다른 데이터베이스에서 데이터를 가져오는 등의 방법으로 데이터를 적절히 처리할 필요가 있다.
  - `WAIT` 명령어 등으로 동기 레플리케이션을 구현할 경우, 동기화 과정이 성능에 부담을 줄 수 있으므로 성능에 미치는 영향도 고려해야 한다.

----

# 참고자 

- 실전 레디스, 하야시 쇼고 지음, 서대원 옮김, 정격석 감수, 한빛미디어
