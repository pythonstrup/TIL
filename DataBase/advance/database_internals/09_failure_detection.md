# 9장 장애 감지

- 응답하지 않는 결함이 있는 프로세스가 생기면 레이턴시가 증가하고 시스템 가용성은 감소한다.
- 비동기 분산 시스템은 프로세스가 중단된 것인지 아니면 응답 시간이 지연되고 있는 것인지 알 수 없기 때문에 장애를 감지하기가 매우 어렵다. 

> #### FLP 불가능성 이론
> - 네트워크가 비동기적이고 단 하나의 프로세스라도 고장 날 수 있다면, 모든 정상 프로세서가 합의에 도달하는 것을 항상 보장하는 분산 알고리즘은 존재하지 않는다.

- `중단된 프로세스 stoped process`: `종료 dead`, `중단 failed`, `충돌 crashed`과 같은 용어는 실행이 완전히 중단되 프로세스를 나타낸다.
- `비정상 프로세스 suspected process`: `응답하지 않음 unresponsive`, `장애 발생 faulty`, `느림 slow` -> 하지만 실제로 완전히 중단됐을 수 있다.
- 장애는 링크 또는 프로세스 레벨에서 발생할 수 있다.
  - 속도 저하와 장애는 구별이 안 되는 경우도 있다.
  - **정상 프로세스를 중단된 상태로 오인하는 상황**과 **응답이 없는 프로세스를 바로 중단된 상태로 인지하지 않고 응답을 기다리는 상황** 사이의 트레이드-오프가 존재한다.
- 라이브니스와 안정성은 알고리즘의 문제 해결 능력과 결과의 정확성을 나타내는 속성.
  - `라이브니스`: 의도된 이벤트는 반드시 발생됨.
  - `안정성`: 의도되지 않은 이벤트는 반드시 발생하지 않음.
- 장애가 발생한 프로세스를 제외 -> 불필요한 작업이 줄어들고 에러 및 장애가 전파되는 것을 방지.
  - 반대로 의심스럽지만 정상 작동하는 프로세스 제외 -> 가용성이 감소.
- 장애 알고리즘의 중요한 속성
1. `완전성 completeness`: 장애 발생 시 모든 정상 프로세스는 장애 발생 사실을 인지해야 하고 알고리즘 수행을 완료해 결과를 반환해야 한다.
2. `효율성 effectiveness`: 장애 감지 시스템이 얼마나 빨리 장애를 감지할 수 있는지.
3. `정확성`: 얼마나 정확하게 장애를 감지했는지

- 알고리즘이 효율적일수록 정확성이 낮고, 정확할수록 효율성이 떨어진다. (트레이드-오프)
- 많은 분산 시스템이 `하트비트 heartbeat`를 사용해 장애 감지 시스템을 구현한다.
  - 간단하고 완전성이 높다.

## 하트비트와 핑

- 원격 프로세스는 다음 중 하나의 작업을 주기적으로 발동시켜 확인할 수 있다.
1. 원격 프로세스에 메시지를 보내는 `핑 ping`을 발동시켜 원격 프로세스가 일정 시간 내에 응답하는지 확인
2. 인근 프로세스에 자신의 활성 상태를 알릴 수 있는 하트비를 전송

- 많은 장애 감지 알고리즘이 하트비트와 타임아웃 사용
  - ex) 분산 시스템 프레임워크 `아카 Akka`: 일정 시간 간격으로 하트비트를 사용해 상태를 보고하지 않는 프로세스가 있는지 확인하는 데드라인 장애 감지 시스템이 포함.
- 이 방식은 몇 가지 문제가 있다.
  - 핑 주기와 타임아웃 값이 정확도를 좌우한다.
  - 다른 프로세스의 관점에서 프로세스의 상태를 확인할 수 없다.

### 타임아웃이 없는 장애 감지

- 하트비트 알고리즘은 타임아웃을 사용하지 않고 하트비트 전송 횟수를 기록한다.
  - 애플리케이션은 하트비트 카운터 벡터에 저장된 값을 기반으로 장애를 감지한다.
  - 이 알고리즘은 타임아웃이 없기 때문에 비동기 시스템에서만 사용할 수 있다.
- 모든 프로세스는 `페어 링크 fair link`만으로 구성된 `페어 패스 fair path`로 연결됐고 모두 서로의 존재를 알고 있다고 가정한다.
- 각 프로세스는 인근 프로세스 목록과 각 프로세스의 카운터를 저장하고 인근 프로세스에 하트비트 메시지를 전송한다.
  - 각 메시지에는 하트비트가 이동한 경로를 기록한다.
  - 최초 메시지에는 경로의 첫 번째 발신자 정보와 동일한 메시지를 중복 브로드캐스트하지 않기 위한 고유 식별자를 기록한다.
- 하트비트 메시지를 수신한 프로세스는 경로에 포함된 모든 프로세스의 카운터를 증가.
  - 자신을 경로에 등록한 뒤에 목록에 없는 프로세스에 메시지 전송.
  - 모든 프로세스가 메시지를 수신하면 메시지 전파를 중지.
- 하트비트 카운터는 시스템의 글로벌 뷰.
  - 하트비트가 프로세스 사이에 전파되는 과정을 알 수 있고 이를 사용해 프로세스의 상태를 비교할 수 있다.
  - 하지만 하트비트 카운터가 나타내는 상태를 정확히 판단하기 어려울 수 있다.
  - 결과의 정확성을 높일 수 있는 적절한 임곗값ㅇ르 설정하지 않으면 알고리즘은 정상 프로세스를 비정상 상태로 잘못 판단할 수 있다.

### 하트비트 아웃소싱

- `SWIM 프로토콜 Scalable Weakly Consistent Infection-style Process Group Membership Protocol`
- 주변 프로세스의 관점에서 프로세스의 라이브니스를 판단하는 하트비트 아웃소싱 방식 -> 결과의 신뢰성을 높일 수 있는 방법
  - 만약 어떤 프로세스 P2가 동작하지 않는다면, P3와 P4 등 다른 프로세스에 하트비트를 아웃소싱하여 P2의 상태를 체크하게 하는 것이다.
- 광범위한 피어 그룹에 메시지를 브로드캐스트하지 않아도 된다는 점. 하트비트를 병렬로 전송할 수 있기 때문에 비정상 프로세스에 대한 정보를 더 빠르게 수집하고 상태에 대한 더 정확한 판단을 내릴 수 있다는 점.

## 파이 누적 장애 감지

- 노드의 상태를 작동 중이거나 작동 중단된 상태 두 가지로 나누는 대신, 파이 누적 장애 감지 방식에서는 노드의 상태를 프로세스의 충돌 확률을 나타내는 연속형 척도로 나타낸다.
  - 이 시스템은 `슬라이딩 윈도우 sliding window`에 주변 프로세스의 마지막 하트비트의 도착 시간을 기록한다.
  - 이 기록을 기반으로 다음 하트비트의 도착 시간을 예측하고 실제 도착 시간과 비교해 현재 네트워크 상태에서의 장애 감지 정확성을 나타내는 `불신도`를 계산한다.
- 설계 관점에서 파이 누적 장애 시스템은 다음 3개의 서브시스템으로 구성된다.
1. `모니터링 프로세스`: 핑과 하트비트 사용 또는 요청-응답 샘플링을 통해 노드의 라이브니스 확인
2. `판정 프로세스`: 프로세스를 비정상 상태로 표시해야 하는지 여부를 결정
3. `액션 프로세스`: 프로세스가 비정상 상태로 판정됐을 때마다 실행하는 콜백 작업

- 모니터링 프로세스는 하트비트 도착 시간의 데이터 샘플을 고정 크기 윈도우에 수집 및 저장한다.
  - 새로운 데이터는 윈도우에 추가하고 기존 데이터는 제거한다.
- 표본의 평균과 분산을 계산해 샘플링 윈도우의 분포를 추정한다.
  - 이정보를 기반으로 바로 전 메시지 도착 이후 `t` 시간 단위 내에 메시지가 도착할 확률과 프로세스의 라이브니스의 정확도를 나타내느 `파이`를 계산한다.
  - 이 값은 예측한 도착 시간에 하트비트가 도착하지 않을 확률을 의미한다.

## 가십과 장애 감지

- 단일 노드의 시점에서 장애를 판단하지 않는 또 다른 방식은 `가십 gosship`을 사용해 인근 프로세스의 상태를 수집하고 전달하는 가십형 장애 감지 서비스다.
- 각 노드는 전체 노드 목록과 각 노드의 하트비트 카운터 그리고 마지막으로 카운터가 증가된 시간을 나타내는 타임스탬프 값을 저장한다.
  - 노드는 주기적으로 자신의 카운터를 업데이트하고 목록을 임의의 노드로 전송한다. -> 그리고 다른 노드의 카운터와 상태를 확인한다.
  - 목록을 전달받은 노드는 자신의 목록과 병합해서 다른 노드의 카운터를 업데이트한다.
- 거짓 양성 발생 확률을 줄이려면 타임아웃 값을 신중하게 선택해야 한다.
  - 노드가 서로 통신하는 빙도에는 한도가 있으며, 통신 빈도는 시스템의 프로세스 수에 비례해 증가한다.

## 장애 전파를 사용한 문제 해결

- 장애에 관한 정보를 전파하는 일이 항상 가능한 것은 아니며 모든 노드에 정보를 알리는 데 드는 비용이 매우 높을 수 있다.
- `FUSE, Failure Notification Service`는 네트워크 파티션이 발생해도 낮은 비용으로 신뢰할 수 있게 장애를 전파하는 방법이다.
- FUSE는 장애를 감지하기 위해 모든 활성 프로세스를 여러 그룹으로 나눈다.
  - 어떤 한 그룹에 장애가 발생하면 모든 참가자는 해당 장애를 감지할 수 있다.
  - 개별 프로세스의 장애가 그룹 전체의 장애로 확장돼 전파된다.
- 각 그룹의 프로세스는 주기적으로 그룹 내 다른 프로세스에 핑 메시지를 보내 상태를 확인한다.
  - 만약 특정 프로세스가 충돌, 네트워크 파티션 또는 링크 장애로 인해 핑에 응답하지 않으면 핑을 보낸 프로세스도 더 이상 다른 핑에 응답하지 않는다.

