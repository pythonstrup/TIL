# 10장 리더 선출

- 동기화는 비용이 많이 들 수 있음.
  - 각 단계마다 모든 참가자와 통신해야 한다면 상당한 통신 오버헤드 발생
  - 동기화 프로세스를 줄이고 의사 결정에 필요한 메시지 왕래 횟수를 줄이기 위해 일부 알고리즘에는 분산 알고리즘의 단계를 수행 및 조정하는 리더 프로세스가 있다.
- 분산 시스템의 프로세스는 균일하고 모든 프로세스가 리더 역할을 맡을 수 있다.
  - 리더 프로세스는 오랫동안 리더 역할을 유지하지만 영구적이지는 않다.
  - 일반적으로 프로세스에 장애가 발생할 때까지 역할을 유지한다.
- 선출 알고리즘의 `지속성 liveness`은 거의 항상 리더가 존재하고 선출 과정은 결국 완료됨을 보장한다.
- 이상적으로 `안정성`도 보장되면 좋다.
  - 한 번에 하나의 리더만 존재할 수 있고, `split brain` 현상은 절대로 발생하지 않아야 한다.
  - 하지만 많은 리더 선출이 이 조건을 위반한다.
- 리더 프로세스는 브로드캐스트된 메시지의 순서를 유지한다.
  - 리더는 전역 상태를 수집 및 저장하고 수신한 메시지를 각 프로세스에 전달한다.
  - 나아가 장애 발생 후, 시스템 초기화 중 또는 중요한 상태 변경이 발생한 경우 시스템 재구성 작업을 조정한다.
- 선출 작업은 시스템 초기화 시 첫 리더를 선출하기 위해 또는 이전 리더 프로세스가 충돌하거나 장애가 발생했을 때 발동된다.
  - 선출 작업은 `결정론적 deterministic`이어야 한다.
  - 정확히 하나의 리더를 선출하고 모든 참가자는 결과를 인정해야 한다.
- 리더 선출과 분산 잠금은 이론적으로 유사해 보이지만 미세한 차이가 있다.
  - 한 프로세스가 `임계 구역 critical section`에 대한 잠금을 소유하는 있는 동안 지속성만 보장된다면 다른 프로세스는 잠금 소유자가 누구인지 알 필요가 없다.
  - 이와 대조적으로 리더 프로세스에는 모든 구성원이 인지해야 하는 특수 속성이 있다. 따라서 새로운 리더는 모든 구성원에게 자신의 존재를 알려야 한다.
- 시스템에 안정적인 리더가 있ㅇ면 원격 노드의 상태를 동기화하지 않아도 되고 주고받는 메시지 수를 줄일 수 있다.
  - 나아가 여러 노드가 아닌 하나의 프로세스가 작업을 수행하도록 조정할 수 있다.
  - 리더 프로세스가 있는 시스템의 가장 큰 문제는 리더가 병목이 될 수 있다는 것이다. -> 여러 개의 독립적인 파티션을 나누고 각 파티션별로 리더를 선출함으로써 문제 해결. `스패너 Spanner`가 이 방식을 사용한다고 함.
- 모든 리더 프로세스에는 장애가 발생할 수 있기 때문에 장애를 감지, 보고 및 처리할 수 있어야 한다.
  - 장애 발생 시 이전 리더를 대체할 새로운 리더를 선출해야 한다.
- `ZAB`와 `멀티 팍소스 Multi-Paxos`, `래프트 Raft`와 같은 알고리즘은 참가자 간 합의를 도출하는 데 필요한 메시지 수를 줄이기 위해 임시 리더를 선출한다.
  - 하지만 각 알고리즘별로 리더 선출과 장애 감지, 경쟁하는 리더 프로세스 사이의 충돌을 해결하는 방법은 다르다.

## 불리 알고리즘 bully algorithm

- 프로세스의 순위를 기반으로 리더를 선출하는 알고리즘.
- 각 프로세스에 고유 순위를 부여하고 가장 높은 순위의 프로세스가 리더가 된다.
- 알고리즘 이름이 불리(깡패)인 이유는 가장 높은 순위의 노드가 다른 노드들이 결과를 인정하도록 압박하기 때문이다.
- 군주가 사망하면 왕위 계승률에 따라 가장 서열이 높은 혈통이 군주가 되는 것에 빗대 `군주 monarchial` 선출 알고리즘이라고 부르기도 한다.
- 프로세스가 시스템 내 리더의 부재를 감지하거나 리더가 요청에 응답하지 않으면 새로운 선출 작업이 시작된다. 선출 작업은 아래 세 단계로 구성된다.

1. 프로세스는 자신보다 높은 순위의 프로세스에 선출 메시지를 보낸다.
2. 상위 순위 프로세스가 응답할 때까지 대기하고 응답이 없으면 다음 단계를 진행한다. 응답하는 경우 자신이 알고 있는 최상위 프로세스에 다음 단계 진행을 요청한다.
3. 프로세스는 자신보다 더 높은 순위의 프로세스가 없다고 가정하고 하위 프로세스에 새로운 리더가 선출된 사실을 알린다.

- 하지만 이 방식은 네트워크 파티션 문제가 생기면 `split brain` 문제가 발생할 수 있다.
- 또 다른 문제는 상위 순위 노드에 높은 우선권을 부여한다는 점이다. 상위 순위 노드가 불안정하면 선출 작업이 무한 반복될 수 있다.
  - 높은 순위의 불안정한 노드가 자신을 리더로 선출한 직후 중단되면 재선출과 중단이 계속해서 반복되는 상황이 발생할 수 있다.
  - 이 문제는 공유된 노드의 상태를 기반으로 리더를 선출해 해결할 수 있다.

## 다음 서열로 리더 역할 승계

- 다양한 버전의 불리 알고리즘 중 하나.
  - 그다음 서열을 갖는 여러 대안 프로세스를 두고 장애 조치 시 리더 역할을 승계해 재선출 작업을 단축할 수 있다.
- 모든 리더는 리더 역할을 승계할 노드 목록을 제공한다.
  - 리더 프로세스의 장애를 감지한 프로세스는 리더가 제공한 목록에서 가장 순위가 높은 대안 프로세스에 메시지를 보내 새로운 선출 과정을 시작한다.
  - 대안 프로세스 중 하나라도 응답하면 선출 과정을 생략하고 응답한 프로세스가 새로운 리더로 선출된다.
- 만약 장애를 감지한 프로세스가 목록에서 가장 높은 순위의 프로세스라면 즉시 리더가 되고 다른 프로세스에 이 사실을 알린다.
- 결과적으로 대안 프로세스가 활성 상태라면 리더 선출에 필요한 단계가 줄어든다.

## 후보/일반 노드 최적화

- `후보 candidate` 그룹과 `일반 ordinary` 그룹을 나누는 방식.

## 초대 알고리즘 invitation algorithm

- 서로 더 높은 순위를 차지하기 위해 경쟁하는 대시 서로 자신의 그룹으로 초대.
  - 이론적으로 여러 리더가 존재할 수 있다.
  - 그룹을 병합해나간다.

## 링 알고리즘

- 모든 노드가 링 형태로 연결, 각 노드는 링의 토폴로지에 관한 정보를 가지고 있다.
- 링을 순회하며 노드에 대한 정보 수집.

> 토폴로지는 '위상수학'이라고도 불리며, 대상의 연결 관계나 배치 방식과 같은 위상적 속성을 연구하는 학문
> 
> 가장 대표적인 예는 네트워크 토폴로지
> - 버스형 (Bus Topology)
> - 스타형 (Star Topology)
> - 링형 (Ring Topology)
> - 메시형 (Mesh Topology)

## 요약

- 리더 선출 => 조정 오버헤드를 줄이고, 알고리즘의 성능을 높일 수 있다.
- 선출 작업은 비용이 높지만, 자주 수행되지 않아 시스템 성능에 큰 영향을 주지 않는다.
- 하지만 단일 리더 프로세스는 병목이 될 수 있다. 
  - 이 문제를 프로세스를 여러 그룹으로 분할하고 그룹별로 리더를 선출하거나 작업별로 다른 리더를 사용해 해결할 수 있다.
- 멀티 팍소스와 래프트를 비롯한 여러 합의 알고리즘은 리더 프로세스가 조율을 담당한다.
  - 리더 선출과 합의의 개념은 크게 다르지 않다. 리더를 선출하기 위해서는 모든 프로세스가 합의해야 한다.
  - 따라서 리더 선출 결과에 합의할 수 있다면 다른 어떤 것에 대해서도 같은 방식으로 합의할 수 있음을 의미한다.
- 리더의 정체는 프로세스가 모르는 사이에 바뀔 수 있다.
  - 따라서 각 프로세스가 개별적으로 알고 있는 리더에 대한 정보가 유효한지 확인해야 한다.
  - 이 문제는 리더 선출 알고리즘과 장애 감지 알고리즘을 같이 사용해 해결할 수 있다.
- 리더에 의존하는 대부분의 알고리즘은 여러 리더가 존재하는 것을 허용하고 리더 사이의 충돌을 최대한 빠르게 해결한다.
  - ex) 팍소스는 리더 사이에 충돌이 발생하면 2차 쿼럼을 구성해 하나의 리더를 선출. 따라서 두 개의 다른 제안자의 값이 선택되지 않도록 보장.
  - ex) 래프트는 시스템 내 다른 리더의 존재를 인지한 리더가 자신의 임기를 연장할 수 있도록 한다.
- 두 방식 모두 지속성을 위해 계속해서 리더를 선출한다.
  - 따라서 프로세스에 장애가 발생했다는 사실을 인지하는 데 너무 오랜 시간이 소요되지 않아야 한다.
  - 안정성을 포기하고 여러 리더를 허용하면 성능을 높일 수 있다. 알고리즘에 이중화 단계가 들어갈 수 있으며, 안정성은 충돌 감지 및 해결을 통해 보장한다.
