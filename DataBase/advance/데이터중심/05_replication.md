# 05장 복제

- 복제란 네트워크로 연결된 여러 장비에 동일한 데이터의 복사본을 유지한다는 의미다.
- 데이터 복제가 필요한 여러 이유
1. 지리적으로 사용자와 가깝게 데이터를 유지해 지연 시간을 줄인다.
2. 시스템의 일부에 장애가 발생해도 지속적으로 동작할 수 있게 가용성을 높인다.
3. 읽기 질의를 제공하는 장비의 수를 확장해 읽기 처리량을 늘린다.

- 단일 리더, 다중 리더, 리더 없는 복제 => 거의 모든 분산 데이터베이스는 이 세 가지 방법 중 하나를 사용한다.
- 고려해야할 다양한 트레이드오프 => 대개 설정 옵션으로 처리
  - 동기식 & 비동기식
  - 잘못된 복제본은 어떻게 처리할지

## 리더와 팔로워

- 복사본을 저장하는 각 노드를 `복제 서버 replica`
  - 모든 복제 서버에 모든 데이터가 있다는 사실을 어떻게 보장할 수 있을까?
- 가장 일반적인 해결책은 `리더 기반 복제 leader based replication`
- 읽기는 리더 & 팔로워 / 쓰기는 리더에게만 허용

### 동기식 vs 비동기식

- 복제가 동기식으로 발생하는지 비동기식으로 발생하는지 여부가 가장 중요
- 동기식 복제
  - 장점: 팔로워가 리더와 일관성 있게 최신 데이터 복사본을 가지는 것을 보장
  - 단점: (팔로워가 죽거나 네트워크 문제나 다른 어떤 이유로 인해) 동기 팔로워가 응답하지 않는다면 쓰기가 처리될 수 없다는 것이다. 리더는 모든 쓰기를 `차단 block`하고 동기 복제 서버가 다시 사용할 수 있을 때까지 기다려야 한다.
  - 따라서 모든 팔로우가 동기식인 상황은 비현실적
  - 현실적 방안: 팔로워 하나는 동기식, 그 밖에는 비동기식. (반동기식)

### 새로운 팔로워 설정

- 데이터 파일을 복사하는 것만으로는 대개 충분하지 않다.
  - 클라이언트는 지속적으로 DB에 기록, 데이터는 항상 유동적이라 표준 파일 복사본은 유효하지 않을 수 있다.
- 팔로워 설정을 중단시간 없이 수행하려면?
1. 가능하다면 전체 DB를 잠그지 않고 리더의 스냅샷을 일정 시점에 가져온다.
2. 스냅샷을 새로운 팔로워 노드에 복사
3. 팔로워는 리더에 연결해 스냅샷 이후 발생한 모든 데이터 변경을 요청한다. => 리더 복제 로그의 정확한 위치와 연관되어 있어야 한다. (postgres=`로그 일련번호 log sequence number`, MySQL=`이진로그 좌표 binlog coordinate`)
4. 팔로워가 스냅샷 이후 데이터 변경의 `미처리분 backlog`을 모두 처리했을 때 따라잡았다고 말한다. => 이제부터 리더에 발생하는 데이터 변화를 이어 처리할 수 있다.

### 노드 중단 처리

- 리더 기반 복제에서 어떻게 고가용성을 달성할 수 있을까?

#### 팔로워 장애: 따라잡기 복구

- 먼저 보관된 로그에서 결함이 발생하기 전에 처리한 마지막 트랜잭션을 알아낸다.
  - 연결이 끊어진 동안 발생한 데이터 변경을 모두 요청할 수 있다.
  - 변경이 다 적용되면 리더를 다 따라잡게 되고 이전과 같이 데이터 변경의 스트림을 계속 받을 수 있다.

#### 리더 장애: 장애 복구

- 팔로워 중 하나를 새로운 리더로 승격해야 하고 클라이언트는 새로운 리더를 쓰기를 전송하기 위해 재설정이 필요하며 다른 팔로워는 새로운 리더로부터 데이터 변경을 소비하기 시작
  - `장애 복구 failover`
- 자동 장애 복구는 보통 다음과 같은 단계로 구성
1. 리더가 장애인지 판단한다.
2. 새로운 리더를 선택한다.
3. 새로운 리더 사용을 위해 시스템을 재설정한다.

- 장애 복구 과정은 잘못될 수 있는 것 투성
1. 새로운 리더는 이전 리더가 실패하기 전에 이전 리더의 쓰기를 일부 수신하지 못할 수 있다. 새로운 리더가 선출된 다음 이전 리더가 클러스터에 다시 추가된다면 이 쓰기를 어떻게 해야 할까? => 가장 일반적인 해결책은 이전 리더의 복제되지 않은 쓰기를 단순히 폐기하는 방법
2. 쓰기를 폐기하는 방법은 데이터베이스 외부의 다른 저장소 시스템이 데이터베이스 내용에 맞춰 조정돼야 한다면 특히 위험하다. 깃허브에서 유효하지 않은 MySQL 팔로워가 리더로 승격된 사례가 존재. 새로운 리더의 카운터가 기존 리더보다 뒤처져 있어 이미 할당된 기본키를 재사용하는 문제 발생. 결국 일부 개인 데이터가 잘못된 사용자에게 공개
3. 두 노드가 모두 자신이 리더라고 믿을 수 있다. => `스플릿 브레인 split brain`. 일부 시스템에는 안전 장치로 두 리더가 감지되면 한 노드를 종료하는 매커니즘이 존재.
4. 리더가 분명히 죽었다고 판단 가능한 적절한 타임아웃은 얼마일까?

- 이 문제에 대한 쉬운 해결책은 없다.

### 복제 로그 구현

#### 구문 기반 복제

- 리더는 모든 쓰기 요청(`구문 statement`)을 기록하고 쓰기를 실행한 다음 구문 로그를 팔로워에게 전송
- 모든 구문을 팔로워에게 전달하고 각 팔로워는 클라이언트에서 직접 받은 것처럼 SQL 구문을 파싱하고 실행
- 복제가 깨질 수 있는 다양한 사례
1. `NOW()`, `RAND()` 같이 비결정적 함수를 호출하는 모든 구문은 각 복제 서버마다 다른 값을 생성할 가능성이 있다.
2. 자동 증가 컬럼 사용하는 구문. 데이터베이스게 있는 데이터에 의존. -> 구문은 각 복제 서베에서 정확히 같은 순서로 실행돼야 한다. 그렇지 않으면 효과가 달라질 수 있다.

- MySQL 5.1 이전 버전에서 `구문 기반 복제 statement-based replication`가 사용
  - 이제는 비결정성이 있다면 기본적으로 `로우 기반 복제 row-based replication`로 변경

#### 쓰기 전 로그 배송

1. 로그 구조화 저장소 엔진의 경우 로그 자체가 저장소의 주요 부분이다. 로그 세그먼트는 작게 유지되고 백그라운드로 가비지 컬렉션을 한다.
2. 개별 디스크 블록에 덮어쓰는 B 트리의 경우 모든 변경은 `쓰기 전 로그 write-ahead log, WAL`에 쓰기 때문에 고장 이후 일관성 있는 상태로 색인을 복원할 수 있다.

- 데이터베이스의 모든 쓰기를 포함하는 `추가 전용 append-only` 바이트 열이다.
  - 완전히 동일한 로그를 사용해 다른 노드에서 복제 서버를 구축
  - 리더는 디스크에 로그를 기록하는 일 외에도 팔로워에게 네트워크로 로그를 전송하기도 한다.



