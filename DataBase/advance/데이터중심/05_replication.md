# 05장 복제

- 복제란 네트워크로 연결된 여러 장비에 동일한 데이터의 복사본을 유지한다는 의미다.
- 데이터 복제가 필요한 여러 이유
1. 지리적으로 사용자와 가깝게 데이터를 유지해 지연 시간을 줄인다.
2. 시스템의 일부에 장애가 발생해도 지속적으로 동작할 수 있게 가용성을 높인다.
3. 읽기 질의를 제공하는 장비의 수를 확장해 읽기 처리량을 늘린다.

- 단일 리더, 다중 리더, 리더 없는 복제 => 거의 모든 분산 데이터베이스는 이 세 가지 방법 중 하나를 사용한다.
- 고려해야할 다양한 트레이드오프 => 대개 설정 옵션으로 처리
  - 동기식 & 비동기식
  - 잘못된 복제본은 어떻게 처리할지

---

## 리더와 팔로워

- 복사본을 저장하는 각 노드를 `복제 서버 replica`
  - 모든 복제 서버에 모든 데이터가 있다는 사실을 어떻게 보장할 수 있을까?
- 가장 일반적인 해결책은 `리더 기반 복제 leader based replication`
- 읽기는 리더 & 팔로워 / 쓰기는 리더에게만 허용

### 동기식 vs 비동기식

- 복제가 동기식으로 발생하는지 비동기식으로 발생하는지 여부가 가장 중요
- 동기식 복제
  - 장점: 팔로워가 리더와 일관성 있게 최신 데이터 복사본을 가지는 것을 보장
  - 단점: (팔로워가 죽거나 네트워크 문제나 다른 어떤 이유로 인해) 동기 팔로워가 응답하지 않는다면 쓰기가 처리될 수 없다는 것이다. 리더는 모든 쓰기를 `차단 block`하고 동기 복제 서버가 다시 사용할 수 있을 때까지 기다려야 한다.
  - 따라서 모든 팔로우가 동기식인 상황은 비현실적
  - 현실적 방안: 팔로워 하나는 동기식, 그 밖에는 비동기식. (반동기식)

### 새로운 팔로워 설정

- 데이터 파일을 복사하는 것만으로는 대개 충분하지 않다.
  - 클라이언트는 지속적으로 DB에 기록, 데이터는 항상 유동적이라 표준 파일 복사본은 유효하지 않을 수 있다.
- 팔로워 설정을 중단시간 없이 수행하려면?
1. 가능하다면 전체 DB를 잠그지 않고 리더의 스냅샷을 일정 시점에 가져온다.
2. 스냅샷을 새로운 팔로워 노드에 복사
3. 팔로워는 리더에 연결해 스냅샷 이후 발생한 모든 데이터 변경을 요청한다. => 리더 복제 로그의 정확한 위치와 연관되어 있어야 한다. (postgres=`로그 일련번호 log sequence number`, MySQL=`이진로그 좌표 binlog coordinate`)
4. 팔로워가 스냅샷 이후 데이터 변경의 `미처리분 backlog`을 모두 처리했을 때 따라잡았다고 말한다. => 이제부터 리더에 발생하는 데이터 변화를 이어 처리할 수 있다.

### 노드 중단 처리

- 리더 기반 복제에서 어떻게 고가용성을 달성할 수 있을까?

#### 팔로워 장애: 따라잡기 복구

- 먼저 보관된 로그에서 결함이 발생하기 전에 처리한 마지막 트랜잭션을 알아낸다.
  - 연결이 끊어진 동안 발생한 데이터 변경을 모두 요청할 수 있다.
  - 변경이 다 적용되면 리더를 다 따라잡게 되고 이전과 같이 데이터 변경의 스트림을 계속 받을 수 있다.

#### 리더 장애: 장애 복구

- 팔로워 중 하나를 새로운 리더로 승격해야 하고 클라이언트는 새로운 리더를 쓰기를 전송하기 위해 재설정이 필요하며 다른 팔로워는 새로운 리더로부터 데이터 변경을 소비하기 시작
  - `장애 복구 failover`
- 자동 장애 복구는 보통 다음과 같은 단계로 구성
1. 리더가 장애인지 판단한다.
2. 새로운 리더를 선택한다.
3. 새로운 리더 사용을 위해 시스템을 재설정한다.

- 장애 복구 과정은 잘못될 수 있는 것 투성
1. 새로운 리더는 이전 리더가 실패하기 전에 이전 리더의 쓰기를 일부 수신하지 못할 수 있다. 새로운 리더가 선출된 다음 이전 리더가 클러스터에 다시 추가된다면 이 쓰기를 어떻게 해야 할까? => 가장 일반적인 해결책은 이전 리더의 복제되지 않은 쓰기를 단순히 폐기하는 방법
2. 쓰기를 폐기하는 방법은 데이터베이스 외부의 다른 저장소 시스템이 데이터베이스 내용에 맞춰 조정돼야 한다면 특히 위험하다. 깃허브에서 유효하지 않은 MySQL 팔로워가 리더로 승격된 사례가 존재. 새로운 리더의 카운터가 기존 리더보다 뒤처져 있어 이미 할당된 기본키를 재사용하는 문제 발생. 결국 일부 개인 데이터가 잘못된 사용자에게 공개
3. 두 노드가 모두 자신이 리더라고 믿을 수 있다. => `스플릿 브레인 split brain`. 일부 시스템에는 안전 장치로 두 리더가 감지되면 한 노드를 종료하는 매커니즘이 존재.
4. 리더가 분명히 죽었다고 판단 가능한 적절한 타임아웃은 얼마일까?

- 이 문제에 대한 쉬운 해결책은 없다.

### 복제 로그 구현

#### 구문 기반 복제

- 리더는 모든 쓰기 요청(`구문 statement`)을 기록하고 쓰기를 실행한 다음 구문 로그를 팔로워에게 전송
- 모든 구문을 팔로워에게 전달하고 각 팔로워는 클라이언트에서 직접 받은 것처럼 SQL 구문을 파싱하고 실행
- 복제가 깨질 수 있는 다양한 사례
1. `NOW()`, `RAND()` 같이 비결정적 함수를 호출하는 모든 구문은 각 복제 서버마다 다른 값을 생성할 가능성이 있다.
2. 자동 증가 컬럼 사용하는 구문. 데이터베이스게 있는 데이터에 의존. -> 구문은 각 복제 서베에서 정확히 같은 순서로 실행돼야 한다. 그렇지 않으면 효과가 달라질 수 있다.

- MySQL 5.1 이전 버전에서 `구문 기반 복제 statement-based replication`가 사용
  - 이제는 비결정성이 있다면 기본적으로 `로우 기반 복제 row-based replication`로 변경

#### 쓰기 전 로그 배송(shipping)

1. 로그 구조화 저장소 엔진의 경우 로그 자체가 저장소의 주요 부분이다. 로그 세그먼트는 작게 유지되고 백그라운드로 가비지 컬렉션을 한다.
2. 개별 디스크 블록에 덮어쓰는 B 트리의 경우 모든 변경은 `쓰기 전 로그 write-ahead log, WAL`에 쓰기 때문에 고장 이후 일관성 있는 상태로 색인을 복원할 수 있다.

- 데이터베이스의 모든 쓰기를 포함하는 `추가 전용 append-only` 바이트 열이다.
  - 완전히 동일한 로그를 사용해 다른 노드에서 복제 서버를 구축
  - 리더는 디스크에 로그를 기록하는 일 외에도 팔로워에게 네트워크로 로그를 전송하기도 한다.

- 이 복제 방식은 PostgreSQL과 오라클에서 사용
- 가장 큰 단점은 로그가 제일 저수준의 데이터를 기술한다는 점이다.
  - WAL은 어떤 디스크 블록에서 어떤 바이트를 변경했는지와 같은 상세 정보를 포함한다. => 복제가 저장소 엔진가 밀접하게 엮임.
  - 저장소 형식을 다른 버전으로 변경한다면 대개 리더와 팔로워의 데이터베이스 소프트웨어 버전을 다르게 실행할 수 없다.
- 운영상 큰 영향
  - 팔로워가 리더보다 새로운 소프트웨어 버전을 사용하게끔 복제 프로토콜이 허용한다면 팔로워를 먼저 업그레이드함으로써 중단시간 없이 데이터베이스 소프트웨어 업그레이드 수행이 가능
  - WAL shipping과 같이 복제 프로토콜이 버전의 불일치를 허용하지 않는다면 업그레이드할 때 중단시간이 필요

#### 논리적(로우 기반) 로그 복제

- 복제 로그를 저장소 엔진 내부와 분리하기 위한 대인 하나는 복제와 저장소 엔진을 위해 다른 로그 형식을 사용하는 것이다.
  - 이 같은 종류의 복제 로그를 저장소 엔진의 (물리적) 데이터 표현과 구별하기 위해 `논리적 로그 logical log`라고 부른다.
- 관계형 데이터베이스용 논리적 로그는 대개 로우 단위로 데이터베이스 테이블에 쓰기를 기술한 코드 열이다.
1. 삽입된 로우의 로그는 모든 칼럼의 새로운 값을 포함한다.
2. 삭제된 로우의 로그는 로우를 고유하게 식별하는 데 필요한 정보를 포함한다. 보통 이것은 기본키지만 테이블에 기본키가 없다면 모든 칼럼의 예전 값을 로깅해야 한다.
3. 갱신된 로우의 로그는 로우를 고유하게 식별하는 데 필요한 정보와 모든 칼럼의 새로운 값(적어도 변경된 모든 칼럼의 새로운 값)을 포함한다.

- 여러 로우를 수정하는 트랜잭션은 여러 로그 레코드를 생성한 다음 트랜잭션이 커밋됐음을 레코드에 표시.
  - MySQL 이진 로그는 이 접근 방식을 사용
- 논리적 로그를 저장소 엔진 내부와 분리했기 때문에 하위 호환성을 더 쉽게 유지
  - 리더와 팔로워에서 다른 버전의 데이터베이스 소프트웨어나 심지어 다른 저장소 엔진을 실행할 수 있다.
- 또한 논리적 로그 형식은 외부 애플리케이션이 파싱하기 더 쉽다.
  - 사용자 정의 색인과 캐시 구축을 위해 데이터 웨어하우스 같은 외부 시스템에 데이터베이스의 내용을 전송하고자 할 때 유용
  - 이 기술을 `변경 데이터 캡처 change data capture`라 부른다.

#### 트리거 기반 복제

- 많은 관계형 데이터베이스에서 사용할 수 있는 기능인 `트리거`나 `스토어드 프로시저`를 사용한다.
- 트리거는 사용자 정의 애플리케이션 코드를 등록할 수 있게 한다.
  - 데이터베이스 시스템에서 데이터가 변경되면(쓰기 트랜잭션) 자동으로 실행된다.
  - 트리거는 데이터 변경을 분리된 테이블에 로깅할 수 있는 기회를 가진다.
  - 이 테이블로부터 데이터 변경을 외부 프로세스가 읽을 수 있다.
- 일반적으로 트리거 기반 복제는 다른 복제 방식보다 많은 오버헤드. 내장된 복제보다 버그나 제한 사항이 더 많이 발생하나 유연성 때문에 유용하다.

----

## 복제 지연 문제

- 복제는 노드 내결함성에만 필요한 것은 아니다. 확장성과 지연 시간이 또 다른 이유.
- 모든 쓰기가 단일 노드를 거쳐야 하지만 읽기 전용 질의는 어떤 복제 서버에서도 가능
- 대부분이 읽기 요청이고 쓰기가 아주 작은 비율로 구성된 작업부하라면 많은 팔로워를 만들어 팔로워 간 읽기 요청을 분산하는 매력적인 옵션
  - 이 방식을 사용하면 리더의 부하를 없애고 근처 복제 서버에서 읽기 요청을 처리
- 이런 `읽기 확장 read-scaling` 아키텍처에서는 간단히 팔로워를 더 추가함으로써 읽기 전용 요청을 처리하기 위한 용량을 늘릴 수 있다.
  - 하지만 실레로는 비동기식 복제에서만 동작
  - 동기식으로 모든 팔로워에 복제를 시도한다면 단일 노드 장애나 네트워크 중단으로 전체 시스템의 쓰기가 불가능
- 아쉽게도 애플리케이션이 비동기 팔로워에서 데이터를 읽을 때 팔로워가 뒤처진다면 지난 정보를 볼 수도 있다.
  - 명백하게 불일치가 발생
  - 이와 동시에 리더와 팔로워에 동일한 질의를 수행하면 모든 쓰기가 팔로워에 반영되지 않았기 때문에 서로 다른 결과를 얻을 수도 있다.
  - 일시적인 상태에 불과 => 팔로워는 결국 따라잡아 리더와 일치 => 이런 효과를 `최종적 일관성`이라 한다.
- "최종적"이란 용어는 의도적으로 모호하다.
  - 일반적으로 복제 서버가 얼마나 뒤처질 수 있는지에 대한 제한은 없다.
  - 정상적인 동작에서 리더에서 일어난 쓰기와 팔로워에서 반영 사이의 지연(`복제 지연`)은 실제로는 눈에 띄지 않는 아주 짧은 순간이다.
  - 하지만 시스템이 가용량 근처에서 동작하거나 네트워크 문제가 있으면 지연은 쉽게 수초에서 수 분으로 증가할 수 있다.
- 애플리케이션에서 지연이 매우 크면 불일치는 이론적인 문제가 아니라 실제 문제가 된다.

### 자신이 쓴 내용 읽기

- 사용자가 쓰기를 수행한 직후 데이터를 본다면 새로운 데이터는 아직 복제 서버에 반영되지 않았을 수 있다.
  - 사용자에게 제출된 데이터가 유실된 것처럼 보임
- 이런 상황에서는 `쓰기 후 읽기 일관성`(`자신의 쓰기 읽기 일관성`)아 필요
  - 다만, 다른 사용자에 대해서는 보장하지 않는다. 
- 쓰기 후 일관성을 구현하는 다양한 기법
1. 사용자가 수정한 내용을 읽을 때는 리더에서 읽는다. 그 밖에는 팔로워에서 읽는다.
   - 실제로 질의하지 않고 무엇이 수정됐는지 알 수 있는 방법이 필요
   - ex) 소셜 네트워크에서 사용자 프로필은 본인만 접근 => 항상 사용자 소유의 프로필은 리더에서 읽음
2. 대부분의 내용을 사용자가 편집할 가능성이 있다면 이 접근 방식은 대부분 리더에서 읽기 때문에 효율적이지 않다.
   - 이때는 다른 기준을 사용해야한다.
   - ex) 마지막 갱신 시각을 찾아서 마지막 갱신 후 1분 동안은 리더에서 모든 읽기를 수행
3. 복제 서버가 아직 최신 내용이 아닌 경우에는 다른 복제 서버가 읽기를 처리하거나 복제 서버가 따라잡을 때까지 질의를 대기
   - 클라이언트는 가장 최근 쓰기의 타임스탬프를 기억. 복제 서버가 해당 타임스탬프까지 갱신을 반영하게 함.
   - 타임스탬프는 `논리적 타임스탬프`(로그 열 숫자처럼 쓰기의 순서를 지정)거나 실제 시스템 시간(실제 시스템인 경우 동기화가 매우 중요)일 수 있다.
4. 여러 데이터센터에 분산되어 있다면 복작도가 증가 => 리더가 제공해야 하는 모든 요청은 리더가 포함된 데이터센터로 라우팅되어야 함.

- 동일한 사용자가 여러 디바이스로 서비스를 접근할 때 또 다른 문제가 발생한다.
  - 이 경우에는 `디바이스 간 cross-device` 쓰기 후 읽기 일관성이 제공돼야 한다.
- 몇 가지 문제를 추가적으로 고려해야 한다.
1. 사용자의 마지막 갱신 타임스탬프를 기억해야 하는 접근 방식은 더욱 어렵다. 메타데이터는 중앙집중식으로 관리해야 한다.
2. 다른 디바이스의 연결이 동일한 데이터센터로 라우팅된다는 보장이 없다. 리더에서 읽어야 할 필요가 있는 접근법이라면 먼저 사용자 디바이스의 요청을 동일한 데이터센터로 라우팅.

### 단조 일기

- 비동기식 팔로워에서 읽을 때 발생할 수 있는 두 번째 이상 현상은 사용자가 시간이 거꾸로 흐르는 현상을 목격할 수 있다는 것.
  - 사용자가 각기 다른 복제 서버에서 여러 읽기를 수행할 수 있기 때문이다.
- `단조 읽기 monotonic read`는 이런 종류의 이상 현상이 발생하지 않음을 보장
  - 강한 일관성보다는 덜한 보장이지만 최종적 일관성보다는 더 강한 보장
  - 데이터를 읽을 때 이전 값을 볼 수 있다. 한 사용자가 여러 번에 걸쳐 여러 번 읽어도 시간이 되돌아가는 현상을 보지 않는다는 의미. 즉, 이전에 새로운 데이터를 읽은 후에는 예전 데이터를 읽지 않는다.
- 단조 읽기를 달성하는 방법
  - 사용자의 읽기가 항상 동일한 복제 서버에서 수행되게끔 하는 것이다.
  - ex) 사용자의 ID의 해시를 기반으로 복제 서버를 선택

### 일관된 순서로 읽기

- 인과성의 위반 우려
- 만약 제3자 관찰자가 있다면?
  - 전달이 늦게될 경우 먼저 요청된 값이 나중에 보일 수 있음
- 이런 종류의 이상 현상을 방지하려면 `일관된 순서로 읽기 Consistent Prefix Read` 같은 또 다른 유형의 보장이 필요하다.
- 이는 파티셔닝된(샤딩된) 데이터베이스에서 발생하는 특징적인 문제다.
  - 많은 분산 데이터베이스에서 서로 다른 파티션은 독립적으로 동작하므로 쓰기의 전역 순서는 없다.
  - 즉, 사용자가 데이터베이스를 읽을 때 예전 상태의 일부와 새로운 상태의 일부를 함께 볼 수 있다.
- 한 가지 해결책은 서로 인과성이 있는 쓰기가 동일한 파티션에 기록되게끔 하는 방법
  - 하지만 일부 애플리케이션에서는 효율적이지 않을 수도...

### 복제 지연을 위한 해결책

- 최종적 일관성으로 작업할 때 복제 지연이 몇 분이나 몇 시간으로 증가한다면 어떻게 동작하는지 생각해 볼 가치가 있다.
- 만약 사용자에게 좋지 않은 경험이라면 쓰기 후 읽기 같은 강한 보장을 제공하게끔 시스템을 설계해야 한다.

---

## 다중 리더 복제

- 리더 기반 복제에는 주요한 단점이 하나 있다.
  - 리더가 하나만 존재하고 모든 쓰기는 해당 리더를 거쳐야 한다.
- 쓰기 처리를 하는 각 노드는 데이터 변경을 다른 모든 노드에 전달해야 한다.
  - 이 방식을 `다중 리더` 설정이라 부른다. (마스터 마스터나 액티브/액티브 복제)

### 다중 리더 복제의 사용 사례

- 단일 데이터센터 내의 다중 리더 설정은 복잡도에 비해 이점이 크지 않음.

#### 1. 다중 데이터센터 운영

- 일반적인 리더 기반 복제 설정은 리더가 하나의 데이터센터에 있고 모든 쓰기는 해당 데이터센터를 거쳐야 한다.
- 다중 리더 설정에서는 각 데이터센터마다 리더가 있을 수 있다.
  - 데이터센터 간에는 각 데이터센터의 리더가 다른 데이터센터의 리더에게 변경 사항을 복제한다.
- 다중 리더를 지원하는 DB
  - MySQL `텅스텐 리플리케이터 Tungsten Replicator`
  - PostgreSQL BDR
  - Oracle Gloden Gate

#### 비교: 다중 데이터센터 배포: 단일 리더 설정 vs 다중 리더 설정

|             | 단일 리더                                               | 다중 리더                                                                 |
|:------------|:----------------------------------------------------|:----------------------------------------------------------------------|
| 성능          | 모든 쓰기는 인터넷을 통해 리더가 있는 데이터센로 이동<br>쓰기에 지연 시간을 상당히 소모 | 쓰기를 로컬 데이터센터에서 처리한 다음 비동기 방식으로 데이터센터에 복제<br>데이터센터 간 네트워크 지연은 사용자에게 은닉 |
| 데이터센터 중단 내성 | 데이터센터가 고장하면 다른 데이터센터의 한 팔로워를 리더로 승진                 | 각 데이터센터가 독립적으로 운영                                                     |
| 네트워크 문제 내셩  | 데이터센터 내 연결의 쓰기는 동기식이기 때문에 데이터센터 내 연결 문제에 매우 민감      | 비동기 복제를 사용하여 네트워크 문제에 보다 잘 견딘다. 일시적인 네트워크 중단에도 쓰기 처리는 진행된다.           |

- 다중 리더의 큰 단점
  - 동일한 데이터를 다른 두 개의 데이터 센터에서 동시에 변경 => 이때 발생하는 쓰기 충돌을 반드시 해소

#### 2. 오프라인 작업을 하는 클라이언트

- 인터넷 연결이 끊어진 동안 애플리케이션이 계속 동작해야 하는 경우

#### 3. 협업 편집

- 실시간 협업 편집 애플리케이션
- 사용자가 편집하기 전에 문서의 잠금을 얻어야.
- 하지만 더 빠른 협업을 위해 변경 단위를 매우 작게 해서 잠금을 피할 수도 있다.


### 쓰기 충돌 다루기

- 다중 리더 복제에서 가장 큰 문제

#### 동기 대 비동기 충돌 감지

- 단일 리더는 순서를 정해 block할 수 있지만, 다중 리더는 두 쓰기는 모두 성공하며 충돌 이후 특정 시점에서 비동기로만 감지한다.
- 이론적으로 충돌 감지는 동기식으로 만들 수 있다.
  - 쓰기가 성공한 사실을 모든 복제 서버가 쓰기를 복제하기를 기다리면 된다.
  - 하지만 다중 리더의 주요 장점을 잃어버리게 된다.

#### 충돌 회피

- 제일 간단한 방법
  - 특정 사용자의 요청이 항상 같은 "홈" 데이터센터로 가도록 라우팅
- 하지만 때때로 한 데이터센터가 고장 나서 트래픽을 다른 데이터센터로 다시 라우팅해야 하거나 사용자가 다른 지역으로 이동해 현재는 다른 데이터센터가 가깝다면 레코드를 위해 지정된 리더를 변경하고 싶을 수도 있다.
  - 이런 상황에서는 충돌 회피가 실패

#### 일관된 상태 수렴

- 단일 리더 데이터베이스는 순차적인 순서로 쓰기를 적용
  - 여러 번 갱신 => 마지막 쓰기가 필드의 최종 값으로 결정
- 다중 리더 설정에서는 쓰기 순서가 정해지지 않아 최종 값이 무엇인지 명확하지 않다.
  - 여러 갱신의 순서가 정확하지 않다. (여러 리더에서 동시다발적으로 전달될 수 있기 때문)
- 모든 복제 계획은 모든 복제 서버가 최종적으로 동일하다는 사실을 보장해야 한다.
  - 따라서 데이터베이스는 `수렴 convergent` 방식으로 충돌을 해소해야 한다.
  - 이는 모든 변경이 복제돼 모든 복제 서버에 동일한 최종 값이 전달되게 해야 한다는 의미
- 수렴 충돌 해소를 달성하는 방법은 다양하다.
1. 각 쓰기에 고유 ID를 부여하고, 가장 높은 ID를 가진 쓰기를 고른다. 타임스탬프를 사용하는 경우 `최종 쓰기 승리 last write wins, LWW` => 대중적이지만 유실 위험
2. 각 복제 서버에 고유 ID를 부여하고 높은 숫자의 복제 서버에서 생긴 쓰기가 낮은 숫자의 복제 서버에서 생긴 쓰기보다 항상 우선적으로 적용 => 또한 유실 가능성 있음
3. 어떻게든 값을 병합. 사전 순으로 정렬한 후 연결. ("B", "C" => "B/C")
4. 명시적 데이터 구조에 충돌을 기록해 모든 정보를 보존. 나중에 충돌을 해소하는 애플리케이션 코드를 작성

#### 사용자 정의 충돌 해소 로직

- 대부분의 다중 리더 복제 도구는 애플리케이션 코드를 사용해 충돌 해소 로직을 작성
- 쓰기나 읽기 수행 중에 실행
- 쓰기 수행 중
  - 시스템이 충돌을 감지하자마자 충돌 핸들러 호출
  - 핸들러는 일반적으로 사용자에게 충돌 내용을 표시하지 않는다.
  - 그리고 백그라운드 프로세스에서 빠르게 실행
- 읽기 수행 중
  - 충돌을 감지하면 모든 충돌 쓰기를 저장
  - 다음 번 데이터를 읽을 때 이런 여러 버전의 데이터가 애플리케이션에 반환
  - 사용자에게 충돌 내용을 보여주거나 자동으로 충돌을 해소. 충돌을 해소한 결과는 다시 데이터베이스에 기록

> #### 자동 충돌 해소
> - `충돌 없는 복제 데이터타입 conflict-free replicated datatype, CRDT`
>   - set, map, 정렬 목록, 카운터 등을 위한 데이터 구조의 집합
>   - 동시에 여러 사용자가 편집할 수 있고 합리적인 방법으로 충돌을 자동 해소
> - `병합 가능한 영속 데이터 구조 mergeable persistent data structrue`
>   - 명시적으로 히스토리를 추적하고 삼중 병합 함수를 사용
> - `운영 변환 operational transformation`
>   - 이더패드와 구글 독스 같은 협업 편집 앱의 충돌 해소 알고리즘
>   - 특히 텍스트 문서를 구성하는 문자 목록과 같은 정렬된 항목 목록의 동시 편집을 위해 설계

#### 충돌은 무엇인가?

- 다양한 종류의 충돌들..

### 다중 리더 복제 토폴로지

- `복제 토폴로지`는 쓰기를 한 노드에서 다른 노드로 전달하는 통신 경로를 설명
  - 원형, 별 모양, 전체 연결 토폴로지 등
- MySQL은 기본적으로 `원형 토폴로지 circular topology`만 제공
- 원형과 별 모양은 무한 복제 루프를 방지하기 위해 각 노드에는 고유 식별자가 있고 복제 로그에서 각 쓰기는 거치는 모든 노드의 식별자가 태깅된다.
  - 자신의 식별자가 이미 태깅된 경우 노드가 이미 처리한 사실을 알기 때문에 데이터 변경 사항을 무시
- 원형과 별 모양 토폴로지의 문제점은 하나의 노드에 장애가 발생하면 장애가 다른 노드 간 복제 메시지 흐름에 방해를 준다는 것이다.
  - 즉 해당 노드가 복구될 때까지 통신을 할 수 없다.
  - 토폴로지는 장애 노드를 회피하게끔 재설정할 수 있다. 그러나 대부분의 배포에서 이런 재설정은 수동으로 수행해야 한다.
  - 메시지가 여러 경로를 따라 이동할 수 있으면 `단일 장애점 single point of failure`을 피할 수 있기 때문에 빽빽하게 연결한 토폴로지의 내결함성이 훨씬 좋다.
- 그렇다고 전체 연결 토폴로지가 만능은 아니다.
  - "추월" 문제 => `일관된 순서로 읽기`가 필요한 인과성 문제
- 이런 이벤트를 올바르게 정렬하기 위해 `버전 벡터 version vector`라고 하는 기법을 사용할 수 있다.
  - 하지만 많은 다중 리더 복제 시스템에서 충돌 감지 기법은 제대로 구현되지 않았다.
  - PostgreSQL의 BDR은 쓰기의 인과적 순서를 제공하지 않으며, MySQL의 텅스텐 리플리케이션은 충돌을 감지하기 위한 시도조차 하지 않는다.

----

## 리더 없는 복제

- 리더는 쓰기를 처리하는 순서를 정하고 팔로워는 동일한 순서로 리더의 쓰기를 적용한다.
- 일부 데이터 저장소 시스템은 리더의 개념을 버리고 모든 복제 서버가 클라이언트로부터 쓰기를 직접 받을 수 있게 허용하는 접근 방식을 사용하기도 한다.
  - 초기 복제 데이터 시스템은 대부분 리더가 없었다. 이 개념은 관계형 데이터베이스가 우세한 시대에는 대부분 잊혀졌다.
  - 리더 없는 복제는 아마존이 내부 `다이나모 Dynamo` 시스템에서 사용한 후 다시 데이터베이스용 아키텍처로 유행했다.
  - 리악, 카산드라, 볼드모트 등은 다이나모에 영감을 받음. 이런 종류의 데이터베이스를 `다이나모 스타일`이라 한다.
- 코디네이터 노드가 클라이언트를 대신해 이를 수행하기도 한다.
  - 하지만 리더 데이터베이스와 달리 코디네이터 노드는 특정 순서로 쓰기를 수행하지 않는다.

### 노드가 다운됐을 때 데이터베이스에 쓰기

- 복제 서버 중 하나를 사용할 수 없다고 가정 => 리더 기반 설정에서 쓰기 처리르 계속 하려면 장애 복구를 실행해야 한다.
- 반면 리더 없는 설정에서는 장애 복구가 필요하지 않다.
  - 만약 사용 불가능한 복제 서버가 쓰기를 놓친다면? => 클라이언트는 응답으로 `오래된 outdated` 값을 얻을 수 있다.
  - 이 문제를 해결하기 위해 클라이언트가 데이터베이스에서 읽을 때 하나의 복제 서버로 요청을 보내지 않고 읽기 요청을 병렬로 여러 노드에 전송한다.

#### 읽기 복구와 안티 엔트로피

- 복제 계획은 최종적으로 모든 데이터가 모든 복제 서버에 복사된 것을 보장해야 한다.
  - 사용 불가능한 노드가 온라인 상태가 된 후 누락된 쓰기를 어떻게 따라 잡아야 할까?
- 다이나모 스타일 데이터스토어는 두 가지 메커니즘을 주로 사용
1. 읽기 복구
- 병렬로 읽기를 수행하면 오래된 응답을 감지할 수 있다. 복제 서버가 값이 오래된 값이라는 사실을 알면 해당 복제 서버에 새로운 값을 다시 기록한다.
2. 안티 엔트로피 처리
- 백그라운드 프로세스를 두고 복제 서버 간 데이터 차이를 지속적으로 찾아 누락된 데이터를 하나의 복제 서버에서 다른 서버로 복사한다.
- 안티 엔트로피 처리는 특정 순서로 쓰기를 복사하기 때문에 이 데이터가 복사되기까지 상당한 지연이 있을 수 있다.

#### 읽기와 쓰기를 위한 정족수

- `n`개의 복제 서버가 있을 때 모든 쓰기는 `w`개의 노드에서 성공해야 쓰기가 확정되고 모든 읽기는 최소한 `r`개의 노드에 질의
  - `w + r > n`이면 읽을 때 최신 값을 얻을 것으로 기대 => 최소한 `r`개의 노드 중 하나에서 최신 값을 읽을 수 있기 때문.
  - `r`과 `w`를 따르는 읽기와 ㅆ기를 정족수 읽기와 쓰기라고 부른다.
- 다이나모 스타일 데이터베이스에서 `n`, `w`, `r` 파라미터는 대개 설정 가능하다.
  - 일반적인 선택은 `n`을 홀수(보통 3이나 5)로 하고 `w = r = (n+1) / 2`(반올림)로 설정한다.
- 정족수 조건이 `w + r > n`이면 다음과 같이 사용 불가능한 노드를 용인한다.
1. `w < n`이면 노드 하나를 사용할 수 없어도 여전히 쓰기를 처리할 수 있다.
2. `r < n`이면 노드 하나를 사용할 수 없어도 여전히 읽기를 처리할 수 있다.
3. `n = 3`, `w = 2`, `r = 2`이면 사용 불가능한 노드 하나를 용인한다.
4. `n = 5`, `w = 3`, `r = 3`이면 사용 불가능한 노드 둘을 용인한다.
5. 일반적으로 읽기와 쓰기는 항상 모든 `n`개의 복제 서버에 병렬로 전송한다. 파라미터 w와 r은 얼마나 많은 노드를 기다릴지 결정한다. 즉 읽기나 쓰기가 성공했다고 간주하려면 `n`개의 노드 중 몇 개의 노드에서 성공을 확인해야 하는지를 나타낸다.

- 필요한 `w`나 `r`개 노드보다 사용 가능한 노드가 적다면 쓰기나 읽기는 에러를 반환한다.

### 정족수 일관성의 한계

- `n`개의 복제 서버가 있고 `w + r > n`이 되게끔 `w`와 `r`을 선택한다면 일반적으로 모든 읽기는 키의 최신 값을 반환할 것을 기대한다.
  - 즉 읽은 노드 중에는 최신 값을 가진 노드가 하나 이상 있어야 한다.
- 보통 `r`과 `w` 값으로 노드의 과반수를 선택한다. `n/2` 노드 장애까지 허용해도 `w + r > n`이 보장되기 때문이다.
- 또한 `w`과 `r`을 더 작은 수로 설정해 `w + r <= n`(즉 정족수 조건은 충족되지 않음)이 되게끔 설정할 수도 있다.
- `w`와 `r`이 작을수록 오래된 값을 읽을 확률이 높다.
  - 최신 값을 가진 노드가 읽을 노드에 포함되지 않을 가능성이 높기 때문이다.
- 하지만 `w + r > n`인 경우에도 오래된 값을 반환하는 에지 케이스가 있다.
1. 느슨한 정족수를 사용 => `w`개의 쓰기는 `r`개의 읽기와 다른 노드에서 수행될 수 있으므로 `r`개의 노드와 `w`개의 노드가 겹치는 것을 보장하지 않는다.
2. 두 개의 쓰기가 동시에 발생하면 어떤 쓰기가 먼저 일어났는지 분명하지 않다. 이 경우 안전한 해결책은 동시 쓰기를 합치는 방법밖에 없다.
3. 쓰기가 읽기와 동시에 발생하면 쓰기는 일부 복제 서버에서만 반영. 읽기가 예전 값 또는 최신 값을 반환하는지 여부가 분명하지 않다.
4. 전체에서 성공한 서버가 `w` 복제 서버보다 적다면 성공한 복제 서버에서는 롤백하지 않는다. 이는 쓰기가 실패한 것으로 보고되면 이어지는 읽기에 해당 쓰기 값이 반환될 수도 있고 아닐 수도 있다는 의미다.
5. 새 값을 저장한 노드가 고장나면? => 예전 값을 가진 다른 복제 서버에서 해당 데이터가 복원되고 새로운 값을 저장한 복제 서버 수가 `w`보다 낮아져 정족수 조건이 깨진다.

- 따라서 정족수가 읽기 시 최근에 쓴 값을 반환하게끔 보장하지만 실제로는 그렇게 간단하지 않다.

#### 최신성 모니터링

- 데이터베이스가 최신 결과를 반환하는지 여부를 모니터링하는 일은 중요하다.
  - 복제가 명확히 뒤처진다면 원인을 조사할 수 있게 알려줘야 한다.
- 리더의 현재 위치에서 팔로워의 현재 위치를 빼면 복제 지연량을 측정할 수 있다.
- 하지만 리더 없는 복제 시스템에서는 쓰기가 적용된 순서를 고정할 수 없어 모니터링이 조금 더 어렵다.
  - 읽기 복구만 사용한다면 자주 읽히지 않는 값이 얼마나 오래된 것인지에 대한 제한이 없어 오래된 복제 서버에서 반환된 값은 아주 오래된 값일 수 있다.
- 최종적 일관성은 의도적으로 모호한 보장이지만 운용성을 위해서는 "최종적"을 정량화할 수 있어야 한다.

### 느슨한 정족수와 암시된 핸드오프

- 적절히 설정된 정족수가 있는 데이터베이스는 장애 복구 없이 개별 노드 장애를 용인한다.
- 높은 가용성과 낮은 지연 시간이 필요하다. 가끔 오래된 값 읽기를 허용하는 사용 사례에는 리더 없는 복제 기능을 가진 데이터베이스가 매력적이다.
- 하지만 정족수는 내결함성이 없다.
- 노드가 `n`개 이상인 대규모 클러스터에서 클라이언트는 네트워크 장애 상황에서 일부 데이터베이스 노드에 연결될 가능성이 있다.
- 트레이드오프
1. `w`나 `r` 노드 정족수를 만족하지 않는 모든 요청에 오류를 반환하는 편이 좋을까?
2. 아니면 일단 쓰기를 받아들이고 값이 보통 저장되는 `n`개 노드에 속하지는 않지만 연결할 수 있는 노드에 기록할까?

- 후자를 느슨한 정족수라 부른다.
- 네트워크 장애 상황이 해제되면 한 노드가 다른 노드를 위해 일시적으로 수용한 모든 쓰기를 해당 "홈" 노드로 전송한다. 이 방식을 `암시된 핸드오프`라 부른다.
- 느슨한 정족수는 쓰기 가용성을 높이는 데 특히 유용하다.

#### 다중 데이터센터 운영

- 리더 없는 복제도 동시 쓰기 충돌, 네트워크 중단, 지연 시간 급증을 허용하기 때문에 다중 데이터센터 운영에 적합
- 카산드라와 볼드모트는 일반적인 리더 없는 모델에 다중 데이터센터 지원을 구현 => `n`개의 복제 서버 수에는 모든 데이터센터의 노드가 포함
  - 데이터센터간 연결의 지연과 중단에 영향을 받지 않음
- 리악은 클라이언트와 데이터베이스 간 모든 연결이 하나의 데이터센터의 로컬에서 이뤄지게 하기 때문에 `n`은 하나의 데이터센터 안에 있는 복제 서버 수를 나타냄

### 동시 쓰기 감지

- 다이나모 스타일 데이터베이스 => 여러 클라이언트가 동시에 같은 키에 쓰는 것을 허용 => 엄격한 정족수를 사용하더라도 충돌이 발생
  - 다중 리더 복제와 유사

#### 최종 쓰기 승리 (동시 쓰기 버리기)

- 쓰기에 타임스탬프를 붙여 가장 "최신"이라는 의미로 가장 큰 타임스탬프를 선택하고 예전 타임스탬프를 가진 쓰기는 무시
- `최종 쓰기 승리 LWW`라 부르는 충돌 해소 알고리즘은 카산드라에서 유일하게 제공하는 충돌 해소 방법, 리악에서는 선택적 기능
- LWW는 최종적 수렴 달성이 목표지만 지속성을 희생
- 쓰기 중 하나만 남고 다른 쓰기는 조용히 무시
- 캐싱과 같이 손실된 쓰기를 허용하는 상황
  - 손실된 데이터를 허용하지 않는다면 LWW가 충돌 해소에 적합하지 않다.
- LWW로 데이터베이스를 안전하게 사용하는 유일한 방법은 키를 한번만 쓰고 이후에는 불면 값으로 다루는 것
  - 카산드라를 사용할 때 추천하는 방법은 키로 UUID를 사용해 모든 쓰기 작업에 고유한 키를 부여

#### "이전 발생" 관계와 동시성

- 작업 B가 작업 A에 대해서 알거나 A에 의존적이거나 어떤 방식으로든 A를 기반으로 한다면 작업 A는 작업 B의 `이전 발생 happens-before`
  - 단순히 동시 작업
- 한 작업이 다른 작업 전에 발생한다면 나중 작업은 이전 작업을 덮어쓸 수 있지만 작업이 동시에 발생하면 충돌을 해소해야 한다.

#### 이전 발생 관계 파악하기

- 동시에 발생했는지, 하나가 이전에 발생했는지 여부를 결정하는 알고리즘
- 서버는 버전 번호를 보고 두 작업이 동시에 수행됐는지 여부를 결정할 수 있으므로 값 자체를 해석할 필요는 없다.
  - 따라서 값을 데이터 구조로 사용할 수 있다.
- 알고리즘 동작 원리
1. 서버가 모든 키에 대한 버전 번호를 유지하고 키를 기록할 때마다 버전 번호를 증가시킨다. 기록한 값은 새로운 버전 번호를 가지고 저장된다.
2. 클라이언트가 키를 읽을 때는 서버는 최신 버전뿐만 아니라 덮어쓰지 않은 모든 값을 반환한다. 클라이언트는 쓰기 전에 키를 읽어야 한다.
3. 클라이언트가 키를 기록할 때는 이전 읽기의 버전 번호를 포함해야 하고, 이전 읽기에서 받은 모든 값을 함께 합쳐야 한다.
4. 서버가 특정 버전 번호를 가진 쓰기를 받을 때 해당 버전 이하 모든 값을 덮어쓸 수 있다. 하지만 이보다 높은 버전 번호의 모든 값은 유지해야 한다.

#### 동시에 쓴 값 병합

- 이 알고리즘은 어떤 데이터도 자동으로 삭제되지 않음을 보장하지만 불행히도 클라이언트가 추가적으로 작업을 수행해야 한다.
  - 클라이언트는 동시에 쓴 값을 합쳐 정리해야 한다.
  - 리악은 이런 동시 값을 `형제 sibling` 값이라 부른다.
- 형제를 병합하는 합리적인 접근 방식은 합집합을 취하는 것
- 제거할 때 데이터베이스에서 단순히 삭제하면 안 된다.
  - 그 대신 시스템은 형제를 병합할 때 상품을 제거했음을 나타내기 위해 해당 버전 번호에 표시를 남겨둬야 한다.
  - 이런 삭제 표시를 `툼스톤`이라 한다.
- 리악의 데이터타입 지원은 합리적인 방법으로 형제를 자동 병합할 수 있는 CRDT라는 데이터 구조군을 사용한다.

#### 버전 벡터

- 단일 버전 번호는 다중 복제본의 동시 쓰기를 받아들일 때는 충분하지 않다.
  - 키당 버전 번호뿐만 아니라 복제본당 버전 번호도 사용해야 한다.
- 모든 복제본의 버전 번호 모음을 `버전 벡터 version vector`라 부른다.
  - 가장 흥미로운 방식은 리악 2.0에서 사용하는 `도티드 버전 벡터 dotted version vector`
- 리악은 버전 벡터를 `인과성 컨텍스트 causal context`라 부르는 문자열로 부호화
  - 데이터베이스는 덮어쓰기와 동시 쓰기를 구분할 수 있다.

> #### 버전 벡터와 벡터 시계
> - 두 개념은 완전히 같지는 않다.
