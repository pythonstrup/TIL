# 03 애그리거트

## 1. 개요

- 개별 객체 수준에서 모델을 바라보면 상위 수준에서 관계를 파악하기 어렵다.
  - 100개 이상의 테이블을 한 장의 ERD에 모두 표시하면 개별 테이블 간의 관계를 파악하느라 큰 틀에서 데이터 구조를 이해하는 데 어려움을 겪게 되는 것처럼, 도메인 객체 모델이 복잡해지면 개별 구성요소 위주로 모델을 이해하게 되고 전반적인 구조나 큰 수준에서 도메인 간의 관계를 파악하기 어려워진다.
- 주요 도메인 요소 간의 관계를 파악하기 어렵다는 것은 코드를 변경하고 확장하는 것이 어려워진다는 것을 의미한다.
  - 세부적인 모델만 이해한 상태로는 코드를 수정하는 것이 꺼려지기 때문에 코드 변경을 최대한 회피하는 쪽으로 요구사항을 협의하게 된다.
- 복잡한 도메인을 이해하고 관리하기 쉬운 단위로 만들려면 상위 수준에서 모델을 조망할 수 있는 방법이 필요한데, 그 방법이 바로 애그리거트다.
  - 수많은 객체를 애그리거트로 묶어서 바라보면 상위 수준에서 도메인 모델 간의 관계를 파악할 수 있다.
- 애그리거트는 모델을 이해하는 데 도움을 줄 뿐만 아니라 일관성을 관리하는 기준도 된다.
  - 모델을 보다 잘 이해할 수 있고 애그리거트 단위로 일관성을 관리하기 때문에, 애그리거트는 복잡한 도메인을 단순한 구조로 만들어준다.
  - 복잡도가 낮아지는 만큼 도메인 기능을 확장하고 변경하는 데 필요한 노력도 줄어든다.
- 애그리거트는 관련된 모델을 하나로 모은 것 => 한 애그리거트에 속한 객체는 유사하거나 동일한 라이프 사이클을 갖는다.
  - 경계를 설정할 때 기본이 되는 것은 도메인 규칙과 요구사항이다.
- 처음 도메인 모델을 만들기 시작하면 큰 애그리거트로 보이는 것들이 많지만, 도메인에 대한 경험이 생기고 도메인 규칙을 제대로 이해할수록 애그리거트의 실제 크기는 줄어든다.
  - 저자의 경험) 다수의 애그리거트가 한 개의 Entity 객체만 갖는 경우가 많았고, 두 개 이상의 Entity로 구성되는 애그리거트가 드물었다.

----

## 2. 애그리거트 루트

- 애그리거트는 여러 객체로 구성되기 때문에 한 객체만 사태가 정상이면 안 된다.
  - 도메인 규칙을 지키려면 애그리거트에 속한 모든 객체가 정상 상태를 가져야 한다.
  - 애그리거트에 속한 객체가 일관된 상태를 유지하려면 애그리거트 전체를 관리할 주체가 필요한데, 이 책임을 지는 것이 바로 애그리거트의 Root Entity다.

### 2-1. 도메인 규칙과 일관성

- 애그리거트 루트는 단순히 애그리거트에 속한 객체를 포함하는 것으로 끝나는 것은 아니다.
  - 핵심은 애그리거트의 일관성이 깨지지 않도록 하는 것이다. 이를 위해 루트는 애그리거트가 제공해야 할 도메인 기능을 구현한다.
  - 애그리거트 외부에서 애그리거트에 속한 객체를 직접 변경하면 안 된다. 이것은 애그리거트 루트가 강제하는 규칙을 적용할 수 없어 모델의 일관성을 깨는 원인이 된다.
- 불필요한 중복을 피하고 애그리거트 루트를 통해서만 도메인 로직을 구현하게 만들려면 도메인 모델에 대해 다음의 두 가지를 습관적으로 적용해야 한다.
1. 단순히 필드를 변경하는 set 메소드를 `public`으로 만들지 않는다.
2. Value 타입은 불변으로 구현한다.

- 공개 set 메소드는 도메인의 의미나 의도를 표현하지 못하고 도메인 로직을 도메인 객체가 아닌 응용 영역이나 표현 영역으로 분산시킨다.
  - 도메인 로직이 한 곳에 응집되지 않으므로 코드를 유지 보수할 대에도 분석하고 수정하는 데 더 많은 시간이 필요하다.
  - `public set`만 없어도 일관성이 깨질 가능성이 줄어든다. 의미가 더 잘 드러나는 이름을 사용하자.
- Value 객체가 불변이면 Value 객체의 값을 변경하는 방법은 새로운 Value 객체를 할당하는 것뿐이다.
  - 애그리거트 루트가 제공하는 메소드에 새로운 Value 객체를 전달해서 값을 변경하는 방법으로 강제하는 것이다.

### 2-2. 애그리거트 루트의 기능 구현

- 애그리거트 루트는 애그리거트 내부의 다른 객체를 조합해서 기능을 완성한다.
- 애그리거트 루트가 구성요소의 상태만 참조하는 것은 아니다. 기능 실행을 위임하기도 한다.
  - 보통 한 애그리거트에 속하는 모델은 `package-private`이나 `protected` 제한자를 사용하여 애그리거트 외부에서 상태 변경하는 것을 방지한다.

### 2-3. 트랜잭션 범위

- 트랜잭션 범위는 작을수록 좋다.
  - 테이블 개수가 많아진다. => 잠금 대상이 많아진다. => 동시에 처리할 수 있는 트랜잭션 개수가 줄어든다. => 전체적인 성능을 떨어뜨린다.
- 한 트랜잭션에서는 웬만하면 한 개의 애그리거트만 수정하자!
  - 한 트랜잭션에서 두 개 이상의 애그리거트를 수정하면 트랜잭션 충돌이 발생할 가능성이 높아진다.
  - 또한 전체 처리량도 떨어지게 된다.
- 또한 한 애그리거트에서 다른 애그리거트의 상태를 변경하는 것도 삼가하자. (결합도 증가 => 수정 비용 증가)
  - 애그리거트는 최대한 서로 독립적이어야 한다. 
  - 부득이하게 한 트랜잭션에서 두 개 이상의 애그리거트를 수정해야 한다면 애그리거트에서 다른 애그리거트를 직접 수정하지 말고 응용 서비스에서 두 애그리거트를 수정하도록 구현한다.
- 이벤트를 활용하면 한 트랜잭션에서 한 개의 애그리거트를 수정하면서도 동기나 비동기로 다른 애그리거트의 상태를 변경하는 코드를 작성할 수 있다.
- 다음과 같은 경우에는 한 트랜잭션에서 두 개 이상의 애그리거트를 변경하는 것을 고려할 수 있다.
1. 팀 표준: 팀이나 조직의 표준에 따라 사용자 유스케이스와 관련된 응용 서비스의 기능을 한 트랜잭션으로 실행해야 하는 경우가 있다.
2. 기술 제약: 기술적으로 이벤트 방식을 도입할 수 없는 경우 한 트랜잭션에서 다수의 애그리거트를 수정해서 일관성을 처리해야 한다.
3. UI 구현의 편리: 운영자의 편리함을 위해 주문 목록 화면에서 여러 주문의 상태를 한 번에 변경하고 싶을 것이다. 이 경우 한 트랜잭션에서 여러 주문 애그리거트의 상태를 변경해야 한다.

----

## 3. Repository와 애그리거트

- 애그리거는 개념상 완전한 한 개의 도메인 모델을 표현하므로 객체의 영속성을 처리하는 Repository는 애그리거트 단위로 존재한다.
  - ex) `Order`가 애그리거트 루트, `OrderLine`은 애그리거트에 속하는 구성 요소이므로 `Order`를 위한 Repository만 존재.
- Repository는 보통 다음의 두 메소드를 기본으로 제공한다.
1. `save`: 애그리거트 저장.
2. `findById`: ID로 애그리거트를 구함.

- 두 메소드 외에 필요에 따라 다양한 조건으로 애그리거트를 검색하는 메소드나 애그리거트를 삭제하는 메소드를 추가할 수 있다.
- 어떤 기술을 사용해서 Repository를 구현하느냐에 따라 애그리거트의 구현도 영향을 받는다.
  - JPA, 레거시 DB 등
- Repository가 완전한 애그리거트를 제공하지 않으면 필드나 값이 올바르지 않아 애그리거트의 기능을 실행하는 도중에 `NullPointerException`과 같은 문제가 발생할 수 있다.
- 저장소는 여러 가지가 될 수 있다. RDBMS, NoSQL 등
  - 저장소로 뭘 사용하든지 애그리거트의 상태가 변경되면 모든 변경을 원자적으로 저장소에 반영해야 한다.
  - 애그리거트에서 두 개의 객체를 변경했는데 저장소에는 한 객체에 대한 변경만 반영되면 데이터 일관성이 깨지므로 문제가 된다.

----

## 4. ID를 이용한 애그리거트 참조

- 애그리거트도 다른 애그리거트를 참조한다.
  - 보통 애그리거트 루트가 다른 애그리거트 루트를 참조하는 형식이다.
- 필드를 이용해서 다른 애그리거트를 직접 참조하는 것은 개발자에게 구현의 편리함을 제공한다.
  - ORM 덕분.
- 하지만 필드를 이용한 애그리거트 참조는 다음과 같은 문제를 야기할 수 있다.
1. 편한 탐색 오용
2. 성능에 대한 고민
3. 확장 어려움

- 애그리거트를 직접 참조할 때 발생할 수 있는 가장 큰 문제는 편리함을 오용할 수 있다는 것이다.
  - 한 애그리거트 내부에서 다른 애그리거트 객체에 접근할 수 있으면 다른 애그리거트의 상태를 쉽게 변경할 수 있게 된다.
  - 트랜잭션 범위에서 언급한 것처럼 한 애그리거트가 관리하는 범위는 자기 자신으로 한정해야 한다.
- 또한 성능과 관련된 여러 가지 고민을 해야 한다.
  - JPA를 사용하면 지연 로딩이나 즉시 로딩을 사용하게 된다. 두 로딩 방식 중 무엇을 사용할지는 애그리거트의 어떤 기능을 사용하느냐에 따라 달라진다.
- 마지막으로 확장이 문제다.
  - 초기에는 단일 서버에 단일 DBMS로 서비스를 제공하는 것이 가능하다. 하지만 유저가 많아진다면?
  - 트래픽이 증가하면 자연히 부하를 분산하기 위해 하위 도메인별로 시스템을 분리하기 시작한다. 이 과정에서 하위 도메인마다 서로 다른 DBMS를 사용할 때도 있다.
  - 심지어, 다른 종류의 저장소를 사용하게 될 수도 있다.
- 이런 3가지 문제를 완화하는 방법은 ID를 이용해서 다른 애그리거트를 참조하는 것이다.
  - 객체가 참조로 연결되지 않고, 한 애그리거트에 속한 객체들만 참조로 연결된다.
  - 애그리거트의 경계를 명확히 하고 애그리거트 간 물리적인 연결을 제거. => 모델의 복잡도 낮아짐. 응집도 높아짐.
  - 응용 서비스에서 필요한 애그리거트를 로딩하므로 애그리거트 수준에서 지연 로딩을 하는 것과 동일한 결과를 만든다.

### 4-1. ID를 이용한 참조와 조회 성능

- 여러 애그리거트를 읽을 때 조회 속도가 문제 될 수 있다.
  - 조인을 통해 한 번에 모든 데이터를 가져올 수 있음에도 불구하고 각 항목별로 읽어오는 쿼리를 실행하게 된다. (N+1 문제)
- ID 참조 방식을 사용하면서 N+1 조회와 같은 문제가 발생하지 않도록 하려면 조회 전용 쿼리를 사용하면 된다.
  - 별도의 DAO를 만들고 DAO의 조회 메소드에서 조인을 이용해 한 번의 쿼리로 필요한 데이터를 로딩하면 된다.
- 애그리거트마다 서로 다른 저장소를 사용하고 있다면 한 번의 쿼리로 관련 애그리거트를 조회할 수 없다.
  - 이때는 조회 성능을 높이기 위해 캐시를 적용하거나 조회 전용 저장소를 따로 구성한다.
  - 코드가 복잡해지기는 하지만, 시스템의 처리량을 높일 수 있다는 장점이 있다.
  - 특히 한 대의 DB 장비로 대응할 수 없는 수준의 트래픽이 발생하는 경우 캐시나 조회 전용 저장소는 필수로 선택해야 하는 기법이다.

----

## 5. 애그리거트 간 집합 연관

- `1:N`과 `N:M` 연관
  - `컬렉션 Collection`을 이용한 연관
- `1:N` 관계를 사용하는데, `N`이 수만 개 정도로 많다면 코드를 실행할 때마다 실행 속도가 급격히 느려질 수 있다.
  - 따라서 성능을 위해 개념적으로는 애그리거트 간에 관계가 있더라도 실제 구현에는 반영하지 않는다.
  - ID를 이용한 참조로 대체!

----

## 6. 애그리거트를 팩토리로 사용하기

- 중요한 도메인 로직 처리인 생성 기능이 응용 서비스에 노출되는 경우?
- 이 도메인 기능을 넣기 위해 별도의 도메인 서비스나 팩토리 클래스를 만들 수도 있지만, 이 기능을 애그리거트에서 구현할 수도 있다.
  - ex) `Product`를 생성하는 `Store` 애그리거트 객체
- 애그리거트가 갖고 있는 데이터를 이용해서 다른 애그리거트를 생성해야 한다면 애그리거트에 팩토리 메소드를 구현하는 것을 고려해보자.

----

# 참고자료

- 도메인 주도 개발 시작하기, 최범균 지음
