# 09 도메인 모델과 바운디드 컨텍스트

## 1. 도메인 모델과 경계

- 처음 도메인 모델을 만들 때 빠지기 쉬운 함정. 도메인을 완벽하게 표현하는 단일 모델을 만드는 시도를 하는 것.
  - 한 도메인은 여러 하위 도메인으로 구분되기 때문에 한 개의 모델로 여러 하위 도메인을 표현하려고 시도하면 오히려 모든 하위 도메인에 맞지 않는 모델을 만들게 된다.
- 논리적으로 같은 존재처럼 보이지만 하위 도메인에 따라 다른 용어를 사용하는 경우도 있다.
  - 하위 도메인마다 같은 용어라도 의미가 다르고 같은 대상이라도 지칭하는 용어가 다를 수 있기 때문에 한 개의 모델로 모든 하위 도메인을 표현하려는 시도는 올바른 방법이 아니며, 표현할 수도 없다.
- 올바른 도메인 모델 만들기 => 하위 도메인마다 모델을 만들어야 한다.
  - 각 모델은 명시적으로 구분되는 경계를 가져서 섞이지 않도록 해야 한다.
  - 여러 하위 도메인의 모델이 섞이기 시작하면 모델의 의미가 약해질 뿐만 아니라 여러 도메인의 모델이 서로 얽히기 때문에 각 하위 도메인별로 다르게 발전하는 요구사항을 모델에 반영하기 어려워진다.
- 모델은 특정한 컨텍스트(문맥) 하에서 완전한 의미를 갖는다.
  - 같은 제품이라도 카탈로그 컨텍스트와 재고 컨텍스트에서 의미가 서로 다르다.
- 이렇게 구분되는 경계를 갖는 컨텍스트를 DDD에서는 `바운디드 컨텍스트 Bounded Context`라고 부른다.

----

## 2. 바운디드 컨텍스트

- 바운디드 컨텍스트는 모델의 경계를 결정하며 한 개의 바운디드 컨텍스트는 논리적으로 한 개의 모델을 갖는다.
- 바운디드 컨텍스트는 용어를 기준으로 구분한다.
- 이상적으로 하위 도메인과 바운디드 컨텍스트가 일대일 관계를 가지면 좋겠지만 현실은 그렇지 않을 때가 많다.
  - 기업의 팀 조직에 따라 결정되기도 한다. 
  - 규모가 작은 기업은 전체 시스템을 한 개의 팀에서 구현할 때도 있다. 여러 하위 도메인을 한 개의 바운디드 컨텍스트에서 구현한다는 말이다.
- 여러 하위 도메인을 하나의 바운디드 컨텍스트에서 개발할 때 주의할 점은 하위 도메인의 모델이 섞이지 않도록 하는 것이다.
  - 하위 도메인마다 구분되는 패키지를 갖도록 구현해야 하며, 이렇게 함으로써 하위 도메인을 위한 모델이 서로 뒤섞이지 않고 하위 도메인마다 바운디드 컨텍스트를 갖는 효과를 낼 수 있다.

----

## 3. 바운디드 컨텍스트 구현

- 바운디드 컨텍스트는 도메인 기능을 사용자에게 제공하는 데 필요한 표현 영역, 응용 서비스, 인프라스트럭처 영역을 모두 포함한다.
- 도메인 모델의 데이터 구조가 바귀면 DB 테이블 스키마도 함께 변경해야 하므로 테이블도 바운디드 컨텍스트에 포함된다.
- 모든 바운디드 컨텍스트를 반드시 도메인 주도로 개발할 필요는 없다.
  - 상품의 리뷰는 복잡한 도메인 로직을 갖지 않기 때문에 CRUD 방식으로 구현해도 된다. (DAO와 데이터 중심의 밸류 객체 이용)
- 한 바운디드 컨텍스트에서 두 방식을 혼합해서 사용할 수도 있다.
  - ex) CQRS(Command Query Responsibility Segregation) 패턴: 상태를 변경하는 명령 기능과 내용을 조회하는 쿼리를 구분하는 패턴.
  - 명령 기능은 도메인 모델 기반으로 단순 조회 기능은 서비스-DAO를 이용해서 구현할 수 있다.

----

## 4. 바운디드 컨텍스트 간 통합

- 두 팀이 관련된 바운디드 컨텍스트를 개발하면 자연스럽게 두 바운디드 컨텍스트 간 통합이 발생한다.
  - REST API를 호출해서 두 바운디드 컨텍스트를 직접 통합하는 방법을 선택할 수 있다.
  - 반면 메시지 큐를 사용하는 방법은 간접 통합 방식이다.
- 어떤 도메인 관점에서 모델을 사용하느냐에 따라 두 바운디드 컨텍스트의 구현 코드가 달라지게 된다.
  - 메시지 큐를 주가 제공하느냐에 따라 어떤 도메인을 따르게 될지 결정된다.

> #### 마이크로서비스와 바운디드 컨텍스트
> - 마이크로서비스의 특징과 바운디드 컨텍스트는 잘 어울린다.
> - 각 바운디드 컨텍스트는 모델의 경계를 형성하는데 바운디드 컨텍스트를 마이크로서비스로 구현하면 자연스럽게 컨텍스트별로 모델이 분리된다.

----

## 5. 바운디드 컨텍스트 간 관계

- 바운디드 컨텍스트는 어떤 식으로든 연결되기 때문에 두 바운디드 컨텍스트는 다양한 방식으로 관계를 맺는다.
  - 가장 흔한 관계는 한쪽에서 API를 제공하고 다른 한쪽에서 그 API를 호출하는 관계 (REST API).
  - 이 관계에서는 API를 사용하는 바운디드 컨텍스트가 제공하는 바운디드 컨텍스트에 의존하게 된다.
  - downstream 컴포넌트가 upstream 컴포넌트에 의존한다.
  - upstream은 일종의 서비스 공급자 역할을 하며 downstream은 서비스 소비자 역할을 한다.
- 두 바운디드 컨텍스트가 같은 모델을 공유하는 경우도 있다.
  - 이렇게 두 팀이 공유하는 모델은 `공유 커널 Shared Kernel`이라고 부른다.
  - 장점: 중복이 줄어듬.
  - 단점: 두 팀이 밀접한 관계를 유지해야 함. (밀접하지 않다면 공유 커널 때문에 병목이 발생할 수 있다.)
- `독립 방식 Separate Way`을 채택할 수도 있다. 서로 통합하지 않는 방식이다.
  - 두 바운디드 컨텍스트 간의 통합은 수동으로 이뤄진다. 유저가 각각 접근한다.
  - 하지만 규모가 커질수록 수동 통합에는 한계가 있으므로 규모가 커지기 시작하면 두 바운디드 컨텍스트를 통합해야 한다.

----

## 6. 컨텍스트 맵

- 개별 바운디드 컨텍스트에 매몰되면 전체를 보지 못한다.
- 전체 비즈니스를 조망할 수 있는 지도. 컨텍스트 맵을 활용해보자.

----

# 참고자료

- 도메인 주도 개발 시작하기, 최범균 지음
