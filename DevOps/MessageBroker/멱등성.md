# 메시지 큐를 활용할 때 멱등성을 유지하는 방법

## 1. API 자체를 멱등하게 만든다.

동일한 요청이 여러 번 전송되어도 결과가 동일하도록 API를 설계합니다.

### 방법
- **조회(GET)**: 기본적으로 멱등성을 가짐
- **생성(POST)**: 클라이언트가 생성할 리소스의 ID를 직접 지정 (UUID 등)
- **수정(PUT)**: 전체 리소스를 교체하는 방식으로 설계하여 멱등성 보장
- **삭제(DELETE)**: 이미 삭제된 리소스에 대한 삭제 요청도 동일한 결과 반환

### 예시
```java
// 멱등하지 않은 방식
@PostMapping("/orders")
public Order createOrder(OrderRequest request) {
    return orderService.create(request); // 매번 새로운 주문 생성
}

// 멱등한 방식
@PutMapping("/orders/{orderId}")
public Order createOrder(@PathVariable String orderId, OrderRequest request) {
    return orderService.createOrUpdate(orderId, request); // 동일 ID로 여러 번 호출해도 하나만 생성
}
```

## 2. Message에 ID를 부여해서 처리한다.

메시지마다 고유한 ID를 부여하고, 이미 처리된 메시지는 중복 처리하지 않도록 관리합니다.

### 구현 방법

#### 2.1 데이터베이스를 활용한 중복 제거
```java
@Service
public class MessageProcessor {

    @Autowired
    private ProcessedMessageRepository processedMessageRepo;

    @Transactional
    public void processMessage(Message message) {
        String messageId = message.getId();

        // 이미 처리된 메시지인지 확인
        if (processedMessageRepo.existsById(messageId)) {
            log.info("Message {} already processed. Skipping.", messageId);
            return;
        }

        // 비즈니스 로직 처리
        performBusinessLogic(message);

        // 처리 완료 기록
        processedMessageRepo.save(new ProcessedMessage(messageId, LocalDateTime.now()));
    }
}
```

#### 2.2 Redis를 활용한 중복 제거
```java
@Service
public class MessageProcessor {

    @Autowired
    private RedisTemplate<String, String> redisTemplate;

    private static final String PROCESSED_KEY_PREFIX = "processed:";
    private static final Duration TTL = Duration.ofDays(7);

    public void processMessage(Message message) {
        String messageId = message.getId();
        String key = PROCESSED_KEY_PREFIX + messageId;

        // SetIfAbsent를 사용한 원자적 중복 체크
        Boolean isNew = redisTemplate.opsForValue()
            .setIfAbsent(key, "processed", TTL);

        if (Boolean.FALSE.equals(isNew)) {
            log.info("Message {} already processed. Skipping.", messageId);
            return;
        }

        // 비즈니스 로직 처리
        performBusinessLogic(message);
    }
}
```

#### 2.3 데이터베이스 Unique Constraint 활용
```java
@Entity
@Table(uniqueConstraints = {
    @UniqueConstraint(columnNames = {"messageId"})
})
public class Order {
    @Id
    private Long id;

    @Column(nullable = false, unique = true)
    private String messageId; // 메시지 큐의 메시지 ID

    private String productName;
    private Integer quantity;
}

@Service
public class OrderService {

    @Transactional
    public void createOrder(OrderMessage message) {
        try {
            Order order = new Order();
            order.setMessageId(message.getId());
            order.setProductName(message.getProductName());
            order.setQuantity(message.getQuantity());

            orderRepository.save(order);
        } catch (DataIntegrityViolationException e) {
            // 중복된 messageId로 인한 예외 - 이미 처리됨
            log.info("Order with messageId {} already exists", message.getId());
        }
    }
}
```

### 주의사항
- **메시지 ID 생성**: Producer 측에서 UUID 또는 Snowflake ID 등을 사용하여 고유한 ID 생성
- **저장소 관리**: 처리된 메시지 ID를 영구 보관할 경우 스토리지 증가 고려 (TTL 설정 권장)
- **성능**: Redis 같은 인메모리 저장소 사용 시 빠른 조회 가능
- **트랜잭션**: 비즈니스 로직 처리와 중복 체크를 동일한 트랜잭션으로 묶어야 함
