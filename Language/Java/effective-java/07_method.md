# 8장 메소드 

## item49. 매개변수가 유효한지 검사하라.

- 메소드와 생성자 대부분은 입력 매개변수의 값이 특정 조건을 만족하기를 바란다.
  - ex) 인덱스 값은 음수면 안 된다. 객체 참조는 null이 아니어야 한다.
  - 이런 제약은 반드시 문서화해야 하며 메소드 몸체가 시작되기 전에 검사해야 한다.
- 매개변수 검사를 제대로 하지 않았을 때의 문제점
1. 메소드가 수행되는 중간에 모호한 예외를 던지며 실패할 수 있다.
2. (더 나쁜 상황) 메소드가 잘 수행되지만 잘못된 결과를 반환한다.
3. (한층 더 나쁜 상황) 메소드는 문제없이 수행됐지만, 어떤 객체를 이상한 상태로 만들어놓아서 미래의 알 수 없는 시점에 이 메소드와는 관련 없는 오류를 낸다.

- 매개변수 검사에 실패하면 `실패 원자성 failure atomicity`을 어기는 결과를 낳을 수 있다.
  - 따라서 자바독에서 `@throws`를 통해 문서화해야 한다.
- `java.util.Objects.requireNonNull`메소드를 사용하면 null 검사를 수동으로 하지 않아도 된다.
  - 또한 Java9부터 `Objects`에 `checkFromIndexSize`, `checkFromToIndex`, `checkIndex` 등 범위 검사도 추가되었다. (null 검사만큼 유연하지는 않다.)
- 공개되지 않은 메소드(`private`)라면 `assert`를 사용해 매개변수 유효성을 검증할 수 있다.
- 핵심은 단언한 조건이 무조건 참이라고 선언하는 것. 단언문은 일반적인 유효성 검사와 다르다.
1. 실패하면 `AssertionError`를 던진다.
2. 런타임에 아무런 효과도, 아무런 성능 저하도 없다. (런타임에 영향을 주는 방법도 있다.)

- 하지만 이번 아이템을 "매개변수에 제약을 두는 게 좋다"고 해석해서는 안 된다. 사실은 그 반대다.
  - 메소드는 최대한 범용적으로 설계해야 한다. 메소드가 건네받은 값으로 무언가 제대로 된 일을 할 수 있디면 매개변수 제약은 적을수록 좋다.
  - 하지만 구현하려는 개념 자체가 특정한 제약을 내재한 경우도 드물지 않다.

---

## item50. 적시에 방어적 복사본을 만들라

- 클라이언트가 우리의 불변식을 깨뜨리려 혈안이 되어 있다고 가정하고 방어적으로 프로그래밍해야 한다.
- 만약 `Date`와 같이 가변인 옛날 자바 API를 코드에서 사용하고 있다고 해보자.
  - 일단 더이상 낡은 API를 사용해서는 안 된다. 하지만 그렇게 해서 문제에서 해방되는 것은 아니다. 많은 API와 내부 구현에 그 잔재가 남아 있을 것이다.
  - 외부 공격으로부터 인스턴스 내부를 보호하려면 생성자에서 받은 가변 매개변수 각각을 `방어적으로 복사 defensive copy`해야 한다.

```java
public Period(Date start, Date end) {
  this.start = new Date(start.getTime());
  this.end = new Date(end.getTime());
  
  if (this.start.compareTo(this.end) > 0) {
    throw new IllegalArgumentException("~~~");
  }
}
```

- 멀티스레딩 환경이라면 원본 객체의 유효성을 검사한 후 복사본을 만드는 그 찰나의 취약한 순간에 다른 스레드가 원본 객체를 수정할 위험이 있다.
  - 따라서 반드시 위와 같이 방어적 복사를 해야 한다.
- 매개변수가 제3자에 의해 확장될 수 있는 타입이라면 방어적 복사본을 만들 때 `clone`을 사용해서는 안 된다.
- 또한 접근자 메소드가 남아 있다면 내부의 가변 정보가 드러나기 때문에 여전히 수정이 가능할 수 있다는 점을 주의하자.
  - 이 때는 단순히 접근자가 가변 필드의 방어적 복사본을 반환하면 된다.

```java
public Date start() {
  return new date(start.getTime());
}
```

<br/>

# 참고자료

- Effective Java 3/E, Joshua Bloch

