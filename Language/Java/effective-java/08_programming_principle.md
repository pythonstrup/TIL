# 9장 일반적인 프로그래밍 원칙 

- 자바 언어의 핵심 요소
- 지역변수, 제어구조, 라이브러리, 데이터 타입, 그리고 언어 경계를 넘나드는 기능인 리플렉션과 네이티브 메소드

## item57. 지역변수의 범위를 최소화하라.

- item15의 "클래스와 멤버의 접근 권한을 최소화하라"와 취지가 비슷.
- **지역변수의 범위를 줄이는 가장 강력한 기법은 역시 '가장 처음 쓰일 때 선언하기'다.**
- **거의 모든 지역변수는 선언과 동시에 초기화해야 한다.**
  - `try-catch`는 제외
- `while`보다는 `for`문
- **메소드는 작게 유지하고 한 가지 기능에 집중**

---

## item58. 전통적인 `for` 문보다는 `for-each` 문을 사용하라

- `iterator`나 전통적인 방법으로 변수를 선언하는 것보다는 아래 방식이 더 낫다. (enhanced `for` statement)
  - 하나의 관용구로 컬렉션과 배열을 모두 처리할 수 있어서 어떤 컨테이너를 다루는지는 신경쓰지 않아도 된다.

```java
for (Element e: elements) {
  // ...  
}
```

- 컬렉션을 중첩해 순회해야 한다는 `for-each` 문의 이점은 더욱 커진다.
- 하지만 안타깝게도 `for-each` 문을 사용할 수 없는 상황이 세 가지 존재한다.
1. 파괴적인 필터링: 순회하면서 선택된 원소를 제거해야 한다면, 반복자의 `remove`를 활용해야 한다. 자바8부터 `Collection`의 `removeIf` 메소드를 사용해 컬렉션을 명시적으로 순회하는 일을 피할 수 있다.
2. 변형: 원소의 값 일부 혹은 전체를 교체해야 하는 경우
3. 병렬 반복: 여러 컬렉션을 병렬로 순회해야 하는 경우

- `for-each`문은 컬렉션과 배열은 물론 `Iterable` 인터페이스를 구현한 객체라면 무엇이든 순회할 수 있다.

---

## item59. 라이브러리를 익히고 사용하라

- ex) `Random`
  - 자바 7부터는 `Random`을 더 이상 사용하지 않는 게 좋다. `ThreadLocalRandom`으로 대체. (속도도 3.6배 정도 더 빠르다고 함.)
  - 포크조인 풀이나 병렬 스트림에서는 `SplittableRandom`을 사용하라.
- 표준 라이브러리의 이점
1. **표준 라이브러리를 사용하면 그 코드를 작성한 전문가의 지식과 여러분보다 앞서 사용한 다른 프로그래머들의 경험을 활용할 수 있다.**
2. 핵심적인 일과 크게 관련 없는 문제를 해결하느라 시간을 허비하지 않아도 된다.
3. 노력하지 않아도 성능이 지속해서 개선된다.
4. 기능이 점점 많아진다.
5. 여러분이 작성한 코드가 많은 사람에게 낯익은 코드가 된다. -> 유지보수성이 높아진다.

- 실상은 많은 프로그래머가 직접 구현해 쓰고 있다. 왜 그럴까?
  - 아마도 라이브러리에 그런 기능이 있는지 모르기 때문일 것이다.
  - **메이저 릴리스마다 주목할 만한 수많은 기능이 라이브러리에 추가된다.**
- 자바 프로그래머라면 적어도 `java.lang`, `java.util`, `java.io`와 그 하위 패키지들에는 익숙해져야 한다.
  - 여기에 더해 `java.util.concurrent`의 동시성 기능도 마찬가지로 알아두면 큰 도움이 된다.
- 최대한 라이브러리를 활용하되, 원하는 기능을 찾지 못하면 그 다음 선택지를 고품질의 서드파티 라이브러리로 하라.
  - ex) `Guava`
  - 적합한 서드파티 라이브러리도 찾지 못했다면, 다른 선택이 없으니 직접 구현하자.

---

## item60. 정확한 답이 필요하다면 `float`과 `double`은 피하라

- `float`과 `double`은 과학과 공학 계산용으로 설계
  - 부동소수점 연산에 쓰이며, '근사치'로 계산하도록 세심하게 설계.
  - 따라서 정확한 결과가 필요할 때는 사용하면 안 된다.
  - **특히 금융 관련 계산과는 맞지 않는다.** -> 0.1 혹은 10의 음의 거듭 제곱 수를 표현할 수 없기 때문이다.
- 금융 계산에는 `BigDecimal`, `int`, `long`을 사용해야 한다.
- `BigDecimal` 단점. 기본 타입보다 쓰기 불편하고, 훨씬 느리다.

---

## item61. 박싱된 기본 타입보다는 기본 타입을 사용하라

- 각각 기본 타입에는 그에 상응되는 Wrapper 타입이 있다.
  - `int` -> `Integer`
  - `long` -> `Long`
- 기본 타입과 박싱된 타입의 주된 차이는 크게 3가지다.
1. 기본 타입은 값만 가지고 있으나, 박싱된 타입은 값에 더해 `식별성 identity`이란 속성을 갖는다. -> 값이 같아도 서로 다르다고 식별될 수 있다.
2. 기본 타입의 값은 언제나 유효하지만 박싱된 타입은 유효하지 않은 값 null을 가질 수 있다.
3. 기본 타입이 박싱된 타입보다 시간과 메모리 사용면에서 더 효율적이다.

- 박싱된 타입의 문제점
  - `naturalOrder.compare(new Integer(42), new Integer(42))`를 하면 0을 출력해야 할 것 같지만, 1이 출력되어 버린다.
  - 정수값을 비교한 뒤 같으면, 그 다음으로 식별성을 검사하기 때문이다. -> 박싱된 기본 타입에 == 연산자를 사용하면 오류가 일어난다.
- 그렇다면 박싱된 타입은 언제 써야 할까?
1. 컬렉션의 원소, 키, 값으로 쓴다.
2. 매개변수화 타입이나 매개변수화 메소드의 타입 매개변수로 사용.
3. 리플렉션을 통해 메소드를 호출할 때도 박싱된 타입을 사용.

---

## item62. 다른 타입이 적절하다면 문자열 사용을 피하라

- **문자열은 다른 값 타입을 대신하기에 적합하지 않다.**
  - `int`, `float`, `BigInteger`, `boolean` 등
- **문자열은 열거 타입을 대신하기에 적합하지 않다.**
- **문자열은 혼합 타입을 대신하기에 적합하지 않다.**
  - 여러 요소가 혼합된 데이터를 하나의 문자열로 표현하는 것은 대체로 좋지 않은 생각이다.

```java
String compoundKey = className + "#" + i.next();
```

- 각 요소를 개별로 접근하려면 문자열을 파싱해야 해서 느리고, 귀찮고, 오류 가능성도 커진다.
- 적절한 `equals`, `toString`, `compareTo` 메소드를 제공할 수 없으며, `String`이 제공하는 기능에만 의존해야 한다.
  - 그래서 차라리 전용 클래스를 새로 만드는 편이 낫다.
- **문자열은 권한을 표현하기에 적합하지 않다.**

---

## item63. 문자열 연결은 느리니 주의하라

- 문자열 연결 연산자로 문자열 n개를 잇는 시간은 `n^2`에 비례한다.
  - 문자열은 불변이라서 두 문자열을 연결할 경우 양쪽의 내용을 모두 복사해야 하므로 성능 저하를 피할 수 없다.
- 성능을 포기하고 싶지 않다면 `String` 대신 `StringBuilder`를 사용하라.


---

## item64. 객체는 인터페이스를 사용해 참조하라

- 적합한 인터페이스만 있다면 매개변수뿐 아니라, 반환값, 변수, 필드를 전부 인터페이스 타입으로 선언하라.
  - 객체의 실제 클래스를 사용해야 할 상황은 '오직' 생성자로 생성할 때뿐이다.

```java
Set<MySon> son = new LinkedHashSet<>();
```

- 인터페이스를 타입으로 사용하는 습관을 길러두면 프로그램이 훨씬 유연해질 것이다.
  - 나중에 구현 클래스를 교체하고자 한다면 그저 새 클래스의 생성자를 호출해주기만 하면 된다.

```java
Set<MySon> son = new HashSet<>();
```

- 주의할 점이 있다. 인터페이스의 일반 규약 이외의 특별한 기능에 기대어 동작한다면 새로운 클래스도 반드시 같은 기능을 제공하는 것으로 대체해야 한다.
  - ex) 순서 정책에 기대고 있을 때, `LinkedHashSet`를 `HashSet`로 바꾸면 문제 발생
- 적합한 인터페이스가 없다면 당연히 클래스를 참조해야 한다. 아래는 그 3가지 부류
1. `String`, `BigInteger`와 같은 값 클래스
2. 클래스 기반으로 작성된 프레임워크가 제공하는 객체. `OutputStream` 등 `java.io` 패키지의 여러 클래스들
3. 인터페이스에 없는 특별한 메소드를 제공하는 클래스. `PriorityQueue` 클래스의 `comparator` 메소드 (`Queue` 인터페이스는 이를 제공하지 않는다.)
   - 이런 추가 메소드를 꼭 사용해야 하는 경우로 최소화해야 하며, 절대 남발해서는 안 된다.

- 그래도 가능하다면 가장 덜 구체적인 클래스를 타입으로 사용하자!

---

## item65. 리플렉션보다는 인터페이스를 사용하라

- `java.lang.reflrect`의 리플렉션 기능을 사용하면 프로그램에서 임의의 클래스에 접근할 수 있다.
- 리플렉션을 사용하면 컴파일 당시에 존재하지 않던 클래스도 이용할 수 있는데, 물론 단점도 있다.
1. 컴파일타임 타입 검사가 주는 이점을 하나도 누릴 수 없다.
2. 리플렉션을 이용하면 코드가 지저분하고 장황해진다.
3. 성능이 떨어진다.

- 리플렉션은 아주 제한된 형태로만 사용해야 그 단점을 피하고 이점만 취할 수 있다.
- 리플렉션은 인스턴스 생성에만 쓰고, 이렇게 만든 인스턴스는 인터페이스나 상위 클래스로 참조해 사용하자.

---

## item66. 네이티브 메소드는 신중히 사용하라

- 여기서 네이티브 메소드란 C나 C++ 같은 네이티브 프로그래밍 언어로 작성한 메소드를 말한다.
- 전통적인 네이티브 메소드의 주요 쓰임은 다음 세 가지다.
1. 레지스트리 같은 플랫폼 특화 기능
2. 네이티브 코드로 작성된 기존 라이브러리를 사용
3. 성능 개선을 목적으로 성능에 결정적인 영향을 주는 영역만 따로 네이티브 언어로 작성

- 플랫폼 특화 기능을 활용하려면 네이티브 메소드를 사용해야 한다. 하지만 자바가 성숙해가면서 하부 플랫폼의 기능들을 점차 흡수하고 있다.
  - 그래서 네이티브 메소드를 사용할 필요가 줄어들고 있다.
- 성능을 개선할 목적으로 네이티브 메소드를 사용하는 것은 거의 권장하지 않는다.
  - 자바로도 충분히 빠르다. 원래의 네이티브 구현보다도 더 빠른 경우도 있다.
- 네이티브는 심각한 단점을 가지고 있다.
  - 메모리 훼손 오류로부터 안전하지 않다.
  - 자바보다 플랫폼을 많이 타서 이식성도 낮다.
  - 디버깅도 어렵다.
  - 주의하지 않으면 속도가 오히려 느려질 수 있다.
  - 가비지 컬렉터가 네이티브 메모리는 자동 회수하지 못하고, 심지어 추적조차 할 수없다.
  - 자바 코드와 네이티브 코드의 경계를 넘나들 때마다 비용도 추가된다.
  - `접착 코드 glue code`를 작성해야 하는데, 이는 귀찮은 작업이며, 가독성이 떨어진다.

---

## item67. 최적화는 신중히 하라

- 모든 사람이 마음 깊이 새겨야 할 최적화 격언 세 개

> (맹목적인 어리석음을 포함해) 그 어떤 핑계보다 효율성이라는 이름 아래 행해진 컴퓨팅 죄악이 더 많다. (심지어 효율을 높이지도 못하면서)
> - 월리엄 울프

> (전체의 97% 정도인) 자그마한 효율성은 모두 잊자. 섣부른 최적화가 만악의 근원이다.

> 최적화를 할 때는 다음 두 규칙을 따르라.
> 1. 하지 마라.
> 2. (전문가 한정) 아직 하지 마라. 다시 말해, 완전히 명백하고 최적화됮 않은 해법을 찾을 때까지는 하지 마라.

- 성능 때문에 견고한 구조를 희생하지 말자. 빠른 프로그램보다는 좋은 프로그램을 작성하라.
  - 좋은 프로그램이지만 원하는 성능이 나오지 않는다면 그 아키텍처 자체가 최적화할 수 있는 길을 안내해줄 것이다.
  - 좋은 프로그램은 정보 은닉 원칙을 따르므로 개별 구성요소의 내부를 독립적으로 설계할 수 있다.
  - 따라서 시스템의 나머지에 영향을 주지 않고도 각 요소를 다시 설계할 수 있다. (item15)
- 성능 문제를 완전히 무시하라는 뜻은 아니다.
  - 완성된 설계의 기본 틀을 변경하려다 보면 유지보수하거나 개선하기 어려운 꼬인 구조의 시스템이 만들어지기 쉽다.
  - 따라서 설계 단계에서 성능을 반드시 염두에 두어야 한다.
- **성능을 제한하는 설계를 피하라**
  - 완성 후 변경하기가 가장 어려운 설계 요소는 바로 컴포넌트끼리, 혹은 외부 시스템과의 소통 방식이다.
- **API를 설계할 때 성능에 주는 영향을 고려하라**
- **각각의 최적화 시도 전후로 성능을 측정하라**
  - 대부분 눈에 듸게 높아지지 못하는 경우가 많고, 심지어 더 나빠지게 할 때도 있다.
- 프로파일링 도구는 최적화 노력을 어디에 집중해야 할지 찾는 데 도움을 준다.
  - 개별 메소드의 소비 시간과 호출 횟수 같은 런타임 정보.
  - 집중할 곳은 물론 알고리즘을 변경해야 한다는 사실을 알려주기도 한다. -> 프로그램 시간이 거듭제곱으로 증가하는 알고리즘이 숨어 있다면 더 효율적인 것으로 교체해야 한다.
  - 시스템 규모가 커질수록 프로파일러가 더 중요해진다.
- 자바는 프로그래머가 작성하는 코드와 CPU에서 수행하는 명령 사이의 '추상화 격차'가 커서 최적화로 인한 성능 변화를 일정하게 예측하기가 그만큼 더 어렵다.
  - 자바의 성능 모델은 정교하지 않고 구현 시스템, 릴리스, 프로세서마다 차이가 있다.
  - 플랫폼마다의 성능도 다를 수 있다는 말이다. 결국 직접 구동해서 측정해 봐야 한다.

---

## item68. 일반적으로 통용되는 명명 규칙을 따르라

- 자바 플랫폼은 명명 규칙이 잘 정립되어 있으며, 그중 많은 것이 자바 언저 명세에 기술되어 있다.
  - 철자와 문법. 두 가지 범주로 나뉜다.
- 철자 규칙: 패키지, 클래스, 인터페이스, 메소드, 필드, 타입 변수의 이름
  - 패키지와 모듈 이름: 각 요소를 점(`.`)로으로 구분하여 계층적으로 짓는다. 요소들은 소문자 알파벳 혹은 (드물게) 숫자로 이뤄진다.
  - 패키지 이름의 나머지는 해당 패키지를 설명하는 하나 이상의 요소로 이뤄진다. 각 요소는 일반적으로 8자 이하의 짧은 단어로 한다. `utilities`보다는 `util`처럼 의미가 통하는 약어.
  - 클래스와 인터페이스의 이름은 하나 이상의 단어로 이뤄지며, 각 단어는 대문자로 시작한다. 통용되는 줄임말을 제외하고는 단어를 줄여 쓰지 않도록 한다.
  - 메소드와 필드는 camel case로 작성한다. (나머지는 클래스와 비슷한)
  - 단, 상수는 예외이다. 모두 대문자로 쓰며 단어 사이는 밑줄로 구분한다(`NEGATIVE_INFINITY` 등). 여기서 상수 필드란 `static final` 필드를 말한다.
  - 타입 매개변수 이름은 보통 한 문자로 표현한다. 타입 = `T` / 컬렉션 원소 = `E` / 맵의 키 = `K` / 맵의 값 = `V` / 예외 = `X` / 메소드 반환 타입 = `R`
- 문법 규칙: 철자 규칙과 비교하면 더 유연하고 논란도 많다.
  - 패키지에 대한 규칙은 없다.
  - 객체를 생성할 수 있는 클래스의 이름은 보통 단수 명사나 명사구를 사용
  - 객체를 생성할 수 없는 클래스의 이름은 보통 복수형 명사로 짓는다.
  - 인터페이스 이름은 클래스와 똑같이 짓거나, `able` 혹은 `ible`로 끝나느 형용사로 짓는다. (`Runnable`, `Iterable`)
  - 어노테이션은 지배적인 규칙이 없이 명사, 동사, 전치사, 형용사가 두루 쓰인다.
  - 어떤 동작을 수행하는 메소드의 이름은 동사나 동사구로 짓는다.
  - `boolean` 값을 반환하는 메소드라면 보통 `is`나 (드물게) `has`로 시작하고, 명사나 명사구 혹은 형용사 단어로 끝나게 한다.
  - 반환 타입이 `boolean`이 아니거나 해당 인스턴스의 속성을 반환하는 메소드의 이름은 보통 명사, 명사구, 혹은 `get`으로 시작하는 동사구로 짓는다.
  - 객체의 타입을 바꿔서, 다른 타입의 또 다른 객체를 반환하는 인스턴스 메소드의 이름은 보통 `toType`의 형태로 짓는다. (`toString`, `toArray` 등)
  - 객체의 내용을 다른 뷰로 보여주는 메소드의 이름은 `asType` 형태로 짓는다. (`asList`)
  - 객체의 값을 기본 타입 값으로 반환하는 메소드의 이름은 보통 `typeValue` 형태로 짓는다. (`intValue` 등)
  - 정적 팩토리의 이름은 다양하지만, `from`, `of`, `valueOf`, `instance`, `getInstance`, `newInstance`, `getType`, `newType`을 흔히 사용한다.
  - 필드 이름에 대한 문법 규칙은 다른 것에 비해 덜 명확하고, 덜 중요하다. API 설계를 잘 했다면 직접 노출될 일이 없기 때문이다.

<br/>

# 참고자료

- Effective Java 3/E, Joshua Bloch





