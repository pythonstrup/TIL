# 01장 웹 브라우저가 메시지를 만든다.

## 1. HTTP 리쿼스트 메시지를 작성한다.

### 1-1. 탐헝 여행은 URL 입력부터 시작한다.

- URL은 단순히 `http://`나 `https://`로만 시작되지 않는다.
    - `ftp:`, `file:`, `mailto:`로 시작하는 등 여러 가지가 존재한다.
- 브라우저는 웹 서버에 액세스하는 클라이언트로 사용하는 경우가 많지만 브라우저의 기능은 그뿐만이 아니다.
    - 파일을 다운로드/업로드하는 FTP(File Transfer Protocol)의 클라이언트 기능을 가지고 있다.
    - 브라우저는 몇 개의 클라이언트 기능을 겸비한 복합적인 클라이언트 소프트웨어다.
    - 따라서 몇 개의 기능 중 어느 것을 사용해 데이터에 액세스하면 좋을지 판단하는 재료가 필요하다.
- 아래는 프로토콜 별 주소 형태다.

```
// HTTP
http://user:password@www.cyber.co.kr:80/dir/file.html
http://{사용자명(생략가능)}:{패스워드(생략가능)}@{웹 서버의 도메인명}:{포트번호(생략가능)}/{파일경로명}

// FTP
ftp://user:password@ftp.cyber.co.kr:21/dir/file1.html
ftp://{사용자명(생략가능)}:{패스워드(생략가능)}@{FTP 서버 도메인명}:{포트번호(생략가능)}/{파일경로명}

// 클라이언트 PC 자체의 파일에서 데이터를 읽어오는 경우
file://localhost/c:/path/file1/zip
file://{컴퓨터명(생략가능)}/{파일의 경로명}

// 메일을 송신하는 경우
mailto:tone@cyber.co.kr
mailto:{메일 주소}

// 뉴스그룹의 기사를 읽는 경우
news:comp.protocols.tcp-ip
news:{뉴스그룹명}
```

### 1-2. 브라우저는 먼저 URL을 해독한다.

- 브라우저가 처음 하는 일은 웹 서버에 보내는 리퀘스트의 메시지를 작성하기 위해 URL을 해독하는 일이다.
- 위에서 설명한 URL의 요소를 분해하여 URL의 의미를 파악한다.

### 1-3. 파일명을 생략한 경우

- `http://www.lab.cyber.co.kr/dir/` 처럼 파일명을 생략하는 경우도 있다.
- 생략이 허용되어 있지만 파일명을 작성하지 않으면 어느 파일에 액세스해야 할지 모른다. 따라서 파일명을 생략할 때를 대비하여 파일명을 미리 서버측에 설정해둔다.
    - 대부분의 서버가 `index.html`이나 `default.html`이라는 파일명을 설정해둔다.
- `http://www.lab.cyber.co.kr/dir/fileordir` 이렇게 되어 있으면 어떻게 처리될까?
    - 웹서버에 `fileordir`라는 파일이 존재하면 `fileordir`를 파일명으로 보고 디렉토리가 있으면 디렉토리명으로 본다.

### 1-4. HTTP의 기본 개념

- URL을 해독하면 어디에 액세스해야 하는지가 판명된다.
    - 그러고 나면 브라우저는 HTTP 프로토콜을 사용해 웹 서버에 액세스한다.
- HTTP 프로토콜은 클라이언트와 서버가 주고받는 메시지의 내용이나 순서를 정한 것이다.
    - `무엇을`: URI
    - `어떻게 해서`: HTTP METHOD(GET, POST, HEAD, OPTIONS, PUT, DELETE, TRACE, CONNECT)

### 1-5. HTTP 리퀘스트 메시지를 만든다.

- URL을 해독해서 웹 서버와 파일명을 판단하면 브라우저는 이것을 바탕으로 HTTP의 리퀘스트 메시지를 만든다.
- HTTP는 포맷이 정해져 있으므로 브라우저는 이 포맷에 맞게 리퀘스트 메시지를 만든다.
- 첫번째 행에는 HTTP Method와 URI, HTTP 버전이 들어간다.
- 두번째 행부터는 HTTP 헤더가 들어간다. HTTP 헤더는 부가적인 자세한 정보를 기록해두는 역할을 한다.
    - 날짜, 클라이언트에서 취급하는 데이터 종류, 언어, 압축 형식, 클라이언트나 서버의 소프트웨어 명칭과 벚전, 데이터의 유효 기간이나 최종 변경 일시 등
- 메시지 본문은 메시지의 실제 내용이다.
    - GET의 경우에는 메소드와 URI만으로 충분하지만 POST의 경우 폼에 입력한 데이터를 넘겨야하는 경우가 있습니다. 그럴 때 메시지 본문에 그 정보를 넣어준다.

```
// Request의 형태
--------------------------------------------
<메소드> <URI> <HTTP 버전>
<필드명>:<필드값>
...
...
<필드명>:<필드값>

<메시지 본문>
--------------------------------------------
```

### 1-6. 리퀘스트 메시지를 보내면 응답이 되돌아온다.

- 리퀘스트의 실행 결과인 `Status Code`와 응답 문구(`Message`)를 첫번째 행에 적어야 한다.

```
// Response의 형태
--------------------------------------------
<HTTP 버전> <스테이터스 코드> <응답 문구>
<필드명>:<필드값>
...
...
<필드명>:<필드값>

<메시지 본문>
--------------------------------------------
```

- `Status Code`에 대한 간단한 설명이다.

| 코드  | 설명                                 |
|:---:|:-----------------------------------|
| 1xx | 처리의 경과 상황 등을 통지                    |
| 2xx | 정상 처리                              |
| 3xx | 무언가 다른 조치가 필요함을 나타냄 (ex. redirect) |
| 4xx | 클라이언트 측의 오류                        |
| 5xx | 서버 측의 오류                           |

- 페이지가 문장으로만 되어 있으면 이것으로 끝이지만 이미지나 영상 등이 포함되어 있는 경에는 계속 내용이 있다.
- 영상 등을 포함한 경우에는 문장 안에 영상 파일을 나타내는 `태그`라는 제어 정보가 포함되어 있으므로 브라우저는 화면에 문장을 표시할 때 태그를 탐색한다.
    - 그리고 영상을 포함하고 있는 의미의 태그를 만나면 그곳에 영상용 공백을 비워두고 문장을 표시한다.
    - 이후 다시 한 번 웹 서버에 액세스하여 태그에 쓰여있는 영상 파일을 웹 서버에서 읽어와 방금 전에 비워 둔 공백에 표시한다.
    - 문장 파일을 읽을 때와 마찬가지로 URI 부분에 영상 파일의 이름을 쓴 리퀘스트 메시지를 만든다.
- 여기서 신기한 점은 URI는 하나로 되어 있으므로 파일 한 번만 읽을 수 있다. 그런데 파일이 여러 개면 어떻게 동작할까?
    - 예를 들어 3개의 영상이 포함되어 있다면, 영상 파일을 읽는 리퀘스트를 3개 만들어야 한다.
- 이렇게 해서 필요한 파일을 판단하고 이것을 읽은 후 레이아웃을 정하여 화면에 표시하는 사애로 전체의 동작을 조정하는 것도 브라우저의 역할이다.
    - 웹 서버는 이런 사정을 전혀 모른다. (하나의 페이지를 구성하기 위해 몇 개의 리퀘스트가 필요한지 등등) 그냥 하나의 request에 하나의 response를 반환할
      뿐이다.

<br/>

## 2. 웹서버의 IP 주소를 DNS 서버에 조회한다.

### 2-1. IP 주소의 기본

- HTTP 메시지를 만들면 다음에는 이것을 OS에 의뢰하여 액세스 대상의 웹 서버에게 송신한다. 브라우저는 URL을 해독하거나 HTTP 메시지를 만들지만 메시지를 네트워크에
  송출하는 기능은 없으몰 OS에 의뢰해 송신하는 것이다.
- 이때 URL 안에 쓰여있는 서버의 도메인명에서 IP 주소를 조사해야 한다
    - OS에 송신을 의뢰할 때는 도메인명이 아니라 IP 주소로 메시지를 받을 상대를 지정해야 하기 때문이다.

> TCP/IP의 기본 개념 (작은 규모의 LAN)
> - 서브넷이라는 작은 네트워크를 라우터로 접속해여 전체 네트워크가 만들어진다고 생각할 수 있다.
> - 여기에서 서브넷이란 허브에 몇 대의 PC가 접속된 것이라고 생각해도 된다.
> - 네트워크 주소는 `네트워크 번호`와 `호스트 번호`로 구분되고 이 두 주소를 합쳐서 `IP 주소`라고 한다.

<img src="img/subnet.PNG">

- 위 그림에 대한 설명이다.

1. 액세스 대상의 서버까지 메시지를 운반할 때는 이 IP 주소에 따라 액세스 대상이 어디에 있는지 판단하고 운반한다. 송신 측이 메시지를 보내면 서브넷 안에 있는 허브가 운반하고
   송신 측에서 가장 가까운 라우터가지 도착한다.
2. 라우터가 메시지를 보낸 상대를 확인하여 다음 라우터를 판단하고 거기에 보내도록 지시하여 송신 동작을 실행한 후, 다시 서브넷의 허브가 라우터까지 메시지를 보낸다.

> 호스트 번호와 네트워크 번호
> - 클래스 A인 경우 앞의 8비트가 네트워크 번호고 뒤의 24비트가 호스트 번호다.
> - 클래스 B인 경우 앞의 16비트가 네트워크 번호고 뒤의 16비트가 호스트 번호다.
> - 클래스 C인 경우 앞의 24비트가 네트워크 번호고 뒤의 8비트가 호스트 번호다.

```
// IP 주소 본체의 표기 방법
10.11.12.13

// IP 주소 본체와 같은 방법으로 네트워크를 표기하는 방법
10.11.12.13/255.255.255.0
{IP 주소 본체}/{[서브]넷마스크}

// 네트워크 번호와 비트 수로 [서브]넷마스크를 표기하는 방법
// 24비트까지 네트워크 번호임을 알 수 있다! (자연스럽게 뒤의 8비트가 호스트 번호가 된다.)
10.11.12.13/24

// 서브넷을 나타내는 주소 
// 호스트 번호의 비트가 모두 0일 때(00000000) 각 컴퓨터가 아닌 서브넷 자체를 나타낸다.  
10.11.12.0/24

// 서브넷의 브로드캐스트를 나타내는 주소 
// 호스트 번호의 비트가 모두 1일 때(11111111) 서브넷 전체에 대한 브로드캐스트를 의미한다. (기기 전체에 패킷을 보낼 수 있는 주소)
10.11.12.255/24 
```

- IP 주소는 32비트의 디지털 데이터로 8비트(1바이트)씩 점으로 구분하여 10진수로 표기한다.
- 이것만으로는 어느 부분이 네트워크 번호고 호스트 번호인지 알 수 없다.
    - 네트워크를 구축할 때 사용자가 직접 내역을 결정할 수 있는 것이다.
    - 이 내역을 나타내는 정보를 필요에 따라 IP 주소에 덧붙이는데, 이 정보를 `서브넷 마스크` 혹은 `넷 마스크`라고 한다.

### 2-2. 도메인명과 IP 주소를 구분하여 사용하는 이유

- 만약 IP 주소만 사용한다면? 숫자를 나열한 IP 주소는 기억하기 어렵다. => 사람이 사용하기 어렵다.
- 그렇다면 도메인명만 사용하면 되지 않느냐는 의견이 있을 것이다.
    - 하지만 실행 효율이라는 관점에서 보면 이것은 좋은 방법이라고 할 수 없다.
    - 인터넷 내부에는 다수의 규칙이 있고 그것들이 연대하여 IP 주소에 의해 목적지가 어디에 있는지를 판단하면서 데이터를 운반한다.
    - 그런데 IP 주소 대신 이름을 쓰면 어떻게 될까? IP 주소는 32비트(4바이트) 고정이지만 도메인명은 수십 바이트에서 최대 255바이트나 있다.
    - 주소의 크기가 크면 클수록 라우터 부하가 커지기 때문에 데이터 운반에 더 많은 시간이 걸리게 된다. (네트워크 속도가 느려진다!)
- 따라서 사람은 도메인명을 사용하고 라우터는 IP 주소를 사용한다는 방법이 고안되었고, 이 방법을 사용하고 있는 것이다.
    - 도메인명을 알면 IP 주소를 알 수 있고, IP 주소를 알면 도메인명을 알 수 있는데 이 모든 것은 DNS에서 나오는 것이다.

> DNS
> - 서버명과 IP 주소를 대응시키기 위해 DNS를 가장 많이 사용하지만 DNS의 기능은 이것만이 아니다.
> - 메일 주소와 메일 서버를 대응시키는 등 다양한 정보를 이름에 대응해서 등록할 수 있다.ㄴ

### 2-3. Socket 라이브러리가 IP 주소

- IP 주소를 조사하기 위해 가장 간단한 방법은 가장 가까운 DNS 서버에 도메인명을 전달에 IP 주소를 질의(query)하는 것이다.
- DNS 서버의 데이터를 조회한다는 것은 DNS 서버에 조회 메시지를 보내고 그것을 응답 메시지를 받는다는 의미다.
    - DNS 서버에 대해 클라이언트로 동작한다고 말할 수 있다. => DNS 클라이언트에 해당하는 것을 `DNS Resolver` 혹은 단순히 `Resolver`라고 부른다.
    - 그리고 DNS의 원리를 사용해 IP 주소를 조사하는 것을 네임 리졸루션(name resolution, 이름 확인)이라고 하는데 이것을 실행하는 것이 `Resolver`
      다.
- `Resolver`의 정체는 Socket 라이브러리에 들어있는 부품화된 프로그램이다.

### 2-4. `Resolver`를 사용해 DNS 서버 조회

- 브라우저 등의 애플리케이션 프로그램을 만들 때 아래와 같이 리졸버 프로그램명(`gethostbyname`)과 웹 서버의 이름(`naver.com`)을 쓰기만
  하면 `Resolver`를 호출할 수 있다.
    - 단 한 개의 행으로 IP 주소 질의가 끝이 난다. 이제 브라우저는 웹 서버에 메시지를 보낼 때 메모리 영역에 저장된 IP 주소를 추출해 HTTP 리퀘스트 메시지와 함께
      OS에 건네주어 송신을 의뢰한다.

```
// C 언어로 작성한 네트워크 애플리케이션의 소스 코드 예시
<애플리케이션 프로그램 이름> (<매개변수>) 
{
  ...
  <메모리 영역> = gethostbyname("naver.com"); // 메모리 영역 안에 서버의 IP 주소가 기입된다.
  ...
  <HTTP 메시지 송신>
  ...
}
```

### 2-5. `Resolver`의 내부 작동

- 네트워크 애플리케이션이 `Resolver`를 호출하면 제어가 `Resolver` 내부로 넘어간다.

1. 리졸버를 호출하는 행을 만나면 애플리케이션의 동작이 일시적으로 정지한다. (제어가 넘어가기 때문에)
2. 애플리케이션에게 의뢰받은 작업을 수행한다.
3. 리졸버가 제어권을 쥐게 되면 DNS 서버에 문의하기 위한 메시지를 만든다. (마치 브라우저가 웹 서버의 요청을 보내기 위해 HTTP 리퀘스트를 만드는 것처럼!)
4. 메시지 송신 동작은 리졸버가 아닌 OS 내부에 포함된 프로토콜 스택을 호출하여 실행된다. (리졸버에도 브라우저와 마찬가지로 네트워크에 대해 데이터를 송수신하는 기능이 없기
   때문이다.)
5. 리졸버가 프로토콜 스택을 호출하면 제어가 OS에서 리졸버에게 넘어가고 여기에서 메시지를 보내는 동작을 실행하여 LAN 어댑터를 통해 메시지가 DNS 서버를 향해 송신된다.
6. 액세스 대상의 웹서버가 DNS 서버에 등록되어 있으면 답이 발견되므로 답을 응답 메시지에 작성해 클라이언트에게 반손한다.
7. IP 주소를 담은 메시지는 네트워크를 통해 클라이언트 측에 도착한다.
8. 이때 메시지는 OS의 프로토콜 스택을 경유하여 리졸버에게 전해진다.
9. 리졸버가 내용을 해독한 후 여기에서 IP 주소를 추출해 애플리케이션에 IP 주소를 전해준다.
10. 리졸버에게 주어진 제어권이 다시 애플리케이션으로 넘어간다. 애플리케이션은 IP 주소를 사용해 웹 서버에 접근한다.

<br/>

## 3. 전 세계의 DNS 서버가 연대한다.

### 3-1. DNS 서버의 기본 동작

- DNS 서버의 기본 동작은 클라이언트에서 조회 메시지를 받고 조회의 내용에 응답하는 형태로 정보를 회답하는 일이다.
- 조회 메시지에는 3가지 정보가 포함되어 있다.

1. 이름

- 서버나 메일 배송 목적지(메일 주소에서 @ 뒷부분 이름)와 같은 이름

2. 클래스

- 인터넷 이외에도 네트워크에서의 이용까지 검토해서 이것을 식별하기 위한 정보
- 그런데 지금은 인터넷 이외의 네트워크가 소멸되어 항상 인터넷을 나타내는 `IN` 값이 된다.

3. 타입

- 어떤 타입(종류)의 정보가 지원되는지 나타냄
- 타입이 A면 이름에 IP 주소가 지원되는 것을 의미
- 타입이 MX면 이름에 매일 배송 목적지가 지원된다는 의미
- 예를 들어 도메인명이 `www.naver.com`인 서버의 IP 주소를 조사할 때 클라이언트는 아래와 같은 정보를 포함한 조회 메시지를 DNS 서버에 보낸다.

```
(a) 이름 = www.naver.com
(b) 클래스 = IN
(c) 타입 = A
```

- 그러면 DNS 서버는 등록된 정보를 찾아서 이름, 클래스, 타입 3가지가 일치하는 것을 찾는다.
    - 항목이 일치하면 IP주소 `xxx.xxx.xxx.xxx`를 클라이언트한테 보내준다.
- 만약 네이버 메일(xxxxx@naver.com)을 보낸다고 하면?
    - 메일 배송 목적지를 조회할 때는 `MX`라는 타입을 사용한다.
    - 조회 메시지의 항목은 아래와 같이 구성될 것이다.

```
(a) 이름 = naver.com
(b) 클래스 = IN
(c) 타입 = MX
```

- 실제로 네이버를 `nslookup`으로 조회하면 어떨까?
    - 타입을 `MX`로 두고 naver.com을 호출해보자.

```
$ nslookup                                                                                    ✔  10003  18:24:51
> set type=mx
> naver.com
Server:		1.214.68.2
Address:	1.214.68.2#53

Non-authoritative answer:
naver.com	mail exchanger = 10 mx1.naver.com.
naver.com	mail exchanger = 10 mx2.naver.com.
naver.com	mail exchanger = 10 mx3.naver.com.

Authoritative answers can be found from:
```

- 응답을 확인해보자. 우선순위와 메일 Exchanger 3개가 존재한다.
- 우선순위가 모두 동일하게 10이므로 `mx1.naver.com`부터 차례대로 메일 발송을 시도할 것이다.
    - 만약 문제가 있으면 `mx2.naver.com`, 그래도 문제가 있으면 `mx3.naver.com`으로 시도할 것이다.
    - 우선순위 차이가 있다면, 우선순위 값이 낮은 것부터 차례로 시도한다.
- 등록 정보는 아래의 형태대로 설정 파일 등에 입력되어 있다. (DNS 서버에)
    - 이 표의 1행 정보에 해당하는 것을 `리소스 레코드 Resource Record`라고 부른다.

|         이름          | 클래스 | 타입  |   클라이언트에 회답하는 항목    |
|:-------------------:|:---:|:---:|:-------------------:|
| www.lab.cyber.co.kr | IN  |  A  |     192.0.2.226     |
|     cyber.co.kr     | IN  | MX  | 10 mail.cyber.co.kr |
|  mail.cyber.co.kr   | IN  |  A  |     192.0.2.227     |
|         ...         | ... | ... |         ...         |

### 3-2. 도메인의 계층

- 조회 메시지를 받은 DNS 서버에 정보가 등록되어 있지 않은 경우도 있다.
- 결론부터 말하면 정보를 분산시켜서 다수의 DNS 서버에 등록하고, 다수의 DNS 서버가 연대하여 어디에 정보가 등록되어 있는지를 찾아내는 구조다.
- 도메인:DNS 서버 = N:1 관계다. 도메인 한 대의 정보를 분할해 DNS 서버에 담을 수 없다는 얘기다.
- 만약 한 대의 도메인을 분할할 수 없다는 얘기에 곤란하다고 생각할 수 있다. 하지만 도메인의 아래에 하위 도메인 만들고 그것을 필요한 서버마다 할당할 수 있다.
  - `example.co.kr`이라는 도메인이 있을 때 `sub1.example.co.kr`, `sub2.example.co.kr`와 같이 하위 도메인을 할당할 수 있다.

### 3-3. 담당 DNS 서버를 찾아 IP 주소를 가져온다.

- 인터넷에는 DNS 서버가 수만 대나 있으므로 닥치는 대로 뒤지면서 다닐 수는 없다.
- 먼저 하위의 도메인을 담당하는 DNS 서버의 IP 주소를 그 상위의 DNS 서버에 등록한다. 그리고 상위의 DNS 서버를 또 그 상위의 DNS 서버에 등록하는 식으로 차례대로 등록한다.
  - 상위의 DNS 서버에 가면 하위의 DNS 서버 IP 주소를 알 수 있고, 거기에 조회 메시지를 보낼 수 있다.
- `com`이나 `kr`라는 도메인(이것을 `최상위 도메인`이라 함)의 DNS 서버에 하위의 DNS 서버를 등록한 곳에서 끝나는 것처럼 보인다. 
  - 하지만 인터넷의 도메인은 `com`이나 `kr`의 상위에 또 하나의 `루트 도메인`이라는 도메인이 있다.
  - 루트 도메인에는 도메인명이 없으므로 보통 도메인을 쓸 때는 생략한다.
- 루트 도메인의 DNS 서버에 할당된 IP 주소는 전 세계에 13개밖에 없고 좀처럼 변경되지 않는다.
  - 루트 도메인의 DNS 서버는 1개의 논리 서버며, 다수의 물리 서버로 운영된다. (로드밸런싱을 하는 것으로 보임)

- 도메인을 찾는 과정은 아래와 같다.
1. 가장 가까이에 있는 DNS 서버에 `naver.com`을 조회하는 요청을 보낸다.
2. 가장 가까운 DNS에 `naver.com`이 등록되어 있지 않아 루트 도메인에 조회 메시지를 전송한다.
3. 루트 도메인은 `com` 도메인의 DNS 서버의 IP 주소를 가장 가까운 DNS 서버에게 반송한다.
4. 가장 가까운 DNS 서버는 `com` 도메인의 DNS 서버에 조회 메시지를 보낸다.
5. 여기에도 `www.naver.com`이 등록되어 있지 않으므로 `com` 아래에 있는 'naver.com' DNS 서버의 IP 주소를 반송한다.
6. 위에서 차례로 내려가다보면 원하는 DNS 서버에 도달하게 되고 조회에 대한 답을 들을 수 있다.

### 3-4. DNS 서버는 캐시 기능으로 빠르게 응답할 수 있다.

- 현실에서는 상위와 하위의 도메인을 같은 DNS 서버에 등록하는 경우도 있다.
  - 이 경우 상위의 DNS 서버에 조회하면 하위 DNS 서버를 한 개 건너뛰고, 다시 그 아래의 DNS 서버에 관한 정보가 돌아온다.
- 최상위 루트 도메인에서 차례대로 내려간다는 원칙대로 움직이지 않을 수도 있다.
  - DNS 서버는 한 번 조사한 이름을 캐시에 기록할 수 있는데 조회한 이름에 해당하는 정보가 캐시에 있으면 그 정보를 회답하기 때문이다.
  - 그러면 루트 도메인보다 아래 위치에서부터 찾기 시작할 수 있다.
- 조회한 이름이 등록되어 있지 않은 경우레도 캐시에 보존할 수 있다.
  - 이름이 없는 경우에도 빠르게 회답할 수 있다.

<br/>

## 4. 프로토콜 스택에 메시지 송신을 의뢰한다.

### 4-1. 데이터 송수신 동작의 개요

- IP 주소를 조사했으면 IP 주소의 상대, 여기에서는 액세스 대상 웹 서버에 메시지를 송신하도록 OS 내부에 있는 프로토콜 스택에 의뢰한다.
  - 웹 서버에 보내는 HTTP 메시지는 디지털 데이터이므로 디지털 데이터 송수신 의뢰한다고 해도 좋다.
- 송수신 동작을 하기 전에 먼저 소켓을 만들고 연결한다.
  - 서버 측에서 소켓을 만들고, 소켓에 클라이언트가 파이프를 연결하길 기다린다.
  - 양쪽의 소켓이 연결되면, 소켓에서 데이터를 쏟아붓듯이 데이터 송수신 동작을 실행한다.
- 송수신 동작이 끝나면(데이터를 전부 보내고나면) 연결했던 파이프가 분리된다.
  -  파이프를 분리할 때는 서버나 클라이언트 어느 쪽에서 하든 상관없다.
- 정리하면 아래와 같다. (이 동작을 실행하는 것은 OS 내부의 프로토콜 스택이다.)
1. 서버에서 소켓을 만든다.(소켓 작성 단계)
2. 클라이언트가 서버 측의 소켓에 파이프를 연결한다.(접속 단계)
3. 데이터를 송수신한다.(송수신 단계)
4. 파이프를 분리하고 소켓을 말소한다.(연결 끊기 단계)

### 4-2. 소켓의 작성 단계

- 소켓 라이브러리의 `socket()`을 호출한다. (이제 제어권이 소켓으로 넘어간다.)
- 소켓이 생기면 디스크립터라는 것이 돌아오는데 애플리케이션은 이것을 받아서 메모리에 기록해둔다. 디스크립터는 소켓을 식별하기 위해 사용하는 것이다.

### 4-3 파이프를 연결하는 접속 단계

- 이제 만들어진 소켓에 접속하도록 프로토콜 스택에 의뢰한다.
- Socket 라이브러리의 `connect`라는 부품을 호출해 의뢰 동작을 수행한다.
  - `connect`를 호출할 때 디스크립터, 서버의 IP 주소, 포트 번호 3가지를 담아 보낸다.
- 디스크립터는 소켓을 만들도록 의뢰한 애플리케이션에 건네주는 것이지 접속 상대에 건네주는 것이 아니므로 접속 상대 측에서는 그 값을 모른다.
  - 따라서 디스크립터를 사용해 서버 측의 소켓을 지정할 순 없다.
  - 디스크립터는 컴퓨터 한 대의 내부에서 소켓을 식별하기 위해 사용하지만, 포트 번호는 접속 상대 측에서 소켓을 식별하기 위해 사용한다.
- 포트 번호? 
  - 서버 측의 포트 번호의 경우, `http://`면 80번, `https://`면 443번, `mailto:`면 25번 등 이미 도메인명에 결정되어 있는 경우가 있다.
  - 클라이언트 측의 포트 번호는 프로토콜 스택이 적당한 값을 골라서 할당한다. 그리고 접속 동작을 실행할 때 서버 측에 통지한다.

### 4-4. 메시지를 주고받는 송수신 단계

- 소켓이 상대측과 연결되면 그 다음부터는 간단해진다. 소켓에 데이터를 쏟아부으면 상대측의 소켓에 데이터가 도착한다.
- Socket 라이브러리는 `write()`라는 프로그램 부품을 사용한다.
  - 사용자가 입력한 URL을 바탕으로 만든 HTTP 리퀘스트 메시지가 여기에서 말하는 송신 데이터다.
  - write를 호출할 때 디스크립터와 송신 데이터를 지정한다. 그러면 프로토콜 스택이 송신 데이터를 서버에게 송신한다.
  - 소켓에는 연결된 상대가 기록되어 있으므로 디스크립터로 소켓을 지정하면 연결된 상대가 판명되어 그곳을 향해 데이터를 송신한다.
  - 그러면 서버는 수신 동작을 실행해 받은 데이터의 내용을 조사하고 적절한 처리를 실행하여 응답 메시지를 반송한다.
- 이제 메시지가 돌아오면 수신 작업을 한다. Socket 라이브러리의 `read()`를 사용해 프로토콜 스택에 수신 동작을 의뢰한다.
  - 수신한 응답 메시지를 `수신 버퍼`라고 부르는 메모리 영역에 저장한다.
  - 수신 버퍼는 애플리케이션 프로그램 내부에 마련된 메모리 영역이므로 수신 버퍼에 메시지를 저장한 시점에서 메시지를 애플리케이션에게 건네준다.

### 4-5. 연결 끊기 단계에서 송수신이 종료된다.

- 브라우저가 데이터 수신을 완료하면 송수신 동작은 끝난다.
- Socket 라이브러리의 `close()`를 호출해 연결 끊기 단계로 돌아가도록 의뢰한다.
  - 소켓 사이를 연결한 파이프와 같은 것이 분리되고 소켓도 말소된다.
- HTTP의 동작
  - 웹에서 사용하는 HTTP 프로토콜에서는 응답 메시지의 송신을 완료했을 때 웹 서버측에서 연결 끊기 동작을 수행한다. 이것이 클라이언트측에 전달되어 클라이언트의 소켓은 연결 끊기 단계로 들어간다.
  - 브라우저가 `read`로 수신 동작을 의뢰했을 때 `read`는 수신한 데이터를 건네주는 대신 송수신 동작이 완료되어 연결이 끊겼다는 사실을 브라우저에 통지한다.
  - 송수신이 종료되었다는 것을 알게된 브라우저에서도 `close`를 호출해 연결 끊기 단계에 들어간다.

<br/>

# 참고자료

- 성공과 실패를 결정하는 1%의 네트워크 원리, Tsutomu Tone 지음
