# 01장 웹 브라우저가 메시지를 만든다.

## 1. HTTP 리쿼스트 메시지를 작성한다.

### 1-1. 탐헝 여행은 URL 입력부터 시작한다.

- URL은 단순히 `http://`나 `https://`로만 시작되지 않는다.
  - `ftp:`, `file:`, `mailto:`로 시작하는 등 여러 가지가 존재한다.
- 브라우저는 웹 서버에 액세스하는 클라이언트로 사용하는 경우가 많지만 브라우저의 기능은 그뿐만이 아니다.
  - 파일을 다운로드/업로드하는 FTP(File Transfer Protocol)의 클라이언트 기능을 가지고 있다. 
  - 브라우저는 몇 개의 클라이언트 기능을 겸비한 복합적인 클라이언트 소프트웨어다.
  - 따라서 몇 개의 기능 중 어느 것을 사용해 데이터에 액세스하면 좋을지 판단하는 재료가 필요하다.
- 아래는 프로토콜 별 주소 형태다.

```
// HTTP
http://user:password@www.cyber.co.kr:80/dir/file.html
http://{사용자명(생략가능)}:{패스워드(생략가능)}@{웹 서버의 도메인명}:{포트번호(생략가능)}/{파일경로명}

// FTP
ftp://user:password@ftp.cyber.co.kr:21/dir/file1.html
ftp://{사용자명(생략가능)}:{패스워드(생략가능)}@{FTP 서버 도메인명}:{포트번호(생략가능)}/{파일경로명}

// 클라이언트 PC 자체의 파일에서 데이터를 읽어오는 경우
file://localhost/c:/path/file1/zip
file://{컴퓨터명(생략가능)}/{파일의 경로명}

// 메일을 송신하는 경우
mailto:tone@cyber.co.kr
mailto:{메일 주소}

// 뉴스그룹의 기사를 읽는 경우
news:comp.protocols.tcp-ip
news:{뉴스그룹명}
```

### 1-2. 브라우저는 먼저 URL을 해독한다.

- 브라우저가 처음 하는 일은 웹 서버에 보내는 리퀘스트의 메시지를 작성하기 위해 URL을 해독하는 일이다.
- 위에서 설명한 URL의 요소를 분해하여 URL의 의미를 파악한다.

### 1-3. 파일명을 생략한 경우

- `http://www.lab.cyber.co.kr/dir/` 처럼 파일명을 생략하는 경우도 있다.
- 생략이 허용되어 있지만 파일명을 작성하지 않으면 어느 파일에 액세스해야 할지 모른다. 따라서 파일명을 생략할 때를 대비하여 파일명을 미리 서버측에 설정해둔다.
  - 대부분의 서버가 `index.html`이나 `default.html`이라는 파일명을 설정해둔다.
- `http://www.lab.cyber.co.kr/dir/fileordir` 이렇게 되어 있으면 어떻게 처리될까?
  - 웹서버에 `fileordir`라는 파일이 존재하면 `fileordir`를 파일명으로 보고 디렉토리가 있으면 디렉토리명으로 본다.

### 1-4. HTTP의 기본 개념

- URL을 해독하면 어디에 액세스해야 하는지가 판명된다.
  - 그러고 나면 브라우저는 HTTP 프로토콜을 사용해 웹 서버에 액세스한다.
- HTTP 프로토콜은 클라이언트와 서버가 주고받는 메시지의 내용이나 순서를 정한 것이다.
  - `무엇을`: URI
  - `어떻게 해서`: HTTP METHOD(GET, POST, HEAD, OPTIONS, PUT, DELETE, TRACE, CONNECT)

### 1-5. HTTP 리퀘스트 메시지를 만든다.

- URL을 해독해서 웹 서버와 파일명을 판단하면 브라우저는 이것을 바탕으로 HTTP의 리퀘스트 메시지를 만든다.
- HTTP는 포맷이 정해져 있으므로 브라우저는 이 포맷에 맞게 리퀘스트 메시지를 만든다.
- 첫번째 행에는 HTTP Method와 URI, HTTP 버전이 들어간다.
- 두번째 행부터는 HTTP 헤더가 들어간다. HTTP 헤더는 부가적인 자세한 정보를 기록해두는 역할을 한다.
  - 날짜, 클라이언트에서 취급하는 데이터 종류, 언어, 압축 형식, 클라이언트나 서버의 소프트웨어 명칭과 벚전, 데이터의 유효 기간이나 최종 변경 일시 등
- 메시지 본문은 메시지의 실제 내용이다.
  - GET의 경우에는 메소드와 URI만으로 충분하지만 POST의 경우 폼에 입력한 데이터를 넘겨야하는 경우가 있습니다. 그럴 때 메시지 본문에 그 정보를 넣어준다.

```
// Request의 형태
--------------------------------------------
<메소드> <URI> <HTTP 버전>
<필드명>:<필드값>
...
...
<필드명>:<필드값>

<메시지 본문>
--------------------------------------------
```

### 1-6. 리퀘스트 메시지를 보내면 응답이 되돌아온다.

- 리퀘스트의 실행 결과인 `Status Code`와 응답 문구(`Message`)를 첫번째 행에 적어야 한다.

```
// Response의 형태
--------------------------------------------
<HTTP 버전> <스테이터스 코드> <응답 문구>
<필드명>:<필드값>
...
...
<필드명>:<필드값>

<메시지 본문>
--------------------------------------------
```

- `Status Code`에 대한 간단한 설명이다.

|코드|설명|
|:--:|:--|
|1xx|처리의 경과 상황 등을 통지|
|2xx|정상 처리|
|3xx|무언가 다른 조치가 필요함을 나타냄 (ex. redirect)|
|4xx|클라이언트 측의 오류|
|5xx|서버 측의 오류|

- 페이지가 문장으로만 되어 있으면 이것으로 끝이지만 이미지나 영상 등이 포함되어 있는 경에는 계속 내용이 있다.
- 영상 등을 포함한 경우에는 문장 안에 영상 파일을 나타내는 `태그`라는 제어 정보가 포함되어 있으므로 브라우저는 화면에 문장을 표시할 때 태그를 탐색한다.
  - 그리고 영상을 포함하고 있는 의미의 태그를 만나면 그곳에 영상용 공백을 비워두고 문장을 표시한다.
  - 이후 다시 한 번 웹 서버에 액세스하여 태그에 쓰여있는 영상 파일을 웹 서버에서 읽어와 방금 전에 비워 둔 공백에 표시한다.
  - 문장 파일을 읽을 때와 마찬가지로 URI 부분에 영상 파일의 이름을 쓴 리퀘스트 메시지를 만든다.
- 여기서 신기한 점은 URI는 하나로 되어 있으므로 파일 한 번만 읽을 수 있다. 그런데 파일이 여러 개면 어떻게 동작할까?
  - 예를 들어 3개의 영상이 포함되어 있다면, 영상 파일을 읽는 리퀘스트를 3개 만들어야 한다.
- 이렇게 해서 필요한 파일을 판단하고 이것을 읽은 후 레이아웃을 정하여 화면에 표시하는 사애로 전체의 동작을 조정하는 것도 브라우저의 역할이다.
  - 웹 서버는 이런 사정을 전혀 모른다. (하나의 페이지를 구성하기 위해 몇 개의 리퀘스트가 필요한지 등등) 그냥 하나의 request에 하나의 response를 반환할 뿐이다.

<br/>

## 2. 웹서버의 IP 주소를 DNS 서버에 조회한다.

### 2-1. IP 주소의 기본

- HTTP 메시지를 만들면 다음에는 이것을 OS에 의뢰하여 액세스 대상의 웹 서버에게 송신한다. 브라우저는 URL을 해독하거나 HTTP 메시지를 만들지만 메시지를 네트워크에 송출하는 기능은 없으몰 OS에 의뢰해 송신하는 것이다.
- 이때 URL 안에 쓰여있는 서버의 도메인명에서 IP 주소를 조사해야 한다
  - OS에 송신을 의뢰할 때는 도메인명이 아니라 IP 주소로 메시지를 받을 상대를 지정해야 하기 때문이다.

> TCP/IP의 기본 개념 (작은 규모의 LAN)
> - 서브넷이라는 작은 네트워크를 라우터로 접속해여 전체 네트워크가 만들어진다고 생각할 수 있다.
> - 여기에서 서브넷이란 허브에 몇 대의 PC가 접속된 것이라고 생각해도 된다.
> - 네트워크 주소는 `네트워크 번호`와 `호스트 번호`로 구분되고 이 두 주소를 합쳐서 `IP 주소`라고 한다.

<img src="img/subnet.PNG">

- 위 그림에 대한 설명이다.
1. 액세스 대상의 서버까지 메시지를 운반할 때는 이 IP 주소에 따라 액세스 대상이 어디에 있는지 판단하고 운반한다. 송신 측이 메시지를 보내면 서브넷 안에 있는 허브가 운반하고 송신 측에서 가장 가까운 라우터가지 도착한다.
2. 라우터가 메시지를 보낸 상대를 확인하여 다음 라우터를 판단하고 거기에 보내도록 지시하여 송신 동작을 실행한 후, 다시 서브넷의 허브가 라우터까지 메시지를 보낸다.

> 호스트 번호와 네트워크 번호
> - 클래스 A인 경우 앞의 8비트가 네트워크 번호고 뒤의 24비트가 호스트 번호다.
> - 클래스 B인 경우 앞의 16비트가 네트워크 번호고 뒤의 16비트가 호스트 번호다.
> - 클래스 C인 경우 앞의 24비트가 네트워크 번호고 뒤의 8비트가 호스트 번호다.

```
// IP 주소 본체의 표기 방법
10.11.12.13

// IP 주소 본체와 같은 방법으로 네트워크를 표기하는 방법
10.11.12.13/255.255.255.0
{IP 주소 본체}/{[서브]넷마스크}

// 네트워크 번호와 비트 수로 [서브]넷마스크를 표기하는 방법
// 24비트까지 네트워크 번호임을 알 수 있다! (자연스럽게 뒤의 8비트가 호스트 번호가 된다.)
10.11.12.13/24

// 서브넷을 나타내는 주소 
// 호스트 번호의 비트가 모두 0일 때(00000000) 각 컴퓨터가 아닌 서브넷 자체를 나타낸다.  
10.11.12.0/24

// 서브넷의 브로드캐스트를 나타내는 주소 
// 호스트 번호의 비트가 모두 1일 때(11111111) 서브넷 전체에 대한 브로드캐스트를 의미한다. (기기 전체에 패킷을 보낼 수 있는 주소)
10.11.12.255/24 
```

- IP 주소는 32비트의 디지털 데이터로 8비트(1바이트)씩 점으로 구분하여 10진수로 표기한다.
- 이것만으로는 어느 부분이 네트워크 번호고 호스트 번호인지 알 수 없다.
  - 네트워크를 구축할 때 사용자가 직접 내역을 결정할 수 있는 것이다.
  - 이 내역을 나타내는 정보를 필요에 따라 IP 주소에 덧붙이는데, 이 정보를 `서브넷 마스크` 혹은 `넷 마스크`라고 한다.

### 2-2. 도메인명과 IP 주소를 구분하여 사용하는 이유

- 만약 IP 주소만 사용한다면? 숫자를 나열한 IP 주소는 기억하기 어렵다. => 사람이 사용하기 어렵다.
- 그렇다면 도메인명만 사용하면 되지 않느냐는 의견이 있을 것이다.
  - 하지만 실행 효율이라는 관점에서 보면 이것은 좋은 방법이라고 할 수 없다.
  - 인터넷 내부에는 다수의 규칙이 있고 그것들이 연대하여 IP 주소에 의해 목적지가 어디에 있는지를 판단하면서 데이터를 운반한다.
  - 그런데 IP 주소 대신 이름을 쓰면 어떻게 될까? IP 주소는 32비트(4바이트) 고정이지만 도메인명은 수십 바이트에서 최대 255바이트나 있다.
  - 주소의 크기가 크면 클수록 라우터 부하가 커지기 때문에 데이터 운반에 더 많은 시간이 걸리게 된다. (네트워크 속도가 느려진다!)
- 따라서 사람은 도메인명을 사용하고 라우터는 IP 주소를 사용한다는 방법이 고안되었고, 이 방법을 사용하고 있는 것이다.
  - 도메인명을 알면 IP 주소를 알 수 있고, IP 주소를 알면 도메인명을 알 수 있는데 이 모든 것은 DNS에서 나오는 것이다.

> DNS
> - 서버명과 IP 주소를 대응시키기 위해 DNS를 가장 많이 사용하지만 DNS의 기능은 이것만이 아니다.
> - 메일 주소와 메일 서버를 대응시키는 등 다양한 정보를 이름에 대응해서 등록할 수 있다.ㄴ

### 2-3. Socket 라이브러리가 IP 주소

- IP 주소를 조사하기 위해 가장 간단한 방법은 가장 가까운 DNS 서버에 도메인명을 전달에 IP 주소를 질의(query)하는 것이다.
- DNS 서버의 데이터를 조회한다는 것은 DNS 서버에 조회 메시지를 보내고 그것을 응답 메시지를 받는다는 의미다.
  - DNS 서버에 대해 클라이언트로 동작한다고 말할 수 있다. => DNS 클라이언트에 해당하는 것을 `DNS Resolver` 혹은 단순히 `Resolver`라고 부른다.
  - 그리고 DNS의 원리를 사용해 IP 주소를 조사하는 것을 네임 리졸루션(name resolution, 이름 확인)이라고 하는데 이것을 실행하는 것이 `Resolver`다.
- `Resolver`의 정체는 Socket 라이브러리에 들어있는 부품화된 프로그램이다.

### 2-4. `Resolver`를 사용해 DNS 서버 조회

- 브라우저 등의 애플리케이션 프로그램을 만들 때 아래와 같이 리졸버 프로그램명(`gethostbyname`)과 웹 서버의 이름(`naver.com`)을 쓰기만 하면 `Resolver`를 호출할 수 있다.
  - 단 한 개의 행으로 IP 주소 질의가 끝이 난다. 이제 브라우저는 웹 서버에 메시지를 보낼 때 메모리 영역에 저장된 IP 주소를 추출해 HTTP 리퀘스트 메시지와 함께 OS에 건네주어 송신을 의뢰한다.

```
// C 언어로 작성한 네트워크 애플리케이션의 소스 코드 예시
<애플리케이션 프로그램 이름> (<매개변수>) 
{
  ...
  <메모리 영역> = gethostbyname("naver.com"); // 메모리 영역 안에 서버의 IP 주소가 기입된다.
  ...
  <HTTP 메시지 송신>
  ...
}
```

### 2-5. `Resolver`의 내부 작동

- 네트워크 애플리케이션이 `Resolver`를 호출하면 제어가 `Resolver` 내부로 넘어간다.

1. 리졸버를 호출하는 행을 만나면 애플리케이션의 동작이 일시적으로 정지한다. (제어가 넘어가기 때문에)
2. 애플리케이션에게 의뢰받은 작업을 수행한다.
3. 리졸버가 제어권을 쥐게 되면 DNS 서버에 문의하기 위한 메시지를 만든다. (마치 브라우저가 웹 서버의 요청을 보내기 위해 HTTP 리퀘스트를 만드는 것처럼!)
4. 메시지 송신 동작은 리졸버가 아닌 OS 내부에 포함된 프로토콜 스택을 호출하여 실행된다. (리졸버에도 브라우저와 마찬가지로 네트워크에 대해 데이터를 송수신하는 기능이 없기 때문이다.)
5. 리졸버가 프로토콜 스택을 호출하면 제어가 OS에서 리졸버에게 넘어가고 여기에서 메시지를 보내는 동작을 실행하여 LAN 어댑터를 통해 메시지가 DNS 서버를 향해 송신된다.
6. 액세스 대상의 웹서버가 DNS 서버에 등록되어 있으면 답이 발견되므로 답을 응답 메시지에 작성해 클라이언트에게 반손한다.
7. IP 주소를 담은 메시지는 네트워크를 통해 클라이언트 측에 도착한다. 
8. 이때 메시지는 OS의 프로토콜 스택을 경유하여 리졸버에게 전해진다.
9. 리졸버가 내용을 해독한 후 여기에서 IP 주소를 추출해 애플리케이션에 IP 주소를 전해준다.
10. 리졸버에게 주어진 제어권이 다시 애플리케이션으로 넘어간다. 애플리케이션은 IP 주소를 사용해 웹 서버에 접근한다.

<br/>

# 참고자료

- 성공과 실패를 결정하는 1%의 네트워크 원리, Tsutomu Tone 지음
