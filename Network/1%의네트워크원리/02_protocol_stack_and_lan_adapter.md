# Chapter 02 TCP/IP의 데이터를 전기 신호로 만들어 보낸다.

## 1. 소켓을 작성한다.

### 1-1. 프로토콜 스택의 내부 구성

- OS에 내장된 네트워크 제어용 소프트웨어(**프로토콜 스택**)와 네트워크용 하드웨어(**LAN 어댑터**)가 브라우저에서 받은 메시지를 서버에 송출하는 동작
- 프로토콜 스택의 내부는 역할이 서로 다른 몇 부분으로 나눠져 있다. (아래 그림 참고)
  - 작업을 의뢰하는 쪽이 상위에 의뢰를 받아 실제로 작업하는 쪽이 하위에 있다.
  - 상하 관계는 확실하지 않거나 역전되는 경우도 있으므로 엄밀히 따질 필요는 없다.

<img src="img/protocol-stack.jpg">

> - `TCP`: Transmission Control Protocol
> - `UDP`: User Datagram Protocol
> - `IP`: Internet Protocol
> - `ICMP`: Internet Control Message Protocol
> - `ARP`: Address Resolution Protocol 

- 최상단에 위치한 것은 `네트워크 애플리케이션`이다.
  - 브라우저, 메일러(메일을 읽고 쓰는 소프트웨어), 웹 서버, 메일 서버 등의 프로그램이 여기에 해당한다.
  - 애플리케이션은 `Socket 라이브러리`를 가지고 있으며, 또 `Socket 라이브러리` 안에는 `Resolver`가 내장되어 있다.
- 그 아래는 OS의 내부에 존재하는 `프로토콜 스택`이 있다.
  - 프로토콜 스택은 `TCP`와 `UDP`를 통해 데이터 송/수신 작업을 한다.
  - IP 프로토콜은 패킷 송/수신 동작을 제어하는 부분이다. 인터넷에서 데이터를 운반할 때는 데이터를 작게 나누어 `패킷` 형태로 운반하는데, 이 패킷을 통신 상대까지 운반하는 것이 IP의 주 역할이다.
  - IP 안에는 `ICMP`와 `ARP`라는 프로토콜을 다루는 부분이 포함되어 있다.
  - `ICMP`는 패킷을 운반할 때 발생하는 오류를 통지하거나 제어용 메시지를 통지할 때 사용한다.
  - `ARP`는 IP 주소에 대응하는 이더넷의 `MAC 주소`를 조사할 대 사용한다.
- IP 아래에 있는 `LAN 드라이버`는 LAN 어댑터의 하드웨어를 제어한다.
- 그 아래에 있는 하드웨어인 LAN 어댑터가 실제 송/수신 동작을 수행한다. (케이블에 대해 신호를 송/수신)

> `TCP`와 `UDP`은 언제 사용할까?
> - 브라우저나 메일 등의 일반적인 애플리케이션이 데이터를 송/수신할 경우에는 `TCP`
> - DNS 서버에 대한 조회 등에서 짧은 제어용 데이터를 송/수신할 경우에는 `UDP`

### 1-2. 소켓의 실체는 통신 제어용 제어 정보

- 대표적인 정보로는 통신 상대의 IP 주소는 무엇인가, 포트 번호는 몇 번인가, 통신 동작이 어떤 상태에 있는가 등이 있다.
- 소켓은 개념적인 것이어서 실체가 없으므로 굳이 말하자면 이 제어 정보가 소켓의 실체라고 할 수 있다.
- 프로토콜 스택은 이 제어 정보를 참조하면서 동작한다.
  - 프로토콜 스택은 이것을 참조하여 다음에 무엇을 해야 하는지를 판단하는데 이것이 소켓의 역할이다.

#### netstat 명령어

- 윈도우의 경우 `netstat`이라는 명령으로 소켓의 내용을 화면에 표시할 수 있다.
  - Local Address는 LAN 어댑터 하드웨어에 할당한 IP 주소를 의미한다.

<img src="img/netstat.png">

> netstat 명령어 설명
> - 소켓의 내용을 표시하는 명령어이며, 옵션을 줄 수 있다.
> - `a`: 통신 중인 것뿐만 아니라 통신 개시 전의 것도 포함하여 전부 표시
> - `n`: IP 주소나 포트번호를 번호로 표시
> - `o`: 소켓을 사용하고 있는 프로그램의 PID 표시

> netstat 결과 설명
> - `프로토콜(Proto)` 행
>   - 프로토콜의 종류
>   - 예시에서는 TCP/IP 프로토콜을 사용하여 데이터를 송수신한 것으로 보임. (TCP와 UDP 중 하나)
> - `로컬 주소(Local Address)` 행
>   - netstat 명령을 실행한 기계 자체의 IP 주소와 포트번호
>   - 보통 컴퓨터는 여러 개의 LAN 어댑터를 장착하고 있다. 따라서 여러 개의 IP 주소가 표시되는 것이 대부분이다.
>   - 또한 `0.0.0.0`은 특정 IP 주소와 연결되어 있지 않음을 나타낸다.
> - `외부 주소(Foreign Address)` 행
>   - `0.0.0.0`은 아직 통신이 시작되지 않고 특정 IP 주소나 포트와 연결되어 있지 않은 것을 나타낸다.
>   - 또한 UDP 프로토콜은 소켓을 상대측의 주소나 포트와 연결하지 않으므로 상태측은 `*:*`로 표시된다.
> - `상태(State)` 행
>   - `LISTENING`: 상대의 접속을 기다리고 있는 상태
>   - `ESTABLISHED`: 접속 동작이 끝나고 데이터가 통신 중인지 나타냄
> - `PID` 행
>   - 이 소켓을 사용하고 있는 프로그램의 식별 번호(Program Identifier)

### 1-3. Socket을 호출했을 때의 동작

- `Socket 라이브러리`의 `socket`이나 `connect`를 호출했을 때의 프로토콜 스택 내부 동작 설명

<img src="img/socket-running-with-protocol-stack.jpg">

- 준비 단계에서는 socket을 호출하여 소켓을 만들 것을 의뢰하면 프로토콜 스택은 의뢰에 다라 한 개의 소켓을 만든다.
  - 이 때 프로토콜 스택이 최초로 하는 일은 소켓 한 개 분량의 메모리 영역을 확보하는 것이다.
  - 소켓의 제어 정보를 기록하는 메모리 여역은 처음부터 존재하는 것이 아니므로 먼저 그것을 확보해야 한다.
  - 소켓이 만들어 지면 소켓을 나타내는 디스크립터를 애플리케이션에 알려준다.
  - 디스크립터는 프로토콜 스택의 내부에 있는 다수의 소켓 중 어느 것을 가리키는지를 나타내는 번호표와 같은 정보다.
- 디스크립터를 받은 애플리케이션은 이후 프로토콜 스택에 데이터 송/수신 동작을 의뢰할 때 디스크립터를 통지한다.
  - 소켓에는 누가 누구와 통신하고 있는지, 그리고 그것이 어떤 상태로 있는지 등의 정보가 전부 기록되어 있으므로 디스크립터가 어느 소켓인지를 나타내면 필요한 정보는 전부 프로토콜 스택에서 알 수 있다.
  - 이말인즉슨, 통신 상대의 정보를 애플리케이션에서 일일이 통지받을 필요가 없다는 것이다.

<br/>

## 2. 서버에 접속한다

### 2-1. 접속의 의미

- 소켓을 만들면 애플리케이션은 `connect`를 호출하다.
  - 프로토콜 스택은 자기 쪽의 소켓을 서버측 소켓에 접속한다.
  - 그런데 이더넷이나 통신 회선 등의 케이블은 항상 접속된 상태에 있으므로 케이블은 연결하지 않거나 분리하지 않는다.
- 이더넷이나 통신 회선은 항상 케이블에 연결되어 있으므로 언제나 언제나 신호를 보낼 수 있다.
  - 그러므로 데이터를 신호로 변환하여 송신하기만 하면 언제든지 통신이 가능하다.
  - 소켓을 만든 직후에 애플리케이션에서 데이터 송신 의뢰가 오면 프로토콜 스택은 어떻게 될까?
- 소켓을 만든 직후는 아직 거기에 아무것도 기록되어 있지 않으므로 통신 상대가 누구인지도 모른다.
  - 이 상태에서는 송신 의뢰가 와도 데이터를 어디로 보내면 좋을지 알 수 없다.
  - `서버의 IP 주소나 포트 번호를 프로토콜 스택에 알리는 동작`이 필요하다. 이것은 접속 동작의 한 가지 역할이다.
- 이는 서버측도 마찬가지다.
  - 따라서 클라이언트측에서 `서버측에 통신 동작의 개시를 전달`하는 것이 접속 동작의 역할이다.
- 또한 데이터의 송/수신을 위한 메모리 영역이 필요한데 이 메모리 영역을 '버퍼 메모리'라고 부른다.
  - `버퍼 메모리의 확보`도 '접속'한다는 동작의 의미가 될 수 있다.

### 2-2. 맨 앞부분에 제어 정보를 기록한 헤더를 배치한다

- 제어 정보는 크게 2가지로 나뉜다.
  1. 클라이언트와 서버가 서로 연락을 절충하기 위해 주고받는 제어 정보. => `헤더에 기입되는 정보`
  2. `소켓에 기록되는 정보`

#### 첫 번째, Header에 기입되는 정보

<img src="img/tcp-header.jpg">

- 이것은 접속 동작뿐만 아니라 데이터를 송/수신하는 동작이나 연결을 끊는 동작도 포함하여 통신 동작 전체에서 어떤 정보가 필요한지 검토하여 내용을 TCP 프로토콜의 사양으로 규정하고 있다.
- 이 제어 정보는 패킷의 맨 앞부분에 배치하기 때문에 `TCP Header`라고 부른다.
  - 이더넷이나 IP에도 같은 제어 정보가 있고 이것도 '헤더'라고 부르기 때문에 여러 헤더가 등장해 혼란스럽다.
  - 따라서 이 경우 TCP Header, IP Header, Ethernet Header 등 무엇의 헤더인지 구분할 수 있게 써야 한다.

#### 클라이언트와 서버의 통신 동작

- 클라이언트는 헤더에 필요한 정보를 기록하여 연락을 취하면서 통신 동작을 진행한다.

```
송신측: 데이터 송신 동작을 개시합니다.
수신측: 예, 잘 알겠습니다.
송신측: 00번째 데이터를 보냅니다.
수신측: 00번째 데이터를 받았습니다.
(이하 생략)
```

- 위와 같은 형식으로 헤더에 기록된 제어 정보에 의해 대화가 이뤄진다.
  - 이 대화가 가능하지 않으면 통신이 성립되지 않는다.
  - 헤더는 그만큼 중요하며 헤더의 각 항목의 의미를 알면 통신 동작을 안다고 해도 좋다.

<img src="img/packet-with-header.jpg">

#### 두 번째, 프로토콜 스택의 동작을 제어하기 위한 정보

- 여기에는 애플리케이션에서 통지된 정보, 통신 상대로부터 받은 정보 등이 수시로 기록된다.
- 송/수신 동작의 진행 상황 등도 수시로 기록되고 프로토콜 스택은 하나하나 차례로 정보를 참조하면서 움진인다.
- 그러므로 소켓의 제어 정보는 프로토콜 스택의 프로그램과 일체화되어 있다고 해도 좋다.
- 소켓에 기록한 제어 정보는 상대측에서 볼 수 없다. 왜냐하면 규칙에 따라 헤더에 제어 정보를 기록하여 대화하면 그것으로 클라이언트와 서버가 연락을 취하기 때문이다.
  - 예를 들어 내부 구조가 다른 위도우와 리눅스라는 OS는 프로토콜 스택을 만드는 방법이 다르므로 필요한 제어 정보도 다를 것이다.
  - 하지만 양자는 문제 없이 통실할 수 있으며 컴퓨터와 휴대전화로 통신할 때도 마찬가지다.

### 2-3. 접속 동작의 실제

```
connect(<디스크립터>, <서버측의 IP 주소와 포트 번호>, ...)
```

- 서버측의 IP 주소와 포트 번호를 쓰면 명령이 프로토콜 스택의 TCP 담당 부분에 전달된다.
- 그러면 TCP 담당 부분은 IP 주소로 표시된 상대측의 TCP 담당 부분과 제어 정보를 주고 받는다.
1. 먼저 데이터 송/수신 동작의 개시를 나타내는 제어 정보를 기록한 TCP 헤더를 만든다. (송신처, 수신처, 포트 번호를 기입하고 컨트롤 비트인 `SYN`을 1로 설정)
2. IP 담당 부분에게 건네주어 송신하도록 의뢰, IP 담당 부분은 패킷 송신 동작을 실행해 서버측에 전달
3. 서버에 패킷이 도착하면 서버측의 IP 담당이 이것을 받아 TCP 담당에게 건네준다.
4. 이후 서버측의 TCP 담당이 TCP 헤더를 조사하여 기록되어 있는 수신처 포트 번호에 해당하는 소켓을 찾아낸다.
5. (수신처 포트 번호와 동일한) 접속을 기다리고 있는 상태인 소켓을 발견하면 여기에 필요한 정보를 기록하고 접속 동작이 진행중이라는 상태가 된다.
6. 이 과정이 끝나면 서버의 TCP 담당은 응답을 돌려보낸다. 이 때는 ACK라는 비트를 1로 설정한다. 
7. 클라이언트는 이 응답을 받아 TCP 헤더를 조사하여 서버측의 접속 동작이 성공했는지 확인한다. SYN가 1이면 접속 성공이므로 소켓에 서버의 IP 주소나 포트 번호 등과 함께 소켓에 접속 완료를 나타내는 제어 정보를 기록한다.
8. 클라이언트는 ACK 비트가 1인 응답을 만들어 서버측에 다시 전달한다. 이는 서버측에 패킷이 도착한 것을 알리기 위해서다.

<br/>

## 3. 데이터를 송/수신한다

### 3-1. 프로토콜 스택에 HTTP 리퀘스트 메시지를 넘긴다

- `connect`에서 애플리케이션에 제어가 되돌아오면 데이터 송/수신 동작에 들어간다. 이 동작은 애플리케이션이 `write`를 호출하여 송신 데이터를 프로토콜 스택에 건네주는 곳부터 시작된다.
- 이제 이것을 받은 프로토콜 스택이 송신 동작을 실행한다. 그런데 이 동작에는 몇 가지 중요한 점이 있다.
  - 먼저 프로토콜 스택은 받은 데이터의 내용에 무엇이 쓰여있는지 알지 못한다. `write`를 호출할 때 송신 데이터의 길이를 지정하지만 프로토콜 스택은 해당 길이만큼만 바이너리 데이터가 1바이트씩 차례로 나열되어 있다고 인식할 뿐이다.
- 프로토콜 스택은 받은 데이터를 곧바로 송신하지 않고 일단 자체의 내부에 있는 송신용 버퍼 메모리 영역에 저장하고 애플리케이션이 다음 데이터를 건네주기를 기다린다.
  - 데이터를 전부 한꺼번에 송신 의뢰하는 경우도 있고 1바이트씩 또는 1행씩 세분하여 송신 의뢰하는 경우도 있다.
  - 어느 경우든지 한 번의 송신 의뢰에서 건네주는 데이터의 길이는 애플리케이션의 사정에 따라 결정되며 프로토콜 스택에서 제어할 수 없다.
- 작은 패킷을 많이 보내는 방법은 네트워크의 이용 효율이 저하되므로 어느 정도 데이터를 저장하고 나서 송/수신 동작을 한다.
  - OS의 종류나 버전에 따라 달라지므로 환경에 따라 다르다.

#### MTU & MSS

<img src="img/mtu-mss.jpg">

- 판단 요소의 하나는 한 패킷에 저장할 수 있는 데이터의 크기이다.
- 프로토콜 스택은 `MTU`라는 매개변수를 바탕으로 판단한다. MTU는 한 패킷으로 운반할 수 있는 디지털 데이터의 최대 길이다.
- MTU에는 패킷의 맨 앞부분에 헤더가 포함되어 있으므로 여기부터 헤더를 제외한 것이 하나의 패킷으로 운반할 수 있는 데이터의 최대 길이가 되고 이것을 `MSS`라고 한다.
- 애플리케이션에서 받은 데이터가 `MSS`를 초과하거나 `MSS`에 가까운 길이에 이르기까지 데이터를 저장하고 송신 동작을 하면 패킷이 잘게 나누어질 걱정을 할 필요가 없다.

> 용어 정리
> - `Maximum Transmission Unit, MTU`: 패킷 한 개로 운반할 수 있는 디지털 데이터의 최대 길이. 이더넷에서는 보통 1,500 바이트 
> - `Maximum Segment Size, MSS`: 헤더를 제외하고 한 개의 패킷으로 운반할 수 있는 TCP의 데이터의 최대 길이

#### 타이밍

- 또 한 가지 판단 요소는 타이밍이다. 애플리케이션의 송신 속도가 느려지는 경우 `MSS`에 가깝게 데이터를 저장하면 여기에서 시간이 걸려 송신 동작이 지연되므로 버퍼에 데이터가 모이지 않아도 적당한 곳에서 송신 동작을 실행해야 한다.
- 따라서 프로토콜 스택은 내부에 타이머가 있어서 이것으로 일정 시간 이상 경과하면 패킷을 송신한다.

#### 정리

- 판단 요소는 두 가지이지만 이 둘은 상반된 면도 있다.
  - 전자를 중시하면 패킷 길이가 길어져서 네트워크 이용 효율이 높아지는 반면 버퍼에 머무는 시간만큼 송신 동작이 지연될 우려가 있다.
  - 반면 후자를 숭시하면 지연은 적어지지만 이용 효율이떨어진다.
  - 따라서 양자를 절충해서 적당히 시간을 가늠하여 송신 동작을 실행해야 한다.
- 그러나 TCP 사양에는 절충에 관한 규정이 없으며 실제로 어떻게 판단해야 할지는 프로토콜 스택을 만드는 개발자에게 맡겨져 있다.
  - 그러므로 OS 종류나 버전에 따라 이와 관련된 동작이 달라진다.
- 프로토콜 스택에만 맡긴다면 좋지 않은 일이 생길 수도 있으므로 애플리케이션측에서 송신의 타이밍을 제어하는 여지도 남겨뒀다.

### 3-2. 데이터가 클 때는 분할하여 보낸다

- HTTP 리퀘스트 메시지는 보통 그다지 길지 않으므로 한 개의 패킷에 들어가지만, 폼을 사용하여 긴 데이터를 보낼 경우 한 개의 패킷에 들어가지 않을 만큼 긴 것도 있다.
- 이 경우 송신 버퍼에 저장된 데이터는 MSS의 길이를 초과하므로 다음 데이터를 기다릴 필요가 없다. 따라서 송신 버퍼에 들어있는 데이터를 맨 앞부터 차례대로 MSS의 크기에 맞게 분할하고 분할한 조작을 한 개씩 패킷에 넣어 송신한다.

### 3-3. ACK 번호를 사용하여 패킷이 도착했는지 확인한다

- 이제 데이터를 입력한 패킷이 서버를 향해 송신되는데, 데이터 송신 동작은 이것으로 끝나지 않는다.
- TCP에는 송신한 패킷이 상대에게 올바르게 도착했는지 확인하고 도착하지 않았으면 다시 송신하는 기능이 있으므로 패킷을 송신한 후에는 확인 동작으로 넘어간다.

<img src="img/seq-and-ack01.jpg">

- 클라이언트는 데이터 조각으로 분할할 때 바이트를 세어 시퀀스 번호를 보낸다.
- 서버측은 데이터의 길이를 확인해 거기에 1을 더한 값을 ACK 번호로 보낸다. (`수신 확인 응답`)
- 실제 시퀀스 번호를 생성할 때는 1부터 시작하지 않고 난수를 바탕으로 산출한 초기값으로 시작한다.
  - 시퀀스 번호가 항상 1부터 시작한다고 예측할 수 있으면 거기에 악의적인 공격을 할 우려가 있기 때문이다.
  - 따라서 데이터 송/수신을 시작하기 전에 초기값을 상대에게 알리게 되어 있다. (connect를 SYN 1로 설정하고 거기에 더해 시퀀스 번호 초기값을 같이 보낸다.)
- 사실 TCP의 데이터 송/수신 동작은 양방향이므로 클라이언트에서 서버로 향하는 데이터의 흐름과 서버에서 클라이언트로 향하는 두 가지의 데이터 흐름이 있기 때문에 이에 대응해야 한다.
  - 서버측에서 ACK만 넘기는 것이 아니라, 시퀀스 번호를 붙여 데이터를 넘겨준다는 얘기다.
  - 반대로 클라이언트 측에서도 ACK 번호를 산출해 서버에서 반송한다.

<img src="img/seq-and-ack02.jpg">

- 수신측에 패킷이 올바르게 도착한 것을 확인하고 도착하지 않으면 사지 보내므로 네트워크의 어디에서 오류가 발생했더라도 그것을 전부 검출하여 회복 처리(패킷을 다시 보내는 것)를 할 수 있다.
  - 반대로 말한면 구조가 이렇기 때문에 다른 곳에서 오류 recovery를 할 필요가 없다.
- 이 덕분에 LAN 어댑터, 버터, 라우터 모두 회복 조치를 취하지 않는다.
  - 오류를 검출하면 그 패킷을 버리기만 하는데, 애플리케이션도 마찬가지다.
  - TCP에 맡겨두면 오류가 발생해도 데이터가 문제 없이 상대에게 도착하므로 애플리케이션의 송신 동작은 송신한 채로 끝난다.
  - TCP는 몇 번 시도하다가 회복의 전망이 없다면 데이터 송신 동작을 강제로 종료하고 애플리케이션에 오류를 통지한다. (케이블 분리, 서버 다운 등의 이슈) 

<br/>

# 참고자료

- 성공과 실패를 결정하는 1%의 네트워크 원리, Tsutomu Tone 지음
