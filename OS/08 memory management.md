# 08 메모리 관리 Memory Management

## 출처

- 반효경, 운영체제와 정보기술의 원리

- Abraham Silberschatz, Operating System Concept

- https://rebro.kr/

<hr/>

## 목차

1. [주소 Address](#1-주소-address) <br/>
   &nbsp; 1-1. [주소의 종류](#1-1-주소의-종류) <br/>
   &nbsp; 1-2. [주소 바인딩 address binding](#1-2-주소-바인딩-address-binding) <br/>

<br/>

2. [메모리 관리와 관련한 용어](#2-메모리-관리와-관련한-용어) <br/>
   &nbsp; 2-1. [동적 로딩 Dynamic Loading](#2-1-동적-로딩-dynamic-loading) <br/>
   &nbsp; 2-2. [동적 연결 Dynamic Linking](#2-2-동적-연결-dynamic-linking) <br/>
   &nbsp; 2-3. [중첩 Overlays](#2-3-중첩-overlays) <br/>
   &nbsp; 2-4. [Swapping](#2-4-swapping) <br/>

<br/>

3. [물리적 메모리의 관리 Allocation of Physical Memory](#3-물리적-메모리의-관리-allocation-of-physical-memory) <br/>
   &nbsp; 3-1. [물리적 메모리의 할당 방식](#3-1-물리적-메모리의-할당-방식) <br/>
   &nbsp; 3-2. [연속 할당 Contiguous Allocation](#3-2-연속-할당-contiguous-allocation) <br/>
   &nbsp; 3-3. [불연속 할당 Noncontiguous Allocation](#3-3-불연속-할당-noncontiguous-allocation) <br/>

<br/>

4. [불연속 할당의 기법](#4-불연속-할당의-기법) <br/>
   &nbsp; 4-1. [페이징 Paging](#4-1-페이징-paging) <br/>
   &nbsp; 4-2. [세그멘테이션 Segmentation](#4-2-세그멘테이션-segmentation) <br/>
   &nbsp; 4-3. [페이지드 세그멘테이션 Paged Segmentation](#4-3-페이지드-세그멘테이션-paged-segmentation) <br/>

<br/><br/>

<hr/>

## 1. 주소 Address

<br/>

<hr/>

### 1-1. 주소의 종류

<br/>

컴퓨터에서 주소란 서로 다른 위치를 구분하기 위해 사용하는 일련의 숫자다. 32비트 컴퓨터에서는 총 2<sup>32</sup>개의 서로 다른 메모리 위치를 사용할 수 있고, 64비트 주소체계를 사용하면 2<sup>64</sup>바이트만큼 메몰리 공간에 서로 다른 주소를 할당할 수 있다.<br/>
실세계의 주소에서 행정 구역을 구와 동으로 나눠 구분하기 편하게 도와주듯 컴퓨터 상의 주소도 `페이지`라는 행정 구역을 사용한다. 즉, 32비트를 그대로 사용하지 않고 하위 12비트는 `페이지`를 표현하는 비트로 역할한다. 주소의 종류는 아래와 같다.

<br/>

- `Logical Address(=virtual Address)`
    - 프로세스마다 독립적으로 가지는 주소 공간
    - 각 프로세스마다 0번지부터 시작
    - CPU가 보는 주소는 logical address이다.

<br/>

- `Physical Address`
    - 실제 메모리(RAM)에 올라가는 위치

<br/>

<hr/>

### 1-2. 주소 바인딩 Address Binding

<br/>

주소 바인딩이란 주소를 결정하는 것을 의미한다. 어떤 프로그램이 메모리의 어느 위치에, 즉 어떤 물리적 주소에 load 될지를 결정하는 과정이다. <br/>
프로세스가 실행되기 위해서는 해당 프로그램이 물리적 메모리에 적재되어 있어야 한다. 또한 CPU가 기계어 명령을 수행하기 위해 논리적 주소를 통해 메모리 참조를 하게 되면 해당 논리적 주소가 물리적 메모리의 어느 위치에 매핑되는지를 확인해야 한다. 이렇게 논리적 주소를 물리적 메모리 주소로 연결시켜주는 작업을 주소 바인딩이라고 한다.

<br/>

주소 바인딩은 binding 하는 시점에 따라 분류된다. 

<img src="img/address-binding.png">

<br/>

- Compile time binding
    - 물리적 메모리 주소(Physical address)가 컴파일 시에 정해진다.
    - 컴파일러는 절대 코드(absolute code) 또는 절대 주소(Absolute address)라는 고정된 주소를 생성한다.
    - 시작 위치가 변경된다면 재컴파일해줘야 한다.
    - 컴파일 타임 주소 할당은 프로세스 내부에서 사용하는 논리적 주소와 물리적 주소가 동일하다. 
    - 현대의 시분할 방식에서는 사용하지 않는다.


<br/>

- Load time binding
    - 프로그램이 실행될 때 물리적 메모리 주소가 결정되는 방식이다.
    - Loader의 책임 하에 물리적 메모리 주소가 부여되며 프로그램이 종료될 때까지 물리적 메모리 상의 위치가 고정된다.
    - `Loader`란 사용자 프로그램을 메모리에 적재시키는 프로그램을 말한다.
    - 컴파일러가 재배치 가능 코드(Relocatable code)를 생성한 경우에 가능한 주소 바인딩 방식이다.
    - 컴파일 타임과 마찬가지로 현대의 시분할 방식에서는 사용하지 않는다.

<br/>

- Execution time binding(=Runtime binding)
    - 프로그램이 실행한 이후에도 그 프로그램이 위치한 물리적 메모리 상의 주소가 변경될 수 있는 바인딩 방식이다.
    - CPU가 주소를 참조할 때마다 해당 데이터가 물리적 메모리의 어느 위치에 존재하는지 주소 매핑 테이블(address mapping table)을 이용해 바인딩을 점검한다.
    - 런타임 주소 할당은 MMU(Memory Management Unit)라는 하드웨어 장치를 사용하여 논리적 주소를 물리적 주소로 바꿔준다. 
    - `MMU 기법`은 프로세스가 CPU에서 수행되면서 생성해내는 모든 주소값에 대해서 base register의 값을 더해주어 물리적 주소를 생성하는 방식이다. base register는 하나이므로 프로세스끼리 공유한다. 

<img src="img/mmu.png">

- CPU가 logical address 상의 346번지의 정보를 요청한 그림이다.
- 해당 주소를 실제 메모리에서 얻기 위해 주소 변환 과정이 필요하다.
- relocation register와 limit register, 2개의 레지스터를 이용해 주소변환을 진행한다. virtual memory(logical memory)가 올라가 있는 위치에 logical memory 상에 존재하는 해당 번지의 위치를 더해주면 값을 얻어올 수 있다.

<br/>

#### limit register의 작동

<img src="img/limit-register.jpg">

`Limit register`는 논리적 주소의 범위이며, 잘못된 메모리를 참조하지 않도록 막아주는 기능을 한다. 그리고 Base register(Relocation register)는 접근할 수 있는 물리적 주소의 최솟값을 나타낸다. 만약 커널 모드인 경우에는 MMU가 물리적인 주소로 변환하지 않고 논리적 주소를 그대로 사용한다. 따라서 커널 모드인지 체크하는 과정도 포함되어 있다. 예를 들어 가상메모리의 최대크기가 3000인데 해당 logical memory에 있지도 않은 4000번지를 요구한다면 다른 프로그램의 위치를 요구하는 꼴이기 때문에 그 요구를 거절한다.

<br/><br/>

<hr/>

## 2. 메모리 관리와 관련한 용어

<br/>

<hr/>

### 2-1. 동적 로딩 Dynamic Loading

<br/>

Dynamic Loading이란 프로세스 전체를 메모리에 미리 다 올리는 것이 아니라 해당 루틴이 불려질 때 메모리에 load하는 것을 말한다. 이를 통해 메모리의 이용성(Utilization)을 향상시킬 수 있다. <br/>
가끔씩 사용되는 많은 양의 코드(ex-오류 처리 코드)가 메모리에 올라가는 것을 막아 메모리를 좀 더 효율적으로 사용할 수 있도록 한다. 즉, 프로세스의 주소 공간 전체를 물리적 메모리에 올리는 기존 방식에 비해 같은 크기의 물리적 메모리에 더 많은 프로그램을 적재할 수 있기 때문에 메모리 이용의 효율성이 향상된다.<br/>
운영체제의 특별한 지원 없이 프로그램 자체에서 구현이 가능하다.

<br/>

<hr/>

### 2-2. 동적 연결 Dynamic Linking

<br/>

`연결 Linking`이란 프로그래머가 작성한 소스 코드를 컴파일하여 생성된 목적 파일(object file)과 이미 컴파일된 라이브러리 파일들을 묶어 하나의 실행 파일을 생성하는 과정을 말한다.<br/>
`동적 연결 Dynamic Linking`은 컴파일을 통해 생성된 목적 파일과 라이브러리 파일 사이의 연결을 프로그램의 실행 시점까지 지연시키는 기법을 말한다. <br/>
동적 연결과 대비되는 개념인 `정적 연결 static linking`은 프로그래머가 작성한 코드와 라이브러리 코드가 모두 합쳐저 실행 파일이 되기 때문에 파일의 크기가 상대적으로 큰 편이다.<br/>
반면 동적 연결은 라이브러리 실행 시점에 연결된다. 즉, 실행 파일에 라이브러리를 포함하지 않으며 프로그램이 실행되면서 라이브러리 함수를 호출해야 라이브러리와 연결이 일어나는 것이다. 이를 위해 실행 파일의  라이브러리 호출 부분에 라이브러리 루틴 위치를 찾기 위한 `stub`이라는 작은 코드를 둔다. 라이브러리가 이미 메모리에 있으면 그 루틴의 주소로 가고, 없으면 디스크에서 읽어온다. 메모리의 효율을 높일 수 있는 대신 운영체제의 도움이 필요하다.

<br/>

<hr/>

### 2-3. 중첩 Overlays

<br/>

`Overlays`란 프로세스의 주소 공간을 분할해 실제 필요한 부분만을 적재하는 기법을 말한다. `Dynamic Loading`과 정확히 구분되어야하는 개념이다. 둘은 역사적으로 다르다. <br/>
`Overlays`는 초창기 시스템에서 메모리 제약이 컸을 때 하나의 프로세스조차도 메모리에 한꺼번에 올릴 수 없었기 때문에 프로세스의 주소 공간을 분할해서 당장 필요한 일부분을 메모리에 올려 실행하고 해당 부분이 끝나면 나머지 부분을 올려 실행하는 기법이었다. 즉, 프로세스의 크기가 메모리보다 클 때 유용한 방법이다.<br/>
반면 `Dynamic Loading`는 더 많은 프로세스를 동시에 올려놓고 실행하기 위한 기법이므로 둘의 결이 다르다고 볼 수 있다.

<br/>

<hr/>

### 2-4. Swapping

<br/>

<img src="img/swapping.jpg">

`Swapping`은 메모리에 올라온 프로세스의 주소 공간 전체를 디스크의 스왑 영역(swap area)에 일시적으로 내려놓는 것을 말한다. 이 때 스왑 영역을 `backing store`라고도 부르며 디스크 내에 파일 시스템과는 벼로도 존재하는 영역이다.<br/>
스크로 내보내는 것을 `swap out`, 메모리로 들여보내는 것을 `swap in`이라고 한다. 우선순위(priority)를 기준으로 어떤 프로세스를 swap in/out 할지 결정한다. 우선순위가 낮은 프로세스를 swap out 시키고, 높은 프로세스를 메모리에 올린다. 일반적으로 `Swapper`라고 불리는 중기 스케줄러에 의해 swap out될 대상이 결정된다.<br/>
Swapping이 효율적으로 사용되려면 Runtime Binding 방법으로 주소를 할당하는 것이 swap in/out할 때 좋다.<br/>
프로세스의 메모리 양이 방대한 편이기 때문에 swap time은 대부분 transfer time, 즉 디스크 전송시간이다.

<br/>

<hr/>

## 3. 물리적 메모리의 관리 Allocation of Physical Memory

<br/>

<hr/>

### 3-1. 물리적 메모리의 할당 방식

<br/>

메모리는 일반적으로 `OS 상주 영역`과 `사용자 프로세스 영역`으로 나뉘어 사용된다. 운영체제 상주 영역은 Interrupt Vector와 함께 낮은 주소 영역을 사용하며 운영체제 커널이 이곳에 위치하게 된다. 반면, 사용자 프로세스 영역은 높은 주소 영역을 사용하며 사용자 프로세스들이 적재되어 실행된다.

<br/>

메모리는 일반적으로 커널 영역과 사용자 프로세스 영역으로 나뉘어서 사용된다. 그중 사용자 프로세스 영역의 할당 방법으로는 Contiguous Allocation(연속적 할당), Noncontiguous Allocation(비연속적 할당)으로 나뉜다.

<br/>

낭비되는 메모리 단편화는 아래와 같이 분류할 수 있다.

- `내부 조각 Internal Fragmentation (내부 단편화)`
    - 프로그램 크기보다 분할의 크기가 큰 경우
    - 하나의 분할 내부에서 발생하는 사용되지 않는 메모리 조각
    - 특정 프로그램에 배정되었지만 사용되지 않은 공간

<br/>

- `외부 조각 External Fragmentation (외부 단편화)`
    - 프로그램 크기보다 분할의 크기가 작은 경우
    - 아무 프로그램에도 배정되지 않은 빈 곳인데도 프로그램이 올라갈 수 없는 작은 분할

<br/>

<hr/>

### 3-2. 연속 할당 Contiguous Allocation

<br/>

`연속 할당 Contiguous Allocation`은 프로세스를 메모리에 올릴 때 그 주소 공간을 여러 개로 분할하지 않고 연속적인 메모리 공간을 차지하게 적재한다.<br/>
각 프로세스를 메모리에 담기 위해 메모리는 미리 공간을 분할해두는데, 고정된 크기로 나누는 고정 분할 방식과 프로세스의 크기를 고려해서 나누는 가변 분할 방식이 있다. 

<img src="img/memory-allocate.jpg">

#### 고정 분할 방식

`고정 분할 Fixed partition` 방식은 물리적 메모리를 주어진 개수만큼의 영구적인 분할(partition)으로 나누어 두고 각 분할에 하나의 프로세스를 적재해 실행시킨다. 분할 당 하나의 프로세스가 적재되기 때문에 동시에 메모리에 load 되는 프로세스의 수가 고정된다. 또 수행 가능한 프로세스의 최대 크기가 제한되어 융통성이 떨어진다. 내부 조각과 외부 조각이 모두 발생해 낭비가 심하다.

<br/>

#### 가변 분할 방식

`가변 분할 Variable partition`은 프로세스의 크기를 고려해서 할당하기 때문에 분할의 크기나 개수가 동적으로 변한다. 이를 위해서는 기술적인 관리 기법이 필요하다. 외부 조각만 발생한다.

<br/>

<img src="img/hole.jpg">

가변 분할 방식을 사용하면 `Hole`이라는 가용 메모리 공간이 생기게 된다. Contiguous Allocation에서 메모리를 분할하는 각 단위는 Block이고, 프로세스가 사용할 수 있는 Block을 Hole이라고 한다. 다양한 크기의 Hole들이 메모리 여러 곳에 흩어져 있고, 프로세스가 도착하면 수용 가능한 Hole을 할당시켜준다. <br/>
가변 분할 방식에서 크기가 n인 프로세스가 들어갈 가장 적절한 Hole을 찾는 문제를 Dynamic Storage-Allocation Problem이라고 한다. 3가지의 알고리즘이 존재한다.

- First-fit

크기가 n 이상인 Hole 중 최초로 발견한 Hole에 할당한다. 
 
<br/>

- Best-fit

크기가 n 이상인 가장 작은 Hole을 찾아 할당한다. Hole들이 크기순으로 정렬되지 않은 경우 모든 Hole을 탐색해야 한다는 부담이 있다. 항상 거의 딱 맞는 크기를 할당하기 때문에 할당 후에 아주 작은 Hole들이 많이 생성된다.

<br/>
 
-  Worst-fit

가장 큰 Hole에 할당하는 어리석은 방법이다. 마찬가지로 모든 Hole을 탐색해야 하고, 상대적으로 아주 큰 Hole들이 새로 생성된다. 
 
<br/>

First-fit과 Best-fit이 Worst-fit에 비해서는 속도나 공간 측면에서 효과적인 것으로 알려져 있다. 그러나 전체적으로 효율이 좋지 않은 편이다. 

<br/>

#### Compaction

위의 방법을 사용하지 않고 외부 단편화 문제를 해결하기 위해 `컴팩션 Compaction`을 사용할 수 있다. Compaction은 물리적 메모리 중에서 프로세스에 의해 사용 중인 메모리 영역을 한 곳으로 몰아 하나의 큰 가용 공간인 `Block`을 만드는 방법이다.<br/>
그러나 매우 많은 비용이 드므로 최소한의 메모리 이동으로 compaction을 수행하는 방법이 필요한데 이는 이론적으로 매우 어려운 문제이다. 또한 Compaction은 프로세스의 주소 실행 시간에 동적으로 재배치가 가능한 경우에만 수행될 수 있다는 제약조건도 있다.

<br/>

<br/>

<hr/>

### 3-3. 불연속 할당 Noncontiguous Allocation

<br/>

불연속 할당 방식은 분할 하는 기준에 따라 동일한 크기로 나누어 메모리에 올리는 `페이징 Paging` 기법, 크기가 일정하지 않지만 의미 단위로 나누어 메모리에 올리는 `세그멘테이션 Segmentation` 기법과 세그멘테이션 내에서 동일한 크기의 페이지로 나누어 메모리에 올리는 `페이지드 세그멘테이션 Paged Segmentation`기법으로 나눌 수 있다. 현대의 운영체제에서는 불연속 할당 기법을 사용한다. 

<br/><br/>

<hr/>

## 4. 불연속 할당의 기법

<br/>

<br/>

<hr/>

### 4-1. 페이징 Paging

<br/>

<br/>

<hr/>

### 4-2. 세그멘테이션 Segmentation

<br/>

<br/>

<hr/>

### 4-3. 페이지드 세그멘테이션 Paged Segmentation

<br/>

<br/>

<hr/>