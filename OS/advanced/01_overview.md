# Part1. 개관

- 운영체제는 컴퓨터 사용자와 컴퓨터 하드웨어 사이에서 중개자 역할을 한다.
  - 운영체제의 목적은 사용자가 프로그램을 편리하고 효율적으로 수행할 수 있는 환경을 제공하는 데 있다.
- 웅영체제는 컴퓨터 하드웨어를 관리하는 소프트웨어다.
  - 하드웨어는 컴퓨터 시스템의 정확한 동작을 보장하고 프로그래밍 시스템의 정상적인 동작을 방해하지 않도록 하는 적합한 메커니즘을 제공해야 한다.

# Chapter1. 서론

- 먼저 컴퓨터의 하드웨어의 구성과 구조를 이해하는 것이 중요하다.
  - CPU, 메모리, 입출력 장치, 저장장치
  - 운영체제의 근본적인 책임은 이러한 자원들을 프로그램에 할당하는 것이다.

## 1-1. 운영체제가 할 일

- 컴퓨터 시스템은 대개 네 가지 구성요소인 하드웨어, 운영체제, 응용 프로그램, 사용자로 구분할 수 있다.
  - 하드웨어: 중앙 처리 장치(CPU), 메모리 및 입출력(I/O) 장치 => 기본 계산용 자원을 제공
  - 응용 프로그램: 워드 프로세서, 스프레드시트, 컴파일러, 웹 브라우저 등 => 사용자의 계산 문제를 해결하기 위해 자원이 어떻게 사용될지를 정의
  - 운영체제: 사용자를 위해 다양한 응용 프로그램 간의 하드웨어 사용을 제어하고 조정한다.

### 1-1-1. 사용자 관점

- 컴퓨터에 대한 사용자 관점은 사용되는 인터페이스에 따라 달라진다.
  - 모니터, 키보드, 마우스로 구성된 PC 앞에서 작업한다.
  - 사용자가 자원을 독점하도록 설계 => 목표는 사용자가 수행하는 작업을 최대화하는 것
  - 이런 경우 운영체제는 대부분 사용의 용이성을 위해 설계.
- 점점 더 많은 사용자가 스마트폰과 태블릿과 같은 모바일 장치와 상호 작용
  - 일반적으로 셀룰러 또는 기타 무선 기술을 통해 네트워크에 연결
- 일부 컴퓨터는 사용자 관점이 존재하지 않거나 매우 작은 예도 있다.
  - 가전제품이나 자동차 내의 `내장형 컴퓨터` => 사용자의 개입 없이 작동하도록 설계

> #### 셀룰러 Cellular
> - 이동 무선 통신에서 셀의 설치에 의해 통신망을 구성, 운용하는 것을 말한다.

### 1-1-2. 시스템 관점

- 운영체제 = `자원 할당자 Resource Allocator`
- 자원에 대해 서로 상충할 수도 있는 많은 요청이 있으므로, 운영체제는 컴퓨터 시스템을 효율적이고 공정하게 운영할 수 있도록 어느 요청에 자원을 할당할지를 결정해야 한다.
- 운영체제에 대한 다소 다른 관점은 여러 가지 입출력 장치와 사용자 프로그램을 제어할 필요성을 강조한다.
  - 운영체제는 `제어 프로그램 Contorl Program`이다.
  - 컴퓨터의 부적절한 사용을 방지하기 위해 사용자 프로그램의 수행을 제어한다.
  - 특히 입출력 장치의 제어와 작동에 깊이 관여한다.

### 1-1-3. 운영체제의 정의

- 일반적으로 운영체제에 대한 적합한 정의는 없다.
- 일반적인 정의는 운영체제가 컴퓨터에서 항상 실행되는 프로그램(일반적으로 `커널`이라고 함)이다.
- 커널과 함께 두 가지 다른 유형의 프로그램이 있다.
  - 운영체제와 관련되어 있지만 반드시 커널의 일부일 필요는 없는 `시스템 프로그램`
  - 시스템 작동과 관련되지 않은 모든 프로그램을 포함하는 응용 프로그램
- 모바일 기기의 운영체제를 살펴보면 운영체제를 구성하는 기능의 수가 다시 증가하고 있음을 알 수 있다.
  - 종종 핵심 커널뿐만 아니라 `미들웨어`도 포함된다. 
  - ex) Apple의 IOS와 Google의 Android와 같이 가장 유명한 모바일 운영체제는 데이터베이스, 멀티미디어 및 그래픽을 지원하는 미들웨어와 함께 핵심 커널이 포함되어 있다.

> #### 미들웨어
> - 응용 프로그램 개발자에게 추가 서비스를 제공하는 일련의 소프트웨어 프레임워크

> #### 왜 운영체제를 공부하는가?
> - 운영체제를 만들거나 수정하는 사람은 소수다. 그렇다면 왜 운영체제와 그들의 작동방식을 공부할까?
> - 거의 모든 코드가 운영체제 위에서 실행되므로 운영체제 작동 방식에 대한 지식은 적절하고 효율적, 효과적이며 안전한 프로그래밍에 중요하기 때문이다.

## 1-2. 컴퓨터 시스템의 구성

- 현대의 범용 컴퓨터 시스템은 하나 이상의 CPU와 구성요소와 공유 메모리 사이의 액세스를 제공하는 공통 버스를 통해 연결된 여러 장치 컨트롤러로 구성된다.
  - 각 장치 컨트롤러는 특정 유형의 장치를 담당한다.
  - 컨트롤러에 따라 둘 이상의 장치가 연결될 수도 있다. ex) 하나의 USB 포트에 USB 허브 연결 가능
- 일반적으로 운영체제에는 각 장치 컨트롤러마다 `장치 드라이버`가 있다.
  - 장치 컨트롤러의 작동을 잘 알고 있고 운영체제에 장치에 대한 일관된 인터페이스를 제공한다.
  - CPU와 장치 컨트롤러는 병렬로 실행되어 메모리 사이클을 놓고 경쟁한다.
  - 공유 메모리를 질서 있게 액세스하기 위해 메모리 컨트롤러는 메모리에 대한 액세를 동기화한다.

### 1-2-1. 인터럽트 Interrupts

- 입출력 작업을 시작하기 위해 장치 드라이버는 장치 컨트롤러의 적절한 레지스터에 값을 적재한다.
  - 그런 다음 장치 컨트롤러는 이러한 레지스터의 내용을 검사하여 수행할 작업을 결정한다.
  - 컨트롤러는 장치에서 로컬 버퍼로 데이터 전송을 시작한다.
  - 데이터 전송이 완료되면 장치 컨트롤러는 장치 드라이버에게 작업이 완료되었음을 알린다.
  - 읽기 요청이라면 데이터 또는 데이터에 대한 포인터를 반환하여 운영체제의 다른 부분에 제어를 넘긴다.
  - 다른 작업이라면 "쓰기 완료", "장치 사용 중"과 같은 상태 정보를 반환한다. => `인터럽트`를 사용한다.

#### 1-2-1-1. 개요

- 하드웨어는 어느 순간이든 시스템 버스를 통해 CPU에 신호를 보내 인터럽트를 발생시킬 수 있다.
  - 인터럽트는 운영체제와 하드웨어 상호 작용 방식의 핵심 부분이다.
- CPU가 인터럽트되면, CPU는 하던 일을 중단하고 즉시 고정된 위치로 실행을 옮긴다.
  - 고정된 위치란, 인터럽트를 위한 서비스 루틴이 위치한 시작 주소를 가지고 있는 곳이다.
  - 인터럽트 서비스 루틴이 실행되고, 완료되면, CPU는 인터럽트 되었던 연산을 재개한다. 
- 인터럽트는 컴퓨터 구조의 중요한 부분이다.
  - 각 컴퓨터 설계는 저마다의 인터럽트 메커니즘을 가지고 있으며, 몇 가지 기능은 공통적이다.
  - 인터럽트가 요청되면, 인터럽트를 유발한 장치를 위한 인터럽트 서비스 루틴의 주소를 제공하기 위해 이 주소의 배열인 `인터럽트 벡터`가 인터럽트 요청과 함께 주어진 고유의 유일한 장치 번호로 색인된다.

#### 1-2-1-2. 구현

- `인터럽트 요청 라인 interrupt request line`이라는 선이 있는데, 이는 하나의 명령어의 실행을 완료할 때마다 CPU가 이 선을 감지한다.
  - CPU는 컨트롤러가 인터럽트 요청 라인에 신호를 보낸 것을 감지하면, 인터럽트 번호를 읽고 이 번호를 `인터럽트 벡터`의 인덱스로 사용하여 `인터럽트 핸들러 루틴 interrupt-handler routine`으로 점프한다.
  - 해당 인덱스와 관련된 주소에서 실행을 시작한다.
  - 인터럽트 처리기는 작업 중에 변경될 상태를 저장하고, 인터럽트 원인을 확인하고, 필요한 처리를 수행하고, 상태 복원을 수행하고, `return_from_interrupt` 명령어를 실행하여 CPU를 인터럽트 전 실행 상태로 되돌린다.
  - 장치 컨트롤러가 인터럽트 요청 라인에 신호를 선언하여 인터럽트를 `발생 raise`시키고 CPU는 인터럽트를 `포착 catch`하여 인터럽트 핸들러로 `디스패치 dispatch`하고 핸들러는 장치를 서비스하여 인터럽트를 `지운다 clear`

```mermaid
flowchart
  CPU ---|1| A[장치드라이버 입출력 개시]
  A -->|2| B[입출력 개시]
  B -->|3| C[입력 준비 완료, 출력 완료<br/>혹은 에러가 발생할 때<br/>인터럽트 신호를 발생시킨다.]
  C -->|4| D[CPU는 인터럽트를 전달<br/>받으면, 제어를 인터럽트<br/>핸들러에게 넘김]
  A -..->|CPU는 하나의 명령어 실행을<br/>끝내면 인터럽트 발생 여부 확인| D
  D -->|5| E[인터럽트 핸들러가 데이터를<br/>처리하고 인터럽트에서 복귀]
  E -->|6| F[CPU는 인터럽트로 중단된<br/>작업의 처리를 재개함]
  F -->|7| A
```

- 최신 운영체제에서는 더욱 정교한 인터럽트 처리 기능이 필요하다.
1. 중요한 처리 중에 인터럽트 처리를 연기할 수 있어야 한다.
2. 장치는 적절한 인터럽트 핸들러로 효율적으로 디스패치 할 방법이 필요하다.
3. 운영체제가 우선순위가 높은 인터럽트와 우선순위가 낮은 인터럽트를 구분하고 적절한 긴급도로 대응할 수 있도록 다단계 인터럽트가 필요하다.

- 이 세 가지 기능은 CPU 및 `인터럽트 컨트롤러 하드웨어`에 의해 제공된다.
- 대부분의 CPU에는 2개의 인터럽트 요청 라인이 있다.
  - 하나는 복구할 수 없는 메모리 오류와 같은 이벤트를 위해 예약된 `마스크 불가능 인터럽트 nonmaskable interruput`이다.
  - 두 번째 인터럽트 라인은 `마스킹 가능 maskable`이다. 인터럽트 되어서는 안되는 중요한 명령 시퀀스를 실행하기 전에 CPU에 의해 꺼질 수 있다.
- 벡터 방식 인터럽트 기법의 목적은 서비스가 필요한 장치를 결정하기 위해 하나의 인터럽트 핸들러가 가능한 모든 인터럽트 소스를 검색할 필요를 줄이기 위한 것이다.
  - 그러나 실제로 컴퓨터에는 인터럽트 벡터의 주소 개수보다 많은 장치가 있다.
  - 이 문제를 해결하는 일반적인 방법은 `인터럽트 체인 interrupt chain`을 사용하는 것이다.
- 인터럽트 기법은 또한 인터럽트 `우선순위 레벨 interrupt priority level`을 구현한다.
  - 레벨을 통해 CPU는 모든 인터럽트를 마스킹하지 않고도 우선순위가 낮은 인터럽트 처리를 연기할 수 있고, 우선순위가 높은 인터럽트가 우선순위가 낮은 인터럽트의 실행을 선점할 수 있다.
- 요약하면, 인터럽트는 최신 운영체제에서 비동기 이벤트를 처리하기 위해 사용된다.
  - 장치 컨트롤러 및 하드웨어 오류로 인해 인터럽트가 발생한다.
  - 가장 긴급한 작업을 먼저 수행하기 위해 최신 컴퓨터는 인터럽트 우선순위 시스템을 사용한다.
  - 인터럽트는 시간에 민감한 처리에 빈버하게 사용되므로 시스템 성능을 좋게 하려면 효율적인 인터럽트 처리가 필요하다.

### 1-2-2. 저장장치 구조 Storage Structure

- CPU는 메모리에서만 명령 적재 가능.
  - `RAM, Random-Access Memory`라는 재기록 가능한 메모리. => `DRAM, Dynamic Random-Access Memory`라 불리는 반도체 기술로 구현.
- 또한 `부트스트랩 프로그램`을 적재하기 위해 비휘발성 메모리인 `ROM`을 사용
  - 전기적으로 소거 가능한 프로그램 가능 읽기 전용 메모리 `EEPROM` 및 기타 형태의 `펌웨어`(쓰기 작업이 자주 발생하지 않고 비휘발성인 저장장치)
- `폰 노이만 구조 시스템`에서 실행되는 전형적인 명령-실행 사이클은 먼저 메모리부터 명령을 인출해, 그 명령을 `명령 레지스터 instruction register`에 저장한다.
  - 메모리 장치는 단지 일련의 메모리 주소만 인식.
  - 이들 주소[instruction counter, indexing, indirection, literal addresses 등]가 어ㄸㅎ게 생성되었는지 알지 못하며, 그것이 무엇인지 알지 못한다.

> #### 워드
> - 그 컴퓨터 구조의 본연의 데이터 단위
> - 예를 들어 64비트 컴퓨터라면 한 워드는 8바이트(64비트)다.

- 모든 프로그램과 데이터를 영구히 저장하기에 메인 메모리가 너무 작고, 휘발성이기 때문에 `보조저장장치`를 사용한다.
  - HDD, 비휘발성(NVM) 장치
  - NVM 장치의 가장 일반적인 형태는 플래시 메모리이다.
- 비휘발성 저장장치는 전원이 꺼졌을 때 내용을 유지한다. 이를 `NVS`라고 한다. 대부분의 경우 `NVS`는 보조저장장치를 가리킨다. 보통 2가지로 분류된다.
  - `기계적`: HDD, 광 디스크, 홀로그램 저장 장치 및 자기 테이프.
  - `전기적`: 플래시 메모리, FRAM, NRAM, SSD. 책에서는 `NVM`으로 언급.

## 1-2-3. 입출력 구조 I/O Structure

- 운영체제 코드의 상당 부분은 시스템 안정성과 성능에 대한 중요성과 장치의 다양한 특성으로 인해 I/O 관리에 할애된다.
- NVS I/O와 같은 대량 데이터 이동을 사용할 때 높은 오버헤드를 유발할 수 있으므로 `직접 메모리 액세스 DMA, Direct Memory Access`와 같은 기능이 사용된다.
  - 장치에 대한 버퍼 및 포인터, 입출력 카운트를 세팅한 후 장치 제어기는 **CPU의 개입 없이** 메모리로부터 자신의 버퍼 장치로 또는 버퍼로부터 메모리로 데이터 블록 전체를 전송한다.
  - 한 바이트마다 인터럽트가 발생하지 않고, 블록 전송이 완료될 때마다 인터럽트가 발생한다.

# 참고자료

- 운영체제 | Abraham Silberschatz, Peter Baer Galvin, Greg Gagne 저/박민규 역 | 퍼스트북