# Chapter10. 상속과 코드 재사용

- 객체지향 프로그래밍의 장점 중 하나는 코드를 재사용하기가 용이하다는 것이다.
  - 전통적인 패러다임에서 코드를 재사용하는 방법은 코드를 복사한 후 수정하는 것이다.
- 객체지향에서는 코드를 재사용하기 위해 '새로운' 코드를 추가한다.
  - 객체지향에서 클래스를 재사용하는 전통적인 방법은 새로운 클래스를 추가하는 것이다.
  - 가장 대표적인 기법으로는 `상속`이 있다.
  - 재사용 관점에서 상속이란 클래스 안에 정의된 인스턴스 변수와 메소드를 자동으로 새로운 클래스에 추가하는 구현 기법이다.
- 상속 외에도 코드를 효과적으로 재사용할 수 있는 방법이 한 가지 더 있다.
  - 인스턴스 안에 기존 클래스의 인스턴스를 포함시키는 방법으로 흔히 `합성`이라고 부른다.
- 코드를 재사용하려는 강력한 동기 이면에는 중복된 코드를 제거하려는 욕망이 숨어 있다.

<br/>

## 1. 상속과 중복 코드

- 중복 코드는 사람들의 마음 속에 의심과 불신의 씨앗을 뿌린다.
  - 유사한 코드가 이미 존재하는데도 새로운 코드를 만든 이유는 무엇일까?
  - 의도한 것인가? 실수인가? 중복이기는 한 걸까? 중복을 없애도 문제가 없을까?

### DRY 원칙

- `Don't Repeat Yourself`
- 중복 코드는 변경을 방해한다. 이것이 중복 코드를 제거해야 하는 가장 큰 이유다.
- 프로그램의 본질은 비즈니스와 관련된 지식을 코드로 변환하는 것이다. 안타깝게도 이 지식은 항상 변한다. 그에 맞춰 지식을 표현하는 코드 역시 변경해야 한다.
- 중복 코드가 가지는 가장 큰 문제는 코드를 수정하는 데 필요한 노력을 몇 배로 증가시킨다는 점이다.
  - 우선 어떤 코드가 중복인지를 찾아야 한다.
  - 찾아낸 코드를 일관되게 수정해야 한다.
  - 모든 중복 코드를 개별적으로 테스트해서 동일한 결과를 내놓는지 확인해야만 한다.
  - 중복 코드 => 수정과 테스트 비용 증가
- 중복 여부를 판단하는 기준은 변경
  - 요구사항이 변경됐을 때 두 코드를 함께 수정해야 한다면 이 코드는 중복.
  - 중복 코드를 결정하는 기준은 코드의 모양이 아니다. 모양이 유사하다는 것은 단지 중복의 징후일 뿐이다.

### 중복과 변경

#### 중복 코드 살펴보기

- 한 달에 한 번씩 가입자별로 전화 요금을 계산하는 간단한 애플리케이션을 개발.
- 요구사항
  - 10초당 5원의 통화료 부과
- 만약 심야 할인 요금제라는 요구 사항이 들어온다면?
  - 밤 10시 이전 10초당 5원
  - 밤 10시 이후 10초당 2원
- 가장 빠른 방법은 `Phone`을 복사해서 `NightlyDisountPhone`이라는 새로운 클래스를 만든 후 수정하는 것이다.
- 하지만 구현 시간을 절약한 대가로 지불해야 하는 비용은 예상보다 크다.
  - `Phone`과 `NightlyDiscountPhone` 사이에는 중복 코드가 존재하기 때문에 언제 터질지 모르는 시한폭탄을 안고 있는 것과 같다.

#### 중복 코드 수정하기

- 새로운 요구사항을 추가
  - 통화 요금에 부과할 세금 계산
  - 부과되는 세율은 가입자의 핸드폰마다 다르다.
- 현재 통화 요금을 계산하는 로직은 `Phone`과 `NightlyDiscountPhone` 양쪽 모두에 구현돼 있기 때문에 세금을 추가하기 위해서는 두 클래스를 함께 수정해야 한다.
- 중복 코드는 항상 함께 수정해야 하기 때문에 하나라도 빠트린다면 버그로 이어질 것이다.
  - 만약 `Phone`만 수정되고 `NightlyDiscountPhone`은 수정하지 않은 채 코드가 배포됐다면? => 심야 할인 요금제의 모든 가입자에게 세금이 부과되지 않는 장애가 발생할 것이다.

#### 타입 코드 사용하기

- 두 클래스 사이의 중복 코드를 제거하는 한 가지 방법은 클래스를 하나로 합치는 것이다.
  - 타입 코드의 값에 따라 로직을 분기시켜 `Phone`과 `NightlyDiscountPhone`을 하나로 합칠 수 있다.
  - 하지만 타입 코드를 사용하는 클래스는 낮은 응집도와 높은 결합도라는 문제에 시달리게 된다.

### 상속을 이용해서 중복코드 제거하기

- 이미 존재하는 클래스와 유사한 클래스가 필요하다면 코드를 복사하지 말고 상속을 이용해 코드를 재사용할 수 있다.
- 상속을 염두에 두고 설계되지 않은 클래스를 상속을 이용해 재사용하는 것은 생각처럼 쉽지 않다.
  - 개발자는 재사용을 위해 상속 계층 사이에 무수히 많은 가정을 세웠을지도 모른다.
  - 그리고 그 가정은 코드를 이해하기 어렵게 만들뿐만 아니라 직관에도 어긋날 수 있다.
- 요구사항과 구현 사이의 차이가 크면 클수록 코드를 이해하기 어려워진다.
  - 잘못 사용된 상속은 이 차이를 더 크게 벌린다.
- 실제 프로젝트에서 마주치게 될 클래스의 상속 계층은 매우 깊을 것이고, 깊고 깊은 상속 계층의 계단을 하나 내려올 때마다 이해하기 어려운 가정과 마주하게 될 수도 있다.
  - 상속은 결합도를 높인다.
  - 상속이 초래하는 부모 클래스와 자식 클래스 사이의 강한 결합이 코드를 수정하기 어렵게 만든다.

### 강하게 결합된 Phone과 NightlyDiscountPhone

- 부모 클래스와 자식 클래스 사이의 결합이 문제인 이유.
- `NightlyDiscountPhone`을 `Phone`의 자식 클래스로 만든 이유는 `Phone`의 코드를 재사용하고 중복 코드를 제거하기 위해서다.
  - 하지만 세금을 부과하는 로직을 추가하기 위해 `Phone`을 수정할 때 유사한 코드를 `NightlyDiscountPhone`에도 추가해야 했다.
  - 코드 중복을 제거하기 위해 상속을 사용했음에도 세금을 계산하는 로직을 추가하기 위해 새로운 중복 코드를 만들어야 하는 것이다.
- 이것은 `NightlyDiscountPhone`이 `Phone`의 구현에 너무 강하게 결합돼 있기 때문에 발생하는 문제다.

> #### 상속을 위한 경고1
> 자식 클래스의 메소드 안에서 super 참조를 이용해 부모 클래스의 메소드를 직접 호출할 경우 두 클래스는 강하게 결합된다. super 호출을 제거할 수 있는 방법을 찾아 결합도를 제거하라.

- 이처럼 상속 관계로 연결된 자식 클래스가 부모 클래스의 변경에 취약해지는 현상을 가리켜 취약한 기반 클래스 문제라고 부른다.
  - 취약한 기반 클래스 문제는 코드 재사용을 목적으로 상속을 사용할 때 발생하는 가장 대표적인 문제다.

<br/>

# 참고자료

- 오브젝트, 조영호 지음