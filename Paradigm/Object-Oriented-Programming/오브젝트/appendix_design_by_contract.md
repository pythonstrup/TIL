# 부록 A. 계약에 의한 설계 Design By Contract

- 인터페이스만으로는 객체의 행동에 관한 다양한 관점을 전달하기 어렵다.
- 우리에게 필요한 것은 명령의 부수효과를 쉽고 명확하게 표현할 수 있는 커뮤니케이션 수단이다.
- 계약에 의한 설계를 사용하면 협력에 필요한 다양한 제약과 부수효과를 명시적으로 정의하고 문서화할 수 있다.

## 1. 협력과 계약

### 부수효과를 명시적으로

- 인터페이스는 객체가 수신할 수 있는 메시지는 정의할 수 있지만 객체 사이의 의사소통 방식은 명확하게 정의할 수 없다.
- 메시지의 이름과 파라미터 목록은 시그니처를 통해 전달할 수 있지만 협력을 위해 필요한 약속과 제약은 인터페이스를 통해 전달할 수 없기 대문에 협력과 관련된 상당한 내용이 암시적인 상태로 남게 된다.
- 일반적인 정합성 체크 로직은 코드의 구현 내부에 숨겨져 있어 실제로 코드를 분석하지 않는 한 정확하게 파악하기가 쉽지 않다.
  - 게다가 일반 로직과 조건을 기술한 로직을 구분하기도 쉽지 않다.
- 하지만 Code Contract와 같이 계약에 의한 설계 개념을 지원하는 라이브러리나 언어들은 일반 로직과 구분할 수 있도록 제약 조건을 명시적으로 표현하는 것이 가능하다.

```java
// IsSatisfied(schedule)이 true일 때만 호출 가능.
Contract.Requires(IsSatisfied(schedule));
```

- 이렇게 작성된 계약은 문서화로 끝나는 것이 아니라 제약 조건의 만족 여부를 실행 중에 체크할 수 있다.
  - 또한 이 조건들을 코드로부터 추출해 문서를 만들어주는 자동화 도구도 제공한다.

### 계약

> - 각 계약 당사자는 계약으로부터 `이익 benefit`을 기대하고 이익을 얻기 위해 `의무 obligation`을 이행한다.
> - 각 계약 당사자의 이익과 의무는 계약서에 `문서화`된다.

- 한쪽의 의무가 반대쪽의 권리가 된다.
- 계약을 이행하는 구체적인 방식에 대해서는 간섭하지 않는다는 사실도 기억하라.
- 계약은 협력을 명확하게 정의하고 커뮤니케이션할 수 있는 범용적인 아이디어다.

<br/>

## 2. 계약에 의한 설계

- 계약에 의한 설계 개념은 "인터페이스에 대해 프로그래밍하라"는 원칙을 확장한 것이다.
- 우리는 메소드의 이름과 매개변수의 이름을 통해 오퍼레이션이 클라이언트에게 어떤 것을 제공하려고 하는지를 충분히 설명할 수 있다.
  - `의도를 드러내는 인터페이스`를 만들면 오퍼레이션의 시그니처만으로도 어느 정도까지는 클라이언트와 서버가 협력을 위해 수행해야 하는 제약조건을 명시할 수 있다.
- 계약은 여기서 한걸음 더 나아간다.
  1. 서버는 자신이 처리할 수 있는 범위의 값들을 클라이언트가 전달할 것이라고 기대한다.
  2. 클라이언트는 자신이 원하는 값을 서버가 반환할 것이라고 예상한다.
  3. 클라이언트는 메시지 전송 전과 후의 서버의 상태가 정상일 것이라고 기대한다.
- 이 세 가지 기대가 바로 계약에 의한 설계를 구성하는 세 가지 요소에 대응된다. 이 요소들을 순서대로 사전조건, 사후조건, 불변식이라고 부른다.
1. `사전조건 precondition`: 메소드가 호출되기 위해 만족돼야 하는 조건. 메소드의 요구사항을 명시. 사전조건이 만족되지 않으면 메소드가 실행되어서는 안 된다. 사전조건을 지키는 것이 클라이언트의 의무
2. `사후조건 postcondition`: 메소드가 실행된 후에 클라이언트에게 보장해야 하는 조건. 사전조건이 만족 => 사후조건에 명시된 조건을 지켜야 함. 사전조건을 지켰는데도 사후조건을 지킬 수 없다면 클라이언트에게 예외를 던져야 한다.
3. `불변식 invariant`: 항상 참이라고 보장되는 서버의 조건. 메소드가 실행되는 도중에는 불변식을 만족시키지 못할 수도 있지만 메소드를 실행하기 전이나 종료된 후에 불변식은 항상 참이어야 한다.

### 사전조건

```C#
public Reservation Reserve(Customer customer, int audienceCount) 
{
    Contract.Requires(cutomer != null);
    Contract.Requires(audienceCount >= 1);
    return Reservation(customer, this, calculateFee(audienceCount), audienceCount);
}
```

- 사전 조건을 만족시킬 책임은 `Reserve` 메소드를 호출하는 클라이언트에게 있다.
- 계약을 일반 로직과 분리해서 서술함으로써 계약을 좀 더 두드러지게 강조할 수 있다.
- 또한 계약이 메소드의 일부로 실행되도록 함으로써 계약을 강제할 수 있다.

### 사후조건

- 메소드의 실행 결과가 올바른지 검사하고 실행한 후에 객체가 유효한 상태로 남아 있는지를 검증.
- 보통 세 가지 용도로 사용된다.
1. 인스턴스 변수의 상태가 올바른지를 서술하기 위해
2. 메소드에 전달된 파라미터의 값이 올바르게 변경됐는지를 서술하기 위해
3. 반환값이 올바른지를 서술하기 위해
- 하지만 다음과 같은 두 가지 이유로 인해 사전조건보다 사후조건을 정의하는 것이 더 어려울 수 있다.
1. 한 메소드 안에서 return 문이 여러 번 나올 경우
  - 모든 return 문마다 결과값이 올바른지 검증하는 코드 추가 필요.
  - 다행히도 계약에 의한 설계를 지원하는 대부분의 라이브러리는 결괏값에 대한 사후조건을 한번만 기술 할 수 있게 해준다.
2. 실행 전과 실행 후의 값을 비교해야 하는 경우
  - 실행 전의 값이 메소드 실행으로 인해 다른 값으로 변경됐을 수 있기 때문에 두 값을 비교하기 어려울 수 있다.
  - 다행히 계약에 의한 설계를 지원하는 대부분의 라이브러리는 실행 전의 값에 접근할 수 있 간편한 방법을 제공.

### 불변식

- 사전조건과 사후조건은 각 메소드마다 달라지는 데 반해 불변식은 인스턴스 생명주기 전반에 걸쳐 지켜져야 하는 규칙을 명세한다.
- 일반적으로 불변식은 객체의 내부 상태와 관련이 있다. 불변식은 다음과 같은 두 가지 특성을 가진다.
1. 불변식은 클래스의 모든 인스턴스가 생성된 후에 만족돼야 한다. 이것은 클래스에 정의된 모든 생성자는 불변식을 준수해야 한다는 것을 의미한다.
2. 불변식은 클라이언트에 의해 호출 가능한 모든 메소드에 의해 준수돼야 한다. 메소드가 실행되는 중에는 객체의 상태가 불안정한 상태로 빠질 수 있기 때문에 불변식을 만족시킬 필요는 없지만 메소드 실행 전과 메소드 종료 후에는 항상 불변식을 만족하는 상태가 유지돼야 한다.

<br/>

# 참고자료

- 오브젝트, 조영호 지음
