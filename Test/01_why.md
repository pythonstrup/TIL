# 테스트?

## `자동 테스트`의 정체?

가장 단순한 테스트는 다음 요소들로 정의할 수 있다.

- 테스트하려는 단 하나의 행위(주로 메소드나 API)
- 특정한 입력(API에 전달하려는 값)
- 관측 가능한 출력 혹은 동작
- 통제된 조건(하나의 격리된 프로세스 등)

이런 테스트를 실행한다면 시스템에 특정 값을 입력하고 출력 결과를 확인하여 시스템이 기대한 대로 동작한 것인지를 판단하게 될 것이다. 그리고 간단한 테스트가 수백에서 수천 개 모이면 `테스트 스위트` 제품이 전체적으로 의도한 설계대로 잘 작동하는지 혹은 언제 그렇지 못한 지를 이야기할 수 있게 된다.
코드베이스의 덩치에 비례해 테스트 스위트도 커진다. 그 과정에서 테스트 결과가 일관되지 못하거나 느려지는 문제가 나타나기도 한다. 이런 문제를 해결하지 못하면 테스트 스위트의 존폐가 위태로워진다. 테스트는 테스트 엔지니어에게 신뢰를 줄 때만 가치가 있다는 사실을 잊지 말아야 한다.

# 테스트는 왜 해야 하는가?

### 구글 웹 서버 이야기

- 구글에서도 처음엔 엔지니어 주도 테스트를 중요하게 여기지 않았다고 함. 똑똑한 엔지니어가 소프트웨어를 알아서 올바르게 만들어줄 것이라고 기대했기 때문이다.
- 하지만 2005년 GWS(구글 검색 쿼리를 제공하는 웹 서버)의 규모와 복잡성이 커지면서 생산성이 급격히 떨어졌다. 릴리스 때마다 버그가 넘쳐났고 다음 릴리스까지의 기간도 점점 길어졌다.
- 서비스를 수정해야 할 때면 팀원들은 불안해 했고 프로덕션 환경에서만 기능들이 작동하지 않는 일도 잦았다. 한 때는 프로덕션에 추가된 기능의 80% 이상이 사용자에까지 영향을 주는 버그를 담고 있어서 롤백해야만 했다.

### 구글의 결단

- GWS의 테크 리드(TL)는 엔지니어 주도의 자동 테스트를 정책 차원에서 도입하기로 결정
- 이 정책의 일환으로 모든 코드 변경에는 지속해서 실행할 수 있는 테스트가 반드시 딸려 있어야 했다.
- 정책 도입 1년 만에 긴급 배포 건수가 절반으로 줄어들었다고 한다. => 구글의 테스트 문화를 격변시키는 분수령이 되었다. 모두가 테스트의 이점을 목격하면서 다른 팀들도 비슷한 전략을 도입하기 시작한 것이다.
- 여기서 핵심은 제품 결함 해결을 프로그래머의 능력에만 의존해서는 안 된다는 사실이다.
  - 개별 엔지니어가 버그를 심는 빈도는 아주 낮더라도 프로젝트가 커져 팀원이 많아지면 결함 목록은 계속 길어질 것이다.
- 최고의 팀은 팀원들의 집단 지성을 팀 전체의 이익으로 환원하는 방법을 찾아낸다. 바로 자동 테스트가 하는 일이다.
  - 개별 엔지니어가 작성한 테스트는 팀이 공유하는 자원 풀에 추가된다.
  - 따라서 팀원 모두가 공유된 테스트를 수행하고 결함을 찾아낼 수 있다.

### 작성하고 수행하고 조치하라

- 가장 순수한 형태의 자동 테스트는 아래 3가지 활동으로 이뤄진다.
1. 테스트 작성
2. 테스트 수행
3. 실패한 테스트에 대한 조치

- 자동 테스트는 적은 양의 코드로 구성된다. 보통은 테스트 대상 시스템의 일부를 호출하는 함수나 메소드 하나로 만들어진다.
- 테스트 코드는 환경을 원하는 모습으로 설정하고 시스템을 호출하며 결과를 검증한다.
- **시스템의 규모와 배포 속도를 따라잡으려면 모든 엔지니어가 테스트도 함께 개발해야만 한다.**
  - 물론 테스트를 작성하는 것과 좋은 테스트를 작성하는 것은 별개다.
- 테스트 코드를 작성하면 다양한 환경에서 수행할 수 있도록 테스트들을 모듈화하기도 좋다.
  - 예를 들어 파이어폭스에서 실행하던 Gmail을 크롬에서 실행한다고 해서 테스트 코드가 크게 달라질 것은 없다.
  - 두 시스템에 맞춰 설정 정보만 테스트에 제공하면 된다.
- 가장 중요한 것은 테스트가 실패하면 바로바로 조치하도록 권장해야 테스트 프로세스를 신뢰하고 계속 이어갈 수 있다.

### 테스트 코드가 주는 혜택

- 디버깅 감소
  - 테스트를 거친 후의 코드는 통상적으로 결함이 적다.
- 코드를 자신 있게 변경할 수 있다.
  - 테스트들이 프로젝트의 주요 기능들을 끊임없이 검증해주는 덕분이다.
  - 이런 프로젝트에서는 자연스럽게 리팩토링을 권장한다.
- 더 나은 문서자료
  - 코드가 특정 상황에서 어떻게 동작하는지 궁금하다면 그 상황을 검증하는 테스트를 보면 된다.
  - 나아가 요구사항이 변경되어 새로운 코드가 기존 테스트를 통과하지 못한다면 그 문서자료가 이제 낡았음을 분명히 알 수 있다.
- 더 단순한 리뷰
  - 다양한 측면에서 코드를 검사해주는 테스트가 준비되어 있다면 리뷰어가 변경된 코드가 제대로 작동하는지 검증하는 시간을 크게 줄여준다.
- 사려 깊은 설계
  - 테스트하기 어려운 코드는 너무 많은 역할을 가지고 있거나 의존성을 관리하기 어렵게 짰기 때문일 가능성이 크다.
  - 잘 설계된 코드라면 모듈화가 잘되어 있고, 이런 코드는 테스트하기 쉽다. (고로 테스트를 짜면 테스트 짜기 쉬운 구조를 생각하게 되고 이는 모듈화가 잘된 코드를 만드는 것에 도움이 될 수 있다.)

# 2. 테스트는 어떻게 해야하는가?

- `크기 size`는 테스트가 소비하는 자원과 수행할 수 있는 작업을 뜻한다.
- `범위 scope`는 테스트가 검증하고자 하는 코드의 양을 의미한다.
- 테스트 요소별로 알아보자.

# (1) 단위 테스트

- 구글에서 말하는 `단위 테스트 unit test`는 단일 클래스나 메소드처럼 범위가 상대적으로 좁은 테스트를 의미한다. 단위테스트는 일반적으로 크기가 작지만 반드시 그런 건 아니다.
- 범위가 더 넓은 테스트들과 비교해 단위 테스트는 생산성을 끌어올리는 훌륭한 수단이 될 수 있는 특성을 많이 지니고 있다.
- 대체로 대상 코드와 동시에 작성할 수 있을 만큼 작성하기 쉽다. 따라서 커다란 시스템을 설정하거나 이해할 필요 없이 작성 중인 코드를 검증하는 데 집중할 수 있다.
- 각각의 테스트는 개념적으로 간단하고 시스템의 특정 부분에 집중하므로 실패 시 원인을 파악하기 쉽다.
- 구글에서는 단위 테스트의 비율이 80%라고 한다.

## 깨지기 쉬운 테스트 예방하기

- `깨지기 쉬운 테스트`란 실제로는 버그가 없음에도 심지어 검증 대상 코드와 관련조차 없는 변경 때문에 실패하는 테스트를 말한다.
- 코드를 변경할 때마다 테스트가 엄청나게 깨진다면..? 개발팀은 테스트를 유지보수하느라 점점 더 많은 시간을 허비해야 한다.
  - 수동으로 매번 테스트를 손봐야 한다면 '자동화된 테스트 스위트'라고 부르기도 민망하다.
- 테스트가 변경에 영향을 덜 받도록 해주는 관례와 패턴들이 존재한다.

### (i) 변하지 않는 테스트

- 이상적인 테스트라면 변하지 않아야 한다. 한 번 작성한 후로는 대상 시스템의 요구사항이 바뀌지 않는 한 절대 수정할 일이 없어야 한다.
- 우리는 엔지니어가 제품 코드를 변경하는 유형을 생각해보고 그 유형별로 테스트가 어떻게 대응해야 하는지를 따져봐야 한다. 기본적인 유형 4가지는 아래와 같다.
1. 순수 리팩토링
  - 외부 인터페이스를 놔두고 내부만 리팩토링한다면 테스트는 변경되지 않아야 한다. 성능 최적화, 코드 가독성 개선 등이 여기에 속한다.
  - 리팩토링 과정에서 테스트를 변경해야 한다면 원인은 둘 중 하나다. (1) 시스템의 행위가 달라졌거나 (순수 리팩토링 X) (2) 테스트의 추상화 수준이 적절하지 않다는 뜻이다.
2. 새로운 기능 추가
  - 새로운 기능이나 행위를 추가할 때 기존 행위들에 영향을 주지 않아야 한다.
  - 새 기능을 검증할 테스트를 새로 작성해야 하며 기존 테스트들은 변경되지 않아야 한다.
  - 새로운 기능을 추가했는데 기존 테스트를 변경해야 한다면 해당 테스트가 검증하는 기능에 의도치 않은 영향을 주었거나 테스트 자체에 문제가 있다는 뜻이다.
3. 버그 수정
  - 버그 수정은 새로운 기능 추가와 비슷하다.
  - 버그가 존재한다는 것은 기존 테스트 스위트에 빠진 것이 있다는 신호다. <u>버그 수정과 동시에 누락된 테스트를 추가해야 한다.</u>
4. 행위 변경
  - 시스템의 기존 행위를 변경하는 겨우 기존 테스트 역시 변경되어야 한다. 앞의 3가지보다 비용이 더 든다.
  - 행위를 변경하려면 혼란에 빠지거나 업무가 중단되는 사용자가 없도록 조치해줘야 한다.
  - 테스트를 변경한다는 것은 시스템이 한 약속을 의도적으로 변경한다는 뜻이다.
  - 저수준 라이브러리라면 사용자의 시스템을 망가트릴 일이 없도록 애초부터 행위를 변경할 일이 없게끔 설계하는 데 엄청난 노력을 기울인다.

### (ii) 공개된 API를 이용해 테스트 하자.

- 공개 API란 서드파티에 노출한 API이다.
  - 단순히 인터페이스나 public 메소드를 의미하는 것은 아니다. 
  - 예를 들어 어떤 public class는 단지 같은 단위에 속하는 다른 패키지에서 사용할 용도일 뿐 단위 외부의 접근까지 허용할 의도는 없을 수 있다.
- 공개된 API만 이용하는 테스트는 정의상 대상 시스템을 사용자와 똑같은 방식으로 사용한다. 더 현실적이고 잘 깨지지 않는다.
  - 이런 테스트가 깨진다면 다른 사용자도 같은 문제를 겪고 있다는 신호다.
- 공개 API 단위의 범위를 잘 정해서 어디까지가 공개 API인가를 정하는 일에 정답은 없다. 대신 쓸만한 경험 법칙은 있다.
  - 소수의 다른 클래스를 보조하는 용도가 다인 메소드나 클래스라면 독립된 단위로 생각하지 않는 게 좋다. 따라서 이런 메소드나 클래스는 직접 테스트하지 말고 이들이 보조하는 클래스를 통해 우회적으로 테스트해야 한다.
  - 소유자의 통제 없이 누구든 접근할 수 있게 설계된 패키지나 클래스라면 거의 예외 없이 직접 테스트해야 하는 단위로 취급해야 한다. 이때도 테스트는 사용자와 똑같은 방식으로 접근한다.
  - 소유자만 접근할 수 있지만 다방면으로 유용한 기능을 제공하도록 설계된 패키지나 클래스 역시 직접 테스트해야 하는 단위로 봐야 한다.

### (iii) 상호작용이 아니라 상태를 테스트하자.

- 시스템이 기대한 바대로 동작하는지 검증하는 방법은 크게 2가지이다.
  1. `상태 테스트 state test`
  2. `상호작용 테스트 interaction test`
- 대체로 상호작용 테스트는 상태 테스트보다 깨지기 쉽다.
  - 우리가 진짜 원하는 것은 결과가 `무엇 what`이냐지만 상호작용 테스트는 결과에 도달하기까지 시스템이 `어떻게 how` 작동하냐를 확인하려 든다.
- 아래 테스트는 데이터베이스의 특정 API가 호출됐는지를 검증한다. 하지만 설계 의도와 달리 이상하게 테스트가 굴러갈 수 있다.
  1. 시스템에 버그가 있어서 레코드가 쓰인 직후 삭제돼도 테스트는 성공한다.
  2. 시스템을 리팩토링하여 같은 기능을 다른 API를 호출해 수행하도록 바꿨다면 이 테스트는 실패한다.

```java
// 상호작용 테스트 - 깨지기 쉽다.
class MyTest {

  @Test
  public void shouldWriteToDatabase() {
    accounts.createUser("foobar");
    verify(database).put("foobar"); // 데이터베이스의 put() 메소드가 호출됐는지 확인
  }
}
```

- 아래 테스트는 우리가 무엇에 관심이 있는지를 더 정확하게 표현한다. 바로 기능 호출 후에 시스템이 어떤 상태에 놓이는가다.

```java
class MyTest {
  
  @Test
  @Test
  public void shouldCreateUser() {
    accounts.createUser("foobar");
    assertThat(account.getUser("foobar")).isNotNull();
  }
}
```

## 명확한 테스트 작성하기

- 명확한 테스트란 존재 이유와 실패 원인을 엔지니어가 곧바로 알아차릴 수 있는 테스트를 말한다.
  - 실패 원인이 불분명하거나 애초에 왜 만들어진 테스트인지 알아내기 어렵다면 명확하다고 말할 수 없다.
- 명확한 테스트는 대상 시스템의 문서자료 역할을 해주고 새로운 테스트를 작성하기 쉽게 도와주는 토대가 되어준다.

### (i) 완전하고 간결하게 만들자.

- `완전한 테스트 complete test`란 결과에 도달하기까지의 논리를 읽는 이가 이해하는 데 필요한 모든 정보를 본문에 담고 있는 테스트를 말한다.
- `간결한 테스트 concise test`란 코드가 산만하지 않고 관련 없는 정보는 포함하지 않는 테스트다.

```java
// 불완전하고 산만한 테스트
class MyTest {
  @Test
  public void shouldPerformAddition() {
    Calculator calculator = new Calculator(new RoundingStrategy(), "unused", ENABLE_COSINE_FEATURE, 0.01, calculusEngine, false);
    int result = calculator.calculate(newTestCalculation());
    assertThat(result).isEqualTo(5); // 도대체 5는 무엇을 의미하는 걸까?
  }
}
```

- 아래 테스트는 본문에 테스트를 이해하는 데 필요한 정보를 모두 담고 있기 때문에 이해하기 쉽다.
  - 그렇다고 눈을 어지럽히거나 관련 없는 정보는 담지 않아야 한다.

```java
// 완전하고 간결한 테스트
class MyTest {
  public void shouldPerformAddition() {
    Calculator calculator = new Calculator();
    int result = calculator.calculate(newCalculation(2, Operation.PLUS, 3));
    assertThat(result).isEqualTo(5); // 딱봐도 2랑 3을 더해 5가 된다는 것을 알 수 있다.
  }
}
```

### (ii) 메소드가 아니라 행위를 테스트하자.

- 많은 엔지니어가 본능적으로 테스트의 구조를 대상 코드의 구조와 일치시키려고 한다.
  - 제품 코드의 메소드 하나에 테스트 메소드 하나!
- 하지만 시간이 갈수록 문제를 일으킬 것이다.
  - 대상 메소드가 복잡해질수록 테스트도 함께 복잡해져서 실패해도 원인을 파악하기 어려워지기 때문이다.
  - 메소드 하나의 전반을 검사하다 보면 자연스럽게 불명확한 테스트로 이어진다는 게 문제다.
  - 메소드 하나가 몇가지 알을 하는 경우도 종종 있으며 까다롭고 예외적인 상황도 포함할 수 있기 때문이다.

```java
class MyTest {
  @Test
  public void testDisplayTransactionResults() {
    transactionProcessor.displayTransactionResults(
        newUserWithBalance(
            LOW_BALANCE_THRESHOLD.plus(dollars(2))),
        new Transaction("물품", dollars(3)));
    
    assertThat(ui.getText()).contains("물품을(를) 구입하셨습니다.");
    assertThat(ui.getText()).contains("잔고가 부족합니다.");
  }
}
```

- 테스트를 메소드별로 작성하지 않고 행위별로 작성하는 것이 훨씬 나은 방법이다.
- 여기서 `행위 Behavior`란 특정 상태에서 특정한 일련의 입력을 받았을 때 시스템이 보장하는 반응을 뜻한다.
  - 메소드와 행위는 다대다 관계이다.
  - 사소하지 않은 메소드 대부분은 여러 가지 행위를 담당하며 어떤 행위는 여러 메소드를 연계해야 완성된다.
- 행위 주도 테스트는 대체로 메소드 중심 테스트보다 명확하다.
  1. 자연어에 가깝게 읽히기 때문에 힘들여 분석하지 않아도 자연스럽게 이해할 수 있다.
  2. 테스트 각각이 더 좁은 범위를 검사하기 때문에 원인과 결과가 더 분명하게 드러난다.
  3. 각 테스트가 짧고 서술적이어서 이미 검사한 기능이 무엇인지 더 쉽게 확인할 수 있다

```java
// 행위 주도 테스트
class MyTest {
  @Test
  public void testDisplayTransactionResults_showsItemName() {
    transactionProcessor.displayTransactionResults(new User(), new Transaction("물품"));
    assertThat(ui.getText()).contains("물품을(를) 구입하셨습니다.");
  }

  @Test
  public void testDisplayTransactionResults_showsLowBalanceWarning() {
    transactionProcessor.displayTransactionResults(
            newUserWithBalance(
                    LOW_BALANCE_THRESHOLD.plus(dollars(2))),
            new Transaction("물품", dollars(3)));
    assertThat(ui.getText()).contains("잔고가 부족합니다.");
  }
}
```

### (iii) 테스트의 구조는 행위가 부각되도록 구성하자.

- 모든 행위는 given / when / then 이라는 3요소로 구성됨을 기억하자.
  - `given`: 시스템의 설정 정의
  - `when`: 시스템이 수행할 작업 정의
  - `then`: 결과를 검증

```java
class MyClass {
  @Test
  public void transferFundsShouldMoveMoneyBetweenAccounts() {
    // Given: 두 개의 계좌. 각각의 잔고는 $150와 $20
    Account account1 = newAccountWithBalance(usd(150));
    Account account2 = newAccountWithBalance(usd(20));
    
    // When: 첫 번째 계좌에서 두 번째 계좌로 $100 이체
    bank.tranferFunds(account1, account2, usd(100));
    
    // Then: 각 계좌 잔고에 이체 결과가 반영
    assertThat(account1.getBalance()).isEqualTo(usd(50));
    assertThat(account2.getBalance()).isEqualTo(usd(120));
  }
}
```

- 위의 패턴으로 작성된 테스트는 코드를 3단계 깊이로 점차 자세하게 파악할 수 있다.
  1. 먼저 테스트 메소드의 이름을 보고 검사하려는 행위를 간략하게 알 수 있다.
  2. 메소드 이름으로 충분하지 않다면 행위를 형식화해 설명한 given/when/then 주석을 읽는다.
  3. 마지막으로 주석의 설명이 실제 코드로는 정확히 어떻게 표현됐는지 살펴볼 수 있다.
- 이 패턴을 무너뜨리는 가장 큰 원흉은 대상 시스템을 호출하는 코드 사이사이에 추가되는 단정문이다.
  - when 블록 중간에 단정문이 추가되면 단정한 것이 테스트의 중간 과정인지 최종 예상 결과인지 구분하기가 어려워진다.
- when/then/and가 번갈아 가면서 단계별 검증을 할 수 있지만, 이런 코드를 만들 땐 여러 행위를 검사하는 실수를 범하지 않도록 주의해야 한다.
  - 테스트 각각은 단 하나의 행위만 다뤄야 한다.
  - 절대다수의 단위 테스트에는 when과 then 블록이 하나씩이면 충분하다.

### (iv) 테스트 이름은 검사하는 행위에 어울리게 짓자.

- 메소드 중심 테스트는 이름을 대체로 대상 메소드의 이름을 따서 짓는다.
- **반면 행위 주도 테스트는 이름 짓기가 더 자유롭기 때문에 더 의미 있는 정보를 담을 수 있다.**
  - 테스트의 이름은 매우 중요하다. 실패 보고서에 테스트 이름만 덩그러니 표시되는 경우도 많기 때문에 문제가 무엇인지 설명해줄 단서가 이름뿐일 수 있다.
  - 또한 이름은 테스트의 의도를 표현하는 가장 간단한 방법이다.
- 테스트의 이름은 검사하려는 행위를 요약해 보여줘야 한다.
  - **시스템이 수행하는 동작과 예상 결과를 모두 담아야 좋은 이름이다.**
  - 때로는 시스템의 상태나 사전 조건(환경) 같은 추가 정보까지 담기도 한다.
- 중첩 기능을 사용하면 테스트 이름을 더 쉽게 지을 수도 있다.
- 스프링의 경우 `@DisplayName`을 사용해 테스트 이름을 한글로 표기해 이해하기 쉽게 만드는 것이 방법이 될 수 있다.

### (v) 테스트에 논리를 넣지 말자.

- 테스트를 검증하는 테스트를 작성해봐야 할 것 같은 느낌이 든다면 무언가 잘못된 것이다!
- 복잡성은 대체로 `논리 logic`라는 형태로 나타난다.
  - 논리는 프로그래밍 언어에서 명령형 요소(연산자, 반복문, 조건문)를 이용해 표현한다.
  - 논리가 포함된 코드 결과를 예측하려면 약간의 정신노동을 거쳐야 한다.
  - 더욱이 테스트에 논리가 조금만 들어가도 추론하기가 어려워진다.

### (vi) 실패 메시지를 명확하게 작성하자

- 실전에서는  테스트 실패 보고서나 로그에 찍힌 메시지 한 줄만으로 문제의 원인을 찾아내야 할 때가 많다.
- 작 작성된 실패 메시지라면 테스트의 이름과 거의 동일한 정보를 담고 있어야 한다.
  - `원하는 결과`와 `실제 결과` 그리고 `이때 건네진 매개변수의 값`을 명확히 알려줘야 한다.
  - 좋은 실패 메세지라면 기대한 상태와 실제 상태를 명확히 구분해주고 결과가 만들어진 맥락 정보도 더 제공해야 한다.
- 좋은 라이브러리를 사용하면 실패 메시지를 쓸모 있게 작성하기 더 쉬워진다.
- 단정문을 잘 사용하면 단정할 대상을 구분해주기 때문에 훨씬 좋은 실패 메시지를 만들 수 있다.
  - 아래는 구글의 단정문 라이브러리 Truth의 사용 예시이다. 

```java
assertThat(colors.contains("orange")).isTrue(); // 이렇게 작성하기 보다는
assertThat(colors).contains("orange"); // 맥락 정보를 담아주자! 
```

<br/>

## DRY가 아니라 DAMP

- 테스트를 명확하고 잘 깨지지 않게 해주는 마지막 요인은 코드 공유라는 주제와 관련 있다.
- 좋은 테스트는 안정적이고 대상 시스템의 행위가 변경되면 실패하도록 설계된다.
  - 따라서 테스트 코드에서는 DRY가 주는 혜택이 그리 크지 않다.
  - 오히려 테스트는 복잡해지면 손해가 막심하다.
- DRY 대신 DAMP가 되도록 노력해야 한다. DAMP(Descriptive And Meaningful Phrase)는 서술적이고 의미 있는 문구를 뜻한다.
- 단순하고 명료하게만 만들어준다면 테스트에서 다소의 중복은 괜찮다.

### (i) 공유 값

- 필요한 값들을 테스트마다 일일 준비하려면 장황하고 귀찮기 때문에 엔지니어들이 상수를 정의해 공유하고 싶은 유혹에 빠진다.
- 차라리 도우미 메소드를 만들어 데이터를 구성하자!
- 도우미 메소드를 이용하면 불필요한 정보로 오염되거나 다른 테스트와 충돌할 염려 없이 정확히 필요한 값들만 생성해 사용할 수 있다.

### (ii) 공유 셋업

- setup 메소드를 제대로만 활용하면 테스트들을 더 깔끔하고 명확하게 정리해준다.
- 하지만 잘못 사용하면 중요한 세부 정보를 setup 메소드 속으로 숨겨버려서 테스트가 완벽해지지 못하게 막는다.
- setup 메소드는 대상 객체와 협력 객체를 생성하는 데 매우 유용하다.
  - 테스트 대다수가 객체를 생성하는 데 쓰인 인수들에 관심이 없고 테스트를 수행한 후에도 객체들의 상태가 전혀 변하지 않는다면 매우 유용하다.
- 그런데 setup 메소드를 이요한 특정 값에 의존하는 테스트가 생겨나기 시작하면 악몽이 시작될 수 있다.
  - 데이터가 필요하면 테스트 메소드 안에서 정의하고 저장하자!

### (iii) 공유 도우미 메소드와 공유 검증 메소드

- 도우미 메소드를 단순히 데이터 생성 보조 목적으로 사용하면 좋지만 다른 용도로 사용하면 위험해질 수 있다.
- 모든 테스트가 마지막에 도우미 메소드를 호출하는 극단적인 모습도 상상해볼 수 있다.
  - 매우 위험한 습관이다. 이런 식으로는 테스트를 행위 주도적으로 만들기 어렵다.
  - 테스트 각각의 의도를 추론해내기 어려워지기 때문이다.
  - 또한 버그가 하나 발생하면 여러 테스트가 동시다발로 실패할 때가 많아, 살펴봐야 할 범위를 좁혀내기가 쉽지 않다.
- 하지만 하나의 목적에 집중하는 `검증 메소드 validation method`는 여전히 유용하다. 
  - 잘 만들어진 검증용 도우미 메소드는 여러 조건을 확인하는 게 아니라 입력에 대한 단 하나의 개념적 사실만 검증한다.
  - 개념적으로 단순하지만 그 개념을 검사하는 로직이 복잡한 경우라면 특히 큰 도움이 된다.

```java
// 개념적으로 단순한 검증 로직
class MyTest {
  private void assertUserHasAccessToAccount(User user, Account account) {
    for (long userId: account.getUsersWithAccess()) {
      if (user.getId() == userId) {
        return;
      }
    }
    fail(user.getName() + " cannot access " + account.getName());
  }
}
```

### (iv) 테스트 인프라 정의하기

- 가끔은 다른 테스트 스위트와도 코드를 공유하면 유용할 때가 있다.
  - 구글은 이런 종류의 코드를 `테스트 인프라 test infrastructure`라고 한다.
  - 테스트 인프라는 주로 `통합 테스트`나 `종단간 테스트 end-to-end test`에서 빛을 발한다.
- 테스트 인프라는 단일 테스트 스위트 안에서의 코드 공유보다 훨씬 신중하게 접근해야 한다.
  - 많은 곳에서 호출되는 만큼 의존하는 코드가 많기 때문이다!
  - 동작이 달라지면 다른 코드들이 깨지기 때문에 변경하기도 어렵다!
- 테스트 인프라는 독립된 제품 대우를 해줘야 하며 마땅히 자신을 검사해줄 '자체 테스트들을 갖추고 있어야' 한다.
- 물론 대부분의 테스트 인프라는 `JUnit`처럼 잘 알려진 서드파티 라이브러리 형태로 제공될 것이다.
  - 이런 류의 라이브러리는 엄청나게 많기 때문에 가능하면 조기에 전사 표준 인프라를 정하는 것이 좋다.

<br/>

# 더 큰 테스트




## 3. 좋은 테스트의 정의란?

# 참고자료

- 구글 엔지니어는 이렇게 일한다, 타이터스 윈터스 & 톰 맨쉬렉 & 하이럼 라이트 큐레이션, 개앞매시 옮김