# 테스트?

## `자동 테스트`의 정체?

가장 단순한 테스트는 다음 요소들로 정의할 수 있다.

- 테스트하려는 단 하나의 행위(주로 메소드나 API)
- 특정한 입력(API에 전달하려는 값)
- 관측 가능한 출력 혹은 동작
- 통제된 조건(하나의 격리된 프로세스 등)

이런 테스트를 실행한다면 시스템에 특정 값을 입력하고 출력 결과를 확인하여 시스템이 기대한 대로 동작한 것인지를 판단하게 될 것이다. 그리고 간단한 테스트가 수백에서 수천 개 모이면 `테스트 스위트` 제품이 전체적으로 의도한 설계대로 잘 작동하는지 혹은 언제 그렇지 못한 지를 이야기할 수 있게 된다.
코드베이스의 덩치에 비례해 테스트 스위트도 커진다. 그 과정에서 테스트 결과가 일관되지 못하거나 느려지는 문제가 나타나기도 한다. 이런 문제를 해결하지 못하면 테스트 스위트의 존폐가 위태로워진다. 테스트는 테스트 엔지니어에게 신뢰를 줄 때만 가치가 있다는 사실을 잊지 말아야 한다.

# 테스트는 왜 해야 하는가?

### 구글 웹 서버 이야기

- 구글에서도 처음엔 엔지니어 주도 테스트를 중요하게 여기지 않았다고 함. 똑똑한 엔지니어가 소프트웨어를 알아서 올바르게 만들어줄 것이라고 기대했기 때문이다.
- 하지만 2005년 GWS(구글 검색 쿼리를 제공하는 웹 서버)의 규모와 복잡성이 커지면서 생산성이 급격히 떨어졌다. 릴리스 때마다 버그가 넘쳐났고 다음 릴리스까지의 기간도 점점 길어졌다.
- 서비스를 수정해야 할 때면 팀원들은 불안해 했고 프로덕션 환경에서만 기능들이 작동하지 않는 일도 잦았다. 한 때는 프로덕션에 추가된 기능의 80% 이상이 사용자에까지 영향을 주는 버그를 담고 있어서 롤백해야만 했다.

### 구글의 결단

- GWS의 테크 리드(TL)는 엔지니어 주도의 자동 테스트를 정책 차원에서 도입하기로 결정
- 이 정책의 일환으로 모든 코드 변경에는 지속해서 실행할 수 있는 테스트가 반드시 딸려 있어야 했다.
- 정책 도입 1년 만에 긴급 배포 건수가 절반으로 줄어들었다고 한다. => 구글의 테스트 문화를 격변시키는 분수령이 되었다. 모두가 테스트의 이점을 목격하면서 다른 팀들도 비슷한 전략을 도입하기 시작한 것이다.
- 여기서 핵심은 제품 결함 해결을 프로그래머의 능력에만 의존해서는 안 된다는 사실이다.
  - 개별 엔지니어가 버그를 심는 빈도는 아주 낮더라도 프로젝트가 커져 팀원이 많아지면 결함 목록은 계속 길어질 것이다.
- 최고의 팀은 팀원들의 집단 지성을 팀 전체의 이익으로 환원하는 방법을 찾아낸다. 바로 자동 테스트가 하는 일이다.
  - 개별 엔지니어가 작성한 테스트는 팀이 공유하는 자원 풀에 추가된다.
  - 따라서 팀원 모두가 공유된 테스트를 수행하고 결함을 찾아낼 수 있다.

### 작성하고 수행하고 조치하라

- 가장 순수한 형태의 자동 테스트는 아래 3가지 활동으로 이뤄진다.
1. 테스트 작성
2. 테스트 수행
3. 실패한 테스트에 대한 조치

- 자동 테스트는 적은 양의 코드로 구성된다. 보통은 테스트 대상 시스템의 일부를 호출하는 함수나 메소드 하나로 만들어진다.
- 테스트 코드는 환경을 원하는 모습으로 설정하고 시스템을 호출하며 결과를 검증한다.
- **시스템의 규모와 배포 속도를 따라잡으려면 모든 엔지니어가 테스트도 함께 개발해야만 한다.**
  - 물론 테스트를 작성하는 것과 좋은 테스트를 작성하는 것은 별개다.
- 테스트 코드를 작성하면 다양한 환경에서 수행할 수 있도록 테스트들을 모듈화하기도 좋다.
  - 예를 들어 파이어폭스에서 실행하던 Gmail을 크롬에서 실행한다고 해서 테스트 코드가 크게 달라질 것은 없다.
  - 두 시스템에 맞춰 설정 정보만 테스트에 제공하면 된다.
- 가장 중요한 것은 테스트가 실패하면 바로바로 조치하도록 권장해야 테스트 프로세스를 신뢰하고 계속 이어갈 수 있다.

### 테스트 코드가 주는 혜택

- 디버깅 감소
  - 테스트를 거친 후의 코드는 통상적으로 결함이 적다.
- 코드를 자신 있게 변경할 수 있다.
  - 테스트들이 프로젝트의 주요 기능들을 끊임없이 검증해주는 덕분이다.
  - 이런 프로젝트에서는 자연스럽게 리팩토링을 권장한다.
- 더 나은 문서자료
  - 코드가 특정 상황에서 어떻게 동작하는지 궁금하다면 그 상황을 검증하는 테스트를 보면 된다.
  - 나아가 요구사항이 변경되어 새로운 코드가 기존 테스트를 통과하지 못한다면 그 문서자료가 이제 낡았음을 분명히 알 수 있다.
- 더 단순한 리뷰
  - 다양한 측면에서 코드를 검사해주는 테스트가 준비되어 있다면 리뷰어가 변경된 코드가 제대로 작동하는지 검증하는 시간을 크게 줄여준다.
- 사려 깊은 설계
  - 테스트하기 어려운 코드는 너무 많은 역할을 가지고 있거나 의존성을 관리하기 어렵게 짰기 때문일 가능성이 크다.
  - 잘 설계된 코드라면 모듈화가 잘되어 있고, 이런 코드는 테스트하기 쉽다. (고로 테스트를 짜면 테스트 짜기 쉬운 구조를 생각하게 되고 이는 모듈화가 잘된 코드를 만드는 것에 도움이 될 수 있다.)

# 2. 테스트는 어떻게 해야하는가?

- `크기 size`는 테스트가 소비하는 자원과 수행할 수 있는 작업을 뜻한다.
- `범위 scope`는 테스트가 검증하고자 하는 코드의 양을 의미한다.
- 테스트 요소별로 알아보자.

# (1) 단위 테스트

- 구글에서 말하는 `단위 테스트 unit test`는 단일 클래스나 메소드처럼 범위가 상대적으로 좁은 테스트를 의미한다. 단위테스트는 일반적으로 크기가 작지만 반드시 그런 건 아니다.
- 범위가 더 넓은 테스트들과 비교해 단위 테스트는 생산성을 끌어올리는 훌륭한 수단이 될 수 있는 특성을 많이 지니고 있다.
- 대체로 대상 코드와 동시에 작성할 수 있을 만큼 작성하기 쉽다. 따라서 커다란 시스템을 설정하거나 이해할 필요 없이 작성 중인 코드를 검증하는 데 집중할 수 있다.
- 각각의 테스트는 개념적으로 간단하고 시스템의 특정 부분에 집중하므로 실패 시 원인을 파악하기 쉽다.
- 구글에서는 단위 테스트의 비율이 80%라고 한다.

## 깨지기 쉬운 테스트 예방하기

- `깨지기 쉬운 테스트`란 실제로는 버그가 없음에도 심지어 검증 대상 코드와 관련조차 없는 변경 때문에 실패하는 테스트를 말한다.
- 코드를 변경할 때마다 테스트가 엄청나게 깨진다면..? 개발팀은 테스트를 유지보수하느라 점점 더 많은 시간을 허비해야 한다.
  - 수동으로 매번 테스트를 손봐야 한다면 '자동화된 테스트 스위트'라고 부르기도 민망하다.
- 테스트가 변경에 영향을 덜 받도록 해주는 관례와 패턴들이 존재한다.

### (i) 변하지 않는 테스트

- 이상적인 테스트라면 변하지 않아야 한다. 한 번 작성한 후로는 대상 시스템의 요구사항이 바뀌지 않는 한 절대 수정할 일이 없어야 한다.
- 우리는 엔지니어가 제품 코드를 변경하는 유형을 생각해보고 그 유형별로 테스트가 어떻게 대응해야 하는지를 따져봐야 한다. 기본적인 유형 4가지는 아래와 같다.
1. 순수 리팩토링
  - 외부 인터페이스를 놔두고 내부만 리팩토링한다면 테스트는 변경되지 않아야 한다. 성능 최적화, 코드 가독성 개선 등이 여기에 속한다.
  - 리팩토링 과정에서 테스트를 변경해야 한다면 원인은 둘 중 하나다. (1) 시스템의 행위가 달라졌거나 (순수 리팩토링 X) (2) 테스트의 추상화 수준이 적절하지 않다는 뜻이다.
2. 새로운 기능 추가
  - 새로운 기능이나 행위를 추가할 때 기존 행위들에 영향을 주지 않아야 한다.
  - 새 기능을 검증할 테스트를 새로 작성해야 하며 기존 테스트들은 변경되지 않아야 한다.
  - 새로운 기능을 추가했는데 기존 테스트를 변경해야 한다면 해당 테스트가 검증하는 기능에 의도치 않은 영향을 주었거나 테스트 자체에 문제가 있다는 뜻이다.
3. 버그 수정
  - 버그 수정은 새로운 기능 추가와 비슷하다.
  - 버그가 존재한다는 것은 기존 테스트 스위트에 빠진 것이 있다는 신호다. <u>버그 수정과 동시에 누락된 테스트를 추가해야 한다.</u>
4. 행위 변경
  - 시스템의 기존 행위를 변경하는 겨우 기존 테스트 역시 변경되어야 한다. 앞의 3가지보다 비용이 더 든다.
  - 행위를 변경하려면 혼란에 빠지거나 업무가 중단되는 사용자가 없도록 조치해줘야 한다.
  - 테스트를 변경한다는 것은 시스템이 한 약속을 의도적으로 변경한다는 뜻이다.
  - 저수준 라이브러리라면 사용자의 시스템을 망가트릴 일이 없도록 애초부터 행위를 변경할 일이 없게끔 설계하는 데 엄청난 노력을 기울인다.

### (ii) 공개된 API를 이용해 테스트 하자.

- 공개 API란 서드파티에 노출한 API이다.
  - 단순히 인터페이스나 public 메소드를 의미하는 것은 아니다. 
  - 예를 들어 어떤 public class는 단지 같은 단위에 속하는 다른 패키지에서 사용할 용도일 뿐 단위 외부의 접근까지 허용할 의도는 없을 수 있다.
- 공개된 API만 이용하는 테스트는 정의상 대상 시스템을 사용자와 똑같은 방식으로 사용한다. 더 현실적이고 잘 깨지지 않는다.
  - 이런 테스트가 깨진다면 다른 사용자도 같은 문제를 겪고 있다는 신호다.
- 공개 API 단위의 범위를 잘 정해서 어디까지가 공개 API인가를 정하는 일에 정답은 없다. 대신 쓸만한 경험 법칙은 있다.
  - 소수의 다른 클래스를 보조하는 용도가 다인 메소드나 클래스라면 독립된 단위로 생각하지 않는 게 좋다. 따라서 이런 메소드나 클래스는 직접 테스트하지 말고 이들이 보조하는 클래스를 통해 우회적으로 테스트해야 한다.
  - 소유자의 통제 없이 누구든 접근할 수 있게 설계된 패키지나 클래스라면 거의 예외 없이 직접 테스트해야 하는 단위로 취급해야 한다. 이때도 테스트는 사용자와 똑같은 방식으로 접근한다.
  - 소유자만 접근할 수 있지만 다방면으로 유용한 기능을 제공하도록 설계된 패키지나 클래스 역시 직접 테스트해야 하는 단위로 봐야 한다.

### (iii) 상호작용이 아니라 상태를 테스트하자.

- 시스템이 기대한 바대로 동작하는지 검증하는 방법은 크게 2가지이다.
  1. `상태 테스트 state test`
  2. `상호작용 테스트 interaction test`
- 대체로 상호작용 테스트는 상태 테스트보다 깨지기 쉽다.
  - 우리가 진짜 원하는 것은 결과가 `무엇 what`이냐지만 상호작용 테스트는 결과에 도달하기까지 시스템이 `어떻게 how` 작동하냐를 확인하려 든다.
- 아래 테스트는 데이터베이스의 특정 API가 호출됐는지를 검증한다. 하지만 설계 의도와 달리 이상하게 테스트가 굴러갈 수 있다.
  1. 시스템에 버그가 있어서 레코드가 쓰인 직후 삭제돼도 테스트는 성공한다.
  2. 시스템을 리팩토링하여 같은 기능을 다른 API를 호출해 수행하도록 바꿨다면 이 테스트는 실패한다.

```java
// 상호작용 테스트 - 깨지기 쉽다.
class MyTest {

  @Test
  public void shouldWriteToDatabase() {
    accounts.createUser("foobar");
    verify(database).put("foobar"); // 데이터베이스의 put() 메소드가 호출됐는지 확인
  }
}
```

- 아래 테스트는 우리가 무엇에 관심이 있는지를 더 정확하게 표현한다. 바로 기능 호출 후에 시스템이 어떤 상태에 놓이는가다.

```java
class MyTest {
  
  @Test
  @Test
  public void shouldCreateUser() {
    accounts.createUser("foobar");
    assertThat(account.getUser("foobar")).isNotNull();
  }
}
```

## 명확한 테스트 작성하기

- 명확한 테스트란 존재 이유와 실패 원인을 엔지니어가 곧바로 알아차릴 수 있는 테스트를 말한다.
  - 실패 원인이 불분명하거나 애초에 왜 만들어진 테스트인지 알아내기 어렵다면 명확하다고 말할 수 없다.
- 명확한 테스트는 대상 시스템의 문서자료 역할을 해주고 새로운 테스트를 작성하기 쉽게 도와주는 토대가 되어준다.

### (i) 완전하고 간결하게 만들자.

### (ii) 메소드가 아니라 행위를 테스트하자.

### (iii) 테스트에 논리를 넣지 말자.

### (iv) 실패 메시지를 명확하게 작성하자

<br/>

## DRY가 아니라 DAMP

### (i) 공유 값

### (ii) 공유 셋업

### (iii) 공유 도우미 메소드와 공유 검증 메소드

### (iv) 테스트 인프라 정의하기

<br/>

# 더 큰 테스트




## 3. 좋은 테스트의 정의란?

# 참고자료

- 구글 엔지니어는 이렇게 일한다, 타이터스 윈터스 & 톰 맨쉬렉 & 하이럼 라이트 큐레이션, 개앞매시 옮김