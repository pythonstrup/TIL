# 테스트?

## `자동 테스트`의 정체?

가장 단순한 테스트는 다음 요소들로 정의할 수 있다.

- 테스트하려는 단 하나의 행위(주로 메소드나 API)
- 특정한 입력(API에 전달하려는 값)
- 관측 가능한 출력 혹은 동작
- 통제된 조건(하나의 격리된 프로세스 등)

이런 테스트를 실행한다면 시스템에 특정 값을 입력하고 출력 결과를 확인하여 시스템이 기대한 대로 동작한 것인지를 판단하게 될 것이다. 그리고 간단한 테스트가 수백에서 수천 개 모이면 `테스트 스위트` 제품이 전체적으로 의도한 설계대로 잘 작동하는지 혹은 언제 그렇지 못한 지를 이야기할 수 있게 된다.
코드베이스의 덩치에 비례해 테스트 스위트도 커진다. 그 과정에서 테스트 결과가 일관되지 못하거나 느려지는 문제가 나타나기도 한다. 이런 문제를 해결하지 못하면 테스트 스위트의 존폐가 위태로워진다. 테스트는 테스트 엔지니어에게 신뢰를 줄 때만 가치가 있다는 사실을 잊지 말아야 한다.

# 테스트는 왜 해야 하는가?

### 구글 웹 서버 이야기

- 구글에서도 처음엔 엔지니어 주도 테스트를 중요하게 여기지 않았다고 함. 똑똑한 엔지니어가 소프트웨어를 알아서 올바르게 만들어줄 것이라고 기대했기 때문이다.
- 하지만 2005년 GWS(구글 검색 쿼리를 제공하는 웹 서버)의 규모와 복잡성이 커지면서 생산성이 급격히 떨어졌다. 릴리스 때마다 버그가 넘쳐났고 다음 릴리스까지의 기간도 점점 길어졌다.
- 서비스를 수정해야 할 때면 팀원들은 불안해 했고 프로덕션 환경에서만 기능들이 작동하지 않는 일도 잦았다. 한 때는 프로덕션에 추가된 기능의 80% 이상이 사용자에까지 영향을 주는 버그를 담고 있어서 롤백해야만 했다.

### 구글의 결단

- GWS의 테크 리드(TL)는 엔지니어 주도의 자동 테스트를 정책 차원에서 도입하기로 결정
- 이 정책의 일환으로 모든 코드 변경에는 지속해서 실행할 수 있는 테스트가 반드시 딸려 있어야 했다.
- 정책 도입 1년 만에 긴급 배포 건수가 절반으로 줄어들었다고 한다. => 구글의 테스트 문화를 격변시키는 분수령이 되었다. 모두가 테스트의 이점을 목격하면서 다른 팀들도 비슷한 전략을 도입하기 시작한 것이다.
- 여기서 핵심은 제품 결함 해결을 프로그래머의 능력에만 의존해서는 안 된다는 사실이다.
  - 개별 엔지니어가 버그를 심는 빈도는 아주 낮더라도 프로젝트가 커져 팀원이 많아지면 결함 목록은 계속 길어질 것이다.
- 최고의 팀은 팀원들의 집단 지성을 팀 전체의 이익으로 환원하는 방법을 찾아낸다. 바로 자동 테스트가 하는 일이다.
  - 개별 엔지니어가 작성한 테스트는 팀이 공유하는 자원 풀에 추가된다.
  - 따라서 팀원 모두가 공유된 테스트를 수행하고 결함을 찾아낼 수 있다.

### 작성하고 수행하고 조치하라

- 가장 순수한 형태의 자동 테스트는 아래 3가지 활동으로 이뤄진다.
1. 테스트 작성
2. 테스트 수행
3. 실패한 테스트에 대한 조치

- 자동 테스트는 적은 양의 코드로 구성된다. 보통은 테스트 대상 시스템의 일부를 호출하는 함수나 메소드 하나로 만들어진다.
- 테스트 코드는 환경을 원하는 모습으로 설정하고 시스템을 호출하며 결과를 검증한다.
- **시스템의 규모와 배포 속도를 따라잡으려면 모든 엔지니어가 테스트도 함께 개발해야만 한다.**
  - 물론 테스트를 작성하는 것과 좋은 테스트를 작성하는 것은 별개다.
- 테스트 코드를 작성하면 다양한 환경에서 수행할 수 있도록 테스트들을 모듈화하기도 좋다.
  - 예를 들어 파이어폭스에서 실행하던 Gmail을 크롬에서 실행한다고 해서 테스트 코드가 크게 달라질 것은 없다.
  - 두 시스템에 맞춰 설정 정보만 테스트에 제공하면 된다.
- 가장 중요한 것은 테스트가 실패하면 바로바로 조치하도록 권장해야 테스트 프로세스를 신뢰하고 계속 이어갈 수 있다.

### 테스트 코드가 주는 혜택

- 디버깅 감소
  - 테스트를 거친 후의 코드는 통상적으로 결함이 적다.
- 코드를 자신 있게 변경할 수 있다.
  - 테스트들이 프로젝트의 주요 기능들을 끊임없이 검증해주는 덕분이다.
  - 이런 프로젝트에서는 자연스럽게 리팩토링을 권장한다.
- 더 나은 문서자료
  - 코드가 특정 상황에서 어떻게 동작하는지 궁금하다면 그 상황을 검증하는 테스트를 보면 된다.
  - 나아가 요구사항이 변경되어 새로운 코드가 기존 테스트를 통과하지 못한다면 그 문서자료가 이제 낡았음을 분명히 알 수 있다.
- 더 단순한 리뷰
  - 다양한 측면에서 코드를 검사해주는 테스트가 준비되어 있다면 리뷰어가 변경된 코드가 제대로 작동하는지 검증하는 시간을 크게 줄여준다.
- 사려 깊은 설계
  - 테스트하기 어려운 코드는 너무 많은 역할을 가지고 있거나 의존성을 관리하기 어렵게 짰기 때문일 가능성이 크다.
  - 잘 설계된 코드라면 모듈화가 잘되어 있고, 이런 코드는 테스트하기 쉽다. (고로 테스트를 짜면 테스트 짜기 쉬운 구조를 생각하게 되고 이는 모듈화가 잘된 코드를 만드는 것에 도움이 될 수 있다.)

# 2. 테스트는 어떻게 해야하는가?

- `크기 size`는 테스트가 소비하는 자원과 수행할 수 있는 작업을 뜻한다.
- `범위 scope`는 테스트가 검증하고자 하는 코드의 양을 의미한다.
- 테스트 요소별로 알아보자.

# (1) 단위 테스트

- 구글에서 말하는 `단위 테스트 unit test`는 단일 클래스나 메소드처럼 범위가 상대적으로 좁은 테스트를 의미한다. 단위테스트는 일반적으로 크기가 작지만 반드시 그런 건 아니다.
- 범위가 더 넓은 테스트들과 비교해 단위 테스트는 생산성을 끌어올리는 훌륭한 수단이 될 수 있는 특성을 많이 지니고 있다.
- 대체로 대상 코드와 동시에 작성할 수 있을 만큼 작성하기 쉽다. 따라서 커다란 시스템을 설정하거나 이해할 필요 없이 작성 중인 코드를 검증하는 데 집중할 수 있다.
- 각각의 테스트는 개념적으로 간단하고 시스템의 특정 부분에 집중하므로 실패 시 원인을 파악하기 쉽다.
- 구글에서는 단위 테스트의 비율이 80%라고 한다.

## 깨지기 쉬운 테스트 예방하기

- `깨지기 쉬운 테스트`란 실제로는 버그가 없음에도 심지어 검증 대상 코드와 관련조차 없는 변경 때문에 실패하는 테스트를 말한다.
- 코드를 변경할 때마다 테스트가 엄청나게 깨진다면..? 개발팀은 테스트를 유지보수하느라 점점 더 많은 시간을 허비해야 한다.
  - 수동으로 매번 테스트를 손봐야 한다면 '자동화된 테스트 스위트'라고 부르기도 민망하다.
- 테스트가 변경에 영향을 덜 받도록 해주는 관례와 패턴들이 존재한다.

### (i) 변하지 않는 테스트

- 이상적인 테스트라면 변하지 않아야 한다. 한 번 작성한 후로는 대상 시스템의 요구사항이 바뀌지 않는 한 절대 수정할 일이 없어야 한다.
- 우리는 엔지니어가 제품 코드를 변경하는 유형을 생각해보고 그 유형별로 테스트가 어떻게 대응해야 하는지를 따져봐야 한다. 기본적인 유형 4가지는 아래와 같다.
1. 순수 리팩토링
  - 외부 인터페이스를 놔두고 내부만 리팩토링한다면 테스트는 변경되지 않아야 한다. 성능 최적화, 코드 가독성 개선 등이 여기에 속한다.
  - 리팩토링 과정에서 테스트를 변경해야 한다면 원인은 둘 중 하나다. (1) 시스템의 행위가 달라졌거나 (순수 리팩토링 X) (2) 테스트의 추상화 수준이 적절하지 않다는 뜻이다.
2. 새로운 기능 추가
  - 새로운 기능이나 행위를 추가할 때 기존 행위들에 영향을 주지 않아야 한다.
  - 새 기능을 검증할 테스트를 새로 작성해야 하며 기존 테스트들은 변경되지 않아야 한다.
  - 새로운 기능을 추가했는데 기존 테스트를 변경해야 한다면 해당 테스트가 검증하는 기능에 의도치 않은 영향을 주었거나 테스트 자체에 문제가 있다는 뜻이다.
3. 버그 수정
  - 버그 수정은 새로운 기능 추가와 비슷하다.
  - 버그가 존재한다는 것은 기존 테스트 스위트에 빠진 것이 있다는 신호다. <u>버그 수정과 동시에 누락된 테스트를 추가해야 한다.</u>
4. 행위 변경
  - 시스템의 기존 행위를 변경하는 겨우 기존 테스트 역시 변경되어야 한다. 앞의 3가지보다 비용이 더 든다.
  - 행위를 변경하려면 혼란에 빠지거나 업무가 중단되는 사용자가 없도록 조치해줘야 한다.
  - 테스트를 변경한다는 것은 시스템이 한 약속을 의도적으로 변경한다는 뜻이다.
  - 저수준 라이브러리라면 사용자의 시스템을 망가트릴 일이 없도록 애초부터 행위를 변경할 일이 없게끔 설계하는 데 엄청난 노력을 기울인다.

### (ii) 공개된 API를 이용해 테스트 하자.

- 공개 API란 서드파티에 노출한 API이다.
  - 단순히 인터페이스나 public 메소드를 의미하는 것은 아니다. 
  - 예를 들어 어떤 public class는 단지 같은 단위에 속하는 다른 패키지에서 사용할 용도일 뿐 단위 외부의 접근까지 허용할 의도는 없을 수 있다.
- 공개된 API만 이용하는 테스트는 정의상 대상 시스템을 사용자와 똑같은 방식으로 사용한다. 더 현실적이고 잘 깨지지 않는다.
  - 이런 테스트가 깨진다면 다른 사용자도 같은 문제를 겪고 있다는 신호다.
- 공개 API 단위의 범위를 잘 정해서 어디까지가 공개 API인가를 정하는 일에 정답은 없다. 대신 쓸만한 경험 법칙은 있다.
  - 소수의 다른 클래스를 보조하는 용도가 다인 메소드나 클래스라면 독립된 단위로 생각하지 않는 게 좋다. 따라서 이런 메소드나 클래스는 직접 테스트하지 말고 이들이 보조하는 클래스를 통해 우회적으로 테스트해야 한다.
  - 소유자의 통제 없이 누구든 접근할 수 있게 설계된 패키지나 클래스라면 거의 예외 없이 직접 테스트해야 하는 단위로 취급해야 한다. 이때도 테스트는 사용자와 똑같은 방식으로 접근한다.
  - 소유자만 접근할 수 있지만 다방면으로 유용한 기능을 제공하도록 설계된 패키지나 클래스 역시 직접 테스트해야 하는 단위로 봐야 한다.

### (iii) 상호작용이 아니라 상태를 테스트하자.

- 시스템이 기대한 바대로 동작하는지 검증하는 방법은 크게 2가지이다.
  1. `상태 테스트 state test`
  2. `상호작용 테스트 interaction test`
- 대체로 상호작용 테스트는 상태 테스트보다 깨지기 쉽다.
  - 우리가 진짜 원하는 것은 결과가 `무엇 what`이냐지만 상호작용 테스트는 결과에 도달하기까지 시스템이 `어떻게 how` 작동하냐를 확인하려 든다.
- 아래 테스트는 데이터베이스의 특정 API가 호출됐는지를 검증한다. 하지만 설계 의도와 달리 이상하게 테스트가 굴러갈 수 있다.
  1. 시스템에 버그가 있어서 레코드가 쓰인 직후 삭제돼도 테스트는 성공한다.
  2. 시스템을 리팩토링하여 같은 기능을 다른 API를 호출해 수행하도록 바꿨다면 이 테스트는 실패한다.

```java
// 상호작용 테스트 - 깨지기 쉽다.
class MyTest {

  @Test
  public void shouldWriteToDatabase() {
    accounts.createUser("foobar");
    verify(database).put("foobar"); // 데이터베이스의 put() 메소드가 호출됐는지 확인
  }
}
```

- 아래 테스트는 우리가 무엇에 관심이 있는지를 더 정확하게 표현한다. 바로 기능 호출 후에 시스템이 어떤 상태에 놓이는가다.

```java
class MyTest {
  
  @Test
  @Test
  public void shouldCreateUser() {
    accounts.createUser("foobar");
    assertThat(account.getUser("foobar")).isNotNull();
  }
}
```

## 명확한 테스트 작성하기

- 명확한 테스트란 존재 이유와 실패 원인을 엔지니어가 곧바로 알아차릴 수 있는 테스트를 말한다.
  - 실패 원인이 불분명하거나 애초에 왜 만들어진 테스트인지 알아내기 어렵다면 명확하다고 말할 수 없다.
- 명확한 테스트는 대상 시스템의 문서자료 역할을 해주고 새로운 테스트를 작성하기 쉽게 도와주는 토대가 되어준다.

### (i) 완전하고 간결하게 만들자.

- `완전한 테스트 complete test`란 결과에 도달하기까지의 논리를 읽는 이가 이해하는 데 필요한 모든 정보를 본문에 담고 있는 테스트를 말한다.
- `간결한 테스트 concise test`란 코드가 산만하지 않고 관련 없는 정보는 포함하지 않는 테스트다.

```java
// 불완전하고 산만한 테스트
class MyTest {
  @Test
  public void shouldPerformAddition() {
    Calculator calculator = new Calculator(new RoundingStrategy(), "unused", ENABLE_COSINE_FEATURE, 0.01, calculusEngine, false);
    int result = calculator.calculate(newTestCalculation());
    assertThat(result).isEqualTo(5); // 도대체 5는 무엇을 의미하는 걸까?
  }
}
```

- 아래 테스트는 본문에 테스트를 이해하는 데 필요한 정보를 모두 담고 있기 때문에 이해하기 쉽다.
  - 그렇다고 눈을 어지럽히거나 관련 없는 정보는 담지 않아야 한다.

```java
// 완전하고 간결한 테스트
class MyTest {
  public void shouldPerformAddition() {
    Calculator calculator = new Calculator();
    int result = calculator.calculate(newCalculation(2, Operation.PLUS, 3));
    assertThat(result).isEqualTo(5); // 딱봐도 2랑 3을 더해 5가 된다는 것을 알 수 있다.
  }
}
```

### (ii) 메소드가 아니라 행위를 테스트하자.

- 많은 엔지니어가 본능적으로 테스트의 구조를 대상 코드의 구조와 일치시키려고 한다.
  - 제품 코드의 메소드 하나에 테스트 메소드 하나!
- 하지만 시간이 갈수록 문제를 일으킬 것이다.
  - 대상 메소드가 복잡해질수록 테스트도 함께 복잡해져서 실패해도 원인을 파악하기 어려워지기 때문이다.
  - 메소드 하나의 전반을 검사하다 보면 자연스럽게 불명확한 테스트로 이어진다는 게 문제다.
  - 메소드 하나가 몇가지 알을 하는 경우도 종종 있으며 까다롭고 예외적인 상황도 포함할 수 있기 때문이다.

```java
class MyTest {
  @Test
  public void testDisplayTransactionResults() {
    transactionProcessor.displayTransactionResults(
        newUserWithBalance(
            LOW_BALANCE_THRESHOLD.plus(dollars(2))),
        new Transaction("물품", dollars(3)));
    
    assertThat(ui.getText()).contains("물품을(를) 구입하셨습니다.");
    assertThat(ui.getText()).contains("잔고가 부족합니다.");
  }
}
```

- 테스트를 메소드별로 작성하지 않고 행위별로 작성하는 것이 훨씬 나은 방법이다.
- 여기서 `행위 Behavior`란 특정 상태에서 특정한 일련의 입력을 받았을 때 시스템이 보장하는 반응을 뜻한다.
  - 메소드와 행위는 다대다 관계이다.
  - 사소하지 않은 메소드 대부분은 여러 가지 행위를 담당하며 어떤 행위는 여러 메소드를 연계해야 완성된다.
- 행위 주도 테스트는 대체로 메소드 중심 테스트보다 명확하다.
  1. 자연어에 가깝게 읽히기 때문에 힘들여 분석하지 않아도 자연스럽게 이해할 수 있다.
  2. 테스트 각각이 더 좁은 범위를 검사하기 때문에 원인과 결과가 더 분명하게 드러난다.
  3. 각 테스트가 짧고 서술적이어서 이미 검사한 기능이 무엇인지 더 쉽게 확인할 수 있다

```java
// 행위 주도 테스트
class MyTest {
  @Test
  public void testDisplayTransactionResults_showsItemName() {
    transactionProcessor.displayTransactionResults(new User(), new Transaction("물품"));
    assertThat(ui.getText()).contains("물품을(를) 구입하셨습니다.");
  }

  @Test
  public void testDisplayTransactionResults_showsLowBalanceWarning() {
    transactionProcessor.displayTransactionResults(
            newUserWithBalance(
                    LOW_BALANCE_THRESHOLD.plus(dollars(2))),
            new Transaction("물품", dollars(3)));
    assertThat(ui.getText()).contains("잔고가 부족합니다.");
  }
}
```

### (iii) 테스트의 구조는 행위가 부각되도록 구성하자.

- 모든 행위는 given / when / then 이라는 3요소로 구성됨을 기억하자.
  - `given`: 시스템의 설정 정의
  - `when`: 시스템이 수행할 작업 정의
  - `then`: 결과를 검증

```java
class MyClass {
  @Test
  public void transferFundsShouldMoveMoneyBetweenAccounts() {
    // Given: 두 개의 계좌. 각각의 잔고는 $150와 $20
    Account account1 = newAccountWithBalance(usd(150));
    Account account2 = newAccountWithBalance(usd(20));
    
    // When: 첫 번째 계좌에서 두 번째 계좌로 $100 이체
    bank.tranferFunds(account1, account2, usd(100));
    
    // Then: 각 계좌 잔고에 이체 결과가 반영
    assertThat(account1.getBalance()).isEqualTo(usd(50));
    assertThat(account2.getBalance()).isEqualTo(usd(120));
  }
}
```

- 위의 패턴으로 작성된 테스트는 코드를 3단계 깊이로 점차 자세하게 파악할 수 있다.
  1. 먼저 테스트 메소드의 이름을 보고 검사하려는 행위를 간략하게 알 수 있다.
  2. 메소드 이름으로 충분하지 않다면 행위를 형식화해 설명한 given/when/then 주석을 읽는다.
  3. 마지막으로 주석의 설명이 실제 코드로는 정확히 어떻게 표현됐는지 살펴볼 수 있다.
- 이 패턴을 무너뜨리는 가장 큰 원흉은 대상 시스템을 호출하는 코드 사이사이에 추가되는 단정문이다.
  - when 블록 중간에 단정문이 추가되면 단정한 것이 테스트의 중간 과정인지 최종 예상 결과인지 구분하기가 어려워진다.
- when/then/and가 번갈아 가면서 단계별 검증을 할 수 있지만, 이런 코드를 만들 땐 여러 행위를 검사하는 실수를 범하지 않도록 주의해야 한다.
  - 테스트 각각은 단 하나의 행위만 다뤄야 한다.
  - 절대다수의 단위 테스트에는 when과 then 블록이 하나씩이면 충분하다.

### (iv) 테스트 이름은 검사하는 행위에 어울리게 짓자.

- 메소드 중심 테스트는 이름을 대체로 대상 메소드의 이름을 따서 짓는다.
- **반면 행위 주도 테스트는 이름 짓기가 더 자유롭기 때문에 더 의미 있는 정보를 담을 수 있다.**
  - 테스트의 이름은 매우 중요하다. 실패 보고서에 테스트 이름만 덩그러니 표시되는 경우도 많기 때문에 문제가 무엇인지 설명해줄 단서가 이름뿐일 수 있다.
  - 또한 이름은 테스트의 의도를 표현하는 가장 간단한 방법이다.
- 테스트의 이름은 검사하려는 행위를 요약해 보여줘야 한다.
  - **시스템이 수행하는 동작과 예상 결과를 모두 담아야 좋은 이름이다.**
  - 때로는 시스템의 상태나 사전 조건(환경) 같은 추가 정보까지 담기도 한다.
- 중첩 기능을 사용하면 테스트 이름을 더 쉽게 지을 수도 있다.
- 스프링의 경우 `@DisplayName`을 사용해 테스트 이름을 한글로 표기해 이해하기 쉽게 만드는 것이 방법이 될 수 있다.

### (v) 테스트에 논리를 넣지 말자.

- 테스트를 검증하는 테스트를 작성해봐야 할 것 같은 느낌이 든다면 무언가 잘못된 것이다!
- 복잡성은 대체로 `논리 logic`라는 형태로 나타난다.
  - 논리는 프로그래밍 언어에서 명령형 요소(연산자, 반복문, 조건문)를 이용해 표현한다.
  - 논리가 포함된 코드 결과를 예측하려면 약간의 정신노동을 거쳐야 한다.
  - 더욱이 테스트에 논리가 조금만 들어가도 추론하기가 어려워진다.

### (vi) 실패 메시지를 명확하게 작성하자

- 실전에서는  테스트 실패 보고서나 로그에 찍힌 메시지 한 줄만으로 문제의 원인을 찾아내야 할 때가 많다.
- 작 작성된 실패 메시지라면 테스트의 이름과 거의 동일한 정보를 담고 있어야 한다.
  - `원하는 결과`와 `실제 결과` 그리고 `이때 건네진 매개변수의 값`을 명확히 알려줘야 한다.
  - 좋은 실패 메세지라면 기대한 상태와 실제 상태를 명확히 구분해주고 결과가 만들어진 맥락 정보도 더 제공해야 한다.
- 좋은 라이브러리를 사용하면 실패 메시지를 쓸모 있게 작성하기 더 쉬워진다.
- 단정문을 잘 사용하면 단정할 대상을 구분해주기 때문에 훨씬 좋은 실패 메시지를 만들 수 있다.
  - 아래는 구글의 단정문 라이브러리 Truth의 사용 예시이다. 

```java
assertThat(colors.contains("orange")).isTrue(); // 이렇게 작성하기 보다는
assertThat(colors).contains("orange"); // 맥락 정보를 담아주자! 
```

<br/>

## DRY가 아니라 DAMP

- 테스트를 명확하고 잘 깨지지 않게 해주는 마지막 요인은 코드 공유라는 주제와 관련 있다.
- 좋은 테스트는 안정적이고 대상 시스템의 행위가 변경되면 실패하도록 설계된다.
  - 따라서 테스트 코드에서는 DRY가 주는 혜택이 그리 크지 않다.
  - 오히려 테스트는 복잡해지면 손해가 막심하다.
- DRY 대신 DAMP가 되도록 노력해야 한다. DAMP(Descriptive And Meaningful Phrase)는 서술적이고 의미 있는 문구를 뜻한다.
- 단순하고 명료하게만 만들어준다면 테스트에서 다소의 중복은 괜찮다.

### (i) 공유 값

- 필요한 값들을 테스트마다 일일 준비하려면 장황하고 귀찮기 때문에 엔지니어들이 상수를 정의해 공유하고 싶은 유혹에 빠진다.
- 차라리 도우미 메소드를 만들어 데이터를 구성하자!
- 도우미 메소드를 이용하면 불필요한 정보로 오염되거나 다른 테스트와 충돌할 염려 없이 정확히 필요한 값들만 생성해 사용할 수 있다.

### (ii) 공유 셋업

- setup 메소드를 제대로만 활용하면 테스트들을 더 깔끔하고 명확하게 정리해준다.
- 하지만 잘못 사용하면 중요한 세부 정보를 setup 메소드 속으로 숨겨버려서 테스트가 완벽해지지 못하게 막는다.
- setup 메소드는 대상 객체와 협력 객체를 생성하는 데 매우 유용하다.
  - 테스트 대다수가 객체를 생성하는 데 쓰인 인수들에 관심이 없고 테스트를 수행한 후에도 객체들의 상태가 전혀 변하지 않는다면 매우 유용하다.
- 그런데 setup 메소드를 이요한 특정 값에 의존하는 테스트가 생겨나기 시작하면 악몽이 시작될 수 있다.
  - 데이터가 필요하면 테스트 메소드 안에서 정의하고 저장하자!

### (iii) 공유 도우미 메소드와 공유 검증 메소드

- 도우미 메소드를 단순히 데이터 생성 보조 목적으로 사용하면 좋지만 다른 용도로 사용하면 위험해질 수 있다.
- 모든 테스트가 마지막에 도우미 메소드를 호출하는 극단적인 모습도 상상해볼 수 있다.
  - 매우 위험한 습관이다. 이런 식으로는 테스트를 행위 주도적으로 만들기 어렵다.
  - 테스트 각각의 의도를 추론해내기 어려워지기 때문이다.
  - 또한 버그가 하나 발생하면 여러 테스트가 동시다발로 실패할 때가 많아, 살펴봐야 할 범위를 좁혀내기가 쉽지 않다.
- 하지만 하나의 목적에 집중하는 `검증 메소드 validation method`는 여전히 유용하다. 
  - 잘 만들어진 검증용 도우미 메소드는 여러 조건을 확인하는 게 아니라 입력에 대한 단 하나의 개념적 사실만 검증한다.
  - 개념적으로 단순하지만 그 개념을 검사하는 로직이 복잡한 경우라면 특히 큰 도움이 된다.

```java
// 개념적으로 단순한 검증 로직
class MyTest {
  private void assertUserHasAccessToAccount(User user, Account account) {
    for (long userId: account.getUsersWithAccess()) {
      if (user.getId() == userId) {
        return;
      }
    }
    fail(user.getName() + " cannot access " + account.getName());
  }
}
```

### (iv) 테스트 인프라 정의하기

- 가끔은 다른 테스트 스위트와도 코드를 공유하면 유용할 때가 있다.
  - 구글은 이런 종류의 코드를 `테스트 인프라 test infrastructure`라고 한다.
  - 테스트 인프라는 주로 `통합 테스트`나 `종단간 테스트 end-to-end test`에서 빛을 발한다.
- 테스트 인프라는 단일 테스트 스위트 안에서의 코드 공유보다 훨씬 신중하게 접근해야 한다.
  - 많은 곳에서 호출되는 만큼 의존하는 코드가 많기 때문이다!
  - 동작이 달라지면 다른 코드들이 깨지기 때문에 변경하기도 어렵다!
- 테스트 인프라는 독립된 제품 대우를 해줘야 하며 마땅히 자신을 검사해줄 '자체 테스트들을 갖추고 있어야' 한다.
- 물론 대부분의 테스트 인프라는 `JUnit`처럼 잘 알려진 서드파티 라이브러리 형태로 제공될 것이다.
  - 이런 류의 라이브러리는 엄청나게 많기 때문에 가능하면 조기에 전사 표준 인프라를 정하는 것이 좋다.

<br/>

# (2) 테스트 대역

- 단순한 코드라면 단위 테스트 작성이 전형 부담되지 않지만 대상 코드가 복잡해질수록 테스트를 작성하기도 어려워진다.
- 외부 서버에 요청을 보내고 응답을 받아 데이터베이스에 저장하는 함수를 검증한다고 해보자. 또 이런 테스트를 수백~수천 개 작성한다고 해보자.
  - 전체를 한 번 수행하는 데만 몇 시간이 걸리고 예기치 못한 네트워크 실패나 테스트들끼리 데이터를 덮어쓰는 등의 일이 발생하여 테스트 스위트가 불규칙적으로 실패하기 시작할 것이다.
- 이런 상황에서 테스트 대역이 아주 유용하다. `테스트 대역`은 실제 구현 대신 사용할 수 있는 객체나 함수를 말한다.

## 테스트 대역이 소프트웨어 개발에 미치는 영향

- 테스트 용이성 testability
  - 코드베이스가 테스트 대역을 사용해도 괜찮을 만큼 유연해야 한다.
  - 테스트를 염두에 두지 않고 설계된 코드는 상당히 많이 리팩토링해야 한다.
- 적용 가능성 applicability
  - 테스트 대역을 잘못 사용하면 깨지기 쉽고 복잡하고 효율도 나쁜 테스트로 전락해버린다.
  - 테스트 대역을 사용하기 보다 실제 구현을 사용하는 게 나은 경우도 있다.
- 충실성 fidelity
  - 테스트 대역이 실제 구현의 행위와 얼마나 유사한지를 말한다.
  - 테스트 대역이 실제 구현과 전혀 다르게 동작한다면 그 대역을 이용한 테스트들은 별다른 가치를 만들어내지 못한다. (대역이 항상 똑같은 결과만 반환한다면?)
  - 한편 100% 충실한 것 역시 현실적이지 않다. 테스트에 활용하려면 대역은 일반적으로 실제보다 훨씬 단순해야 한다.

## 테스트 대역 @ 구글

- 구글이 어렵게 깨우친 교훈 하나는 테스트 대역을 쉽게 만들어주는 모의 객체 프레임워크를 과용하면 위험하다는 것이다.
  - 테스트 작성은 쉬웠지만 버그는 잘 찾아내지 못했고 끊임없이 보수해야 했다.

## 기본 개념

### (i) 이어주기

- 단위 테스트를 고려해 짜인 코드를 우리는 `테스트하기 쉽다(testable)`라고 한다.
- `이어주기 seam`란 제품 코드 차원에서 테스트 대역을 활용할 수 있는 길을 터줘서 테스트하기 쉽게끔 만들어주는 걸 뜻한다.
  - 프로덕션 환경에서 이용하는 의존 대상을 다른 대상으로 교체할 수 있도록 해주면 된다.
- 대표적인 이어주기 기술로는 `의존성 주입 dependency injection(DI)`이 있다.

### (ii) 모의 객체 프레임워크

- `mocking framework`은 테스트 대역을 쉽게 만들어주는 소프트웨어 라이브러리이다.
  - 대표적으로 자바의 `Mockito`가 있다.
- `모의 객체 mock`는 구체적인 동작 방식을 테스트가 지정할 수 있는 테스트 대역을 말한다.

## 실제 구현

- 구글은 가능하다면 대상 시스템이 의존하는 실제 구현을 사용한다. (Classical Test)
- 코드가 프로덕션 환경에서와 동일하게 동작해야 테스트 충실성이 높아지는데, 실제 구현을 이용하면 자연스럽게 그렇게 된다.
- 구글은 모의 객체 중심주의는 확장하기 어렵다고 결론지었다. 모의 객체 중심주의에서는 엔지니어들이 대상 시스템을 엄격한 지침에 따라 설계해야 한다.

### (i) 격리보다 현실성을 우선하자.

- 의존하는 실제 구현을 이용하면 테스트 대상이 더 실제와 가까워진다. 문자 그대로 테스트가 실제 구현의 코드를 실행할 것이기 때문이다.
- 반대로 테스트 대역을 활용하는 테스트는 시스템을 의존 대상들로부터 격리시키므로 아무리 실행해도 시스템이 실제 의존하는 코드들은 실행되지 않습니다.
- 좋은 테스트는 구현이 어떻게 구성되었느냐의 관점이 아니라 검사할 API를 중심으로 작성되어야 한다.

### (ii) 실제 구현을 사용할지 결정하기

- 빠르고 결정적이고 의존성 구조가 간단하다면 실제 구현을 사용하는 게 좋다. 예컨대 `값 객체 value object`라면 실제 구현을 사용해야 한다.
  - 금액, 날짜, 주소, 혹은 리스트나 맵 같은 컬렉션 클래스가 대표적인 값 객체이다.
- 이보다 복잡한 코드라면 실제 구현을 사용하는 게 비현실적일 때가 많다.

### (iii) 실행시간

- 실제 구현의 수행 시간이 오래 걸릴 때는 테스트 대역이 유용할 수 있다.
- 정답은 없다. 지연되는 시간이 생산성을 얼마나 떨어뜨리는지는 엔지니어마다 다르게 느낄 것이고 실제 구현을 이용하는 테스트의 개수에 따라서도 다를 것이다.
  - 애매한 수준이라면 그냥 실제 구현을 사용하는 게 좋다.
- 테스트 병렬화도 실행 시간을 줄이는 데 효과적이다. 구글은 테스트 스위트 안의 테스트들을 쪼개 여러 서버에서 병렬로 실행하기 쉽게 해주는 인프라를 갖추고 있다.
- 잊지 말아야 할 트레이드오프가 있다. 실제 구현을 이용하면 빌드도 오래 걸린다.
  - 테스트를 위해 실제 구현은 물론 그 구현이 참조하는 코드들까지 빌드해야 하기 때문이다.

### (vi) 결정성

- 같은 버전의 시스템을 대상으로 실행하면 언제든 똑같은 결과를 내어주는 테스트를 `결정적 deterministic`인 테스트라고 한다.
  - 항상 성공하거나 실패해야 한다는 뜻이다.
- 반대로 대상 시스템은 그대로인데 결과가 달라지는 테스트를 `비결정적 nondeterministic`이라고 한다.
- 테스트에서 비결정성은 불규칙한 결과로 이어진다. 대상 시스템이 변치 않았음에도 이따금 실패할 수 있다.
  - 테스트 자체가 문제일 수 있지만 대상 시스템이 사용하는 다른 코드(의존성)가 원흉일 수 있다.
- 실제 구현은 테스트 대역보다 훨씬 복잡할 수 있어서 비결정적일 여지가 더 많다.
  - 예를 들어 실제 구현에서 멀티스레드를 이용하고 스레드 수행 순서가 대상 시스템의 결과에 영향을 준다면 테스트가 가끔씩 실패할 수 있다.
- 대역을 사용하지 못하는 상황이라면 서버의 밀폐된 인스턴스, 즉 테스트가 생애주기를 통제할 수 있는 인스턴스를 이용하는 대안도 있다.

### (v) 의존성 생성

- 실제 구현을 이용하려면 의존 대상들도 모두 생성해야 한다.
- 객체 각각을 생성하는 방법을 결정하는 데만도 시간이 꽤 걸릴 것이다.
  - 설상가상으로 이 객체들 중 단 하나의 생성자 시그니처만 바뀌어도 테스트까지 함께 수정해야 한다.
  - 유지보수할 일이 끊이질 않는다.
- Mock을 사용하면 객체 생성은 훨씬 쉽지만 무시무시한 단점들이 도사리고 있다. 따라서 실제 구현이냐 대역이냐를 결정할 때는 트레이드오프를 잘 따져봐야 한다.

## 가짜 객체

- 실제 구현을 사용할 수 없을 때는 가짜 객체가 최선일 경우가 많다.
- 가짜 객체는 실제 구현과 비슷하게 동작하기 때문에 다른 테스트 대역보다 우선적으로 활용된다.

### (i) 가짜 객체가 중요한 이유

- 가짜 객체는 빠른 것은 물론 실제 객체를 사용할 때의 단점을 제거한 채 테스트를 효과적으로 수행할 수 있게 해준다.
- 가짜 객체 하나로도 API 테스트 경험이 극적으로 좋아진다.

### (ii) 가짜 객체를 작성해야 할 때

- 가짜 객체는 실제 구현과 비슷하게 동작히기 때문에 만들려면 노력도 더 들고 도메인 지식도 더 필요하다.
- 실제 객체의 행위가 변경될 때마다 발맞춰서 갱신해야 하므로 유지보수도 신경써야 한다.
- 팀에서 가짜 객체를 만들지 판단하려면 유지보수까지 포함한 비용과 가짜 객체를 사용해서 얻는 생산성 향상 정도를 잘 저울질해야 한다.
- 유지보수할 가짜 객체 수를 줄이려면 우선 테스트에서 진짜 객체를 사용하지 못하게 만드는 근본 원인을 찾는다. 그런 다음 해당 코드만 가짜 객체로 만든다.

### (iii) 가짜 객체의 충실성

- 충실성이란 가짜 객체가 실제 구현의 행위를 얼마나 비슷하게 흉내 내느냐를 말한다. 실제 구현과 다르게 동작한다면 가짜 객체를 이용하는 테스트들은 쓸모가 없어진다.
  - 테스트에 통과하더라고 프로덕션 환경에서 실제 구현을 이용하는 시스템은 제대로 동작하지 않을 것이다.

### (iv) 가짜 객체도 테스트해야

- 실제 구현의 API 명세를 만족하는지 확인하려면 가짜 객체에도 '고유한' 테스트가 딸려 있어야 한다.
- 초기에는 올바르게 작동하던 가짜 객체라도 세월이 흘러 실제 구현이 변경되면 실제 동작과 달라지게 된다. 자체 테스트로 이런 사태를 막아줘야 한다.

## 스텁

### (i) 스텁 과용의 위험성

- 불명확해진다.
  - 대상 시스템이 어떻게 동작하는지 잘 모르는 사람에게는 이해하기 어려운 코드가 만들어질 것이다.
  - 특정 함수를 스텁으로 뭉갠 이유를 이해하기 위해 실제 시스템의 코드를 살펴보는 일이 일어나고 있다면 스텁이 적합하지 않다는 결정적인 신호다.
- 깨지기 쉬워진다.
  - 스텁을 사용하면 대상 시스템의 내부 구현 방식이 테스트에 드러난다.
- 테스트 효과가 감소한다.
  - 실제 구현과 똑같이 동작하는지 보장할 방법이 사라진다.

### (ii) 스텁이 적합한 경우

- 실제 구현을 포괄적으로 대체하기보다는 특정 함수가 특정 값을 반환하도록 하여 대상 시스템을 원하는 상태로 변경하려 할 때 제격이다.
  - 예를 들어 어떤 시스템에서는 실제 구현이나 가짜 객체로는 원하는 반환값을 얻거나 특정 오류를 일으키기가 불가능할 수 있다.
  - 스텁으로는 함수의 동작을 테스트 코드에 정의할 수 있으므로 이럴 때 원하는 결과를 쉽게 얻을 수 있다.
- 목적이 분명하게 드러나게 하려면 스텁된 함수 하나하나가 단정문들과 직접적인 연관이 있어야 한다.
  - 그래서 테스트들은 대체로 적은 수의 함수만 스텁으로 대체한다. 스텁된 함수가 많을수록 테스트의 의도는 희미해진다.
  - 스텁이 눈에 많이 띄는 것만으로도 스텁을 과용했다는 신호일 수 있다.

## 상호작용 테스트하기

- `상호작용 테스트 interaction test`는 대상 함수의 구현을 '호출하지 않으면서' 그 함수가 어떻게 호출되는지를 검증하는 기법이다.

### (i) 상호작용 테스트보다 상태 테스트를 우선하자.

- `상태 테스트 state test`란 대상 시스템을 호출하여 올바른 값을 반환하는지 혹은 대상 시스템의 상태가 올바르게 변경되었는지를 검증하는 테스트를 말한다.
- 구글은 오랜 경험을 통해 상태 테스트에 집중해야 훗날 제품과 테스트를 확장할 때 훨씬 유리하다는 사실을 깨달았다.
  - 깨지기 쉬운 테스트가 줄어들고 나중에 테스트를 변경하거나 유지보수하기 쉬워진다.
- 상호작용 테스트의 가장 큰 문제는 대상 시스템이 특정 함수가 호출되었는지만 알려줄 뿐, 올바르게 작동하는지는 말해주지 못한다는 점이다.
  - 그래서 해당 코드가 올바르게 동작한다고 '가정하고 넘어가야'한다.
  - 이와 달리 상태 테스트는 가정이 실제로 이루어졌는지까지 검증해주므로 더 유익하다.
- 두 번째 문제는 대상 시스템의 상세 구현 방식을 활용한다는 점이다.
  - 특정 함수가 호출되는지 검증하려면 대상 시스템이 그 함수를 호출할 것임을 테스트가 알아야 한다.
  - 제품 코드의 구현 방식이 바뀌면 테스트가 깨질 수 있다.
  - 그래서 어떤 구글 직원은 상호작용 테스트를 `변경 검출 테스트 change-detector test`라고 부르곤 한다.

### (ii) 상호작용 테스트가 적합한 경우

- 실제 구현이나 가짜 객체를 이용할 수 없어서 상태 테스트가 불가능한 경우, 이럴 때는 대비책으로 상호작용 테스트를 할 수도 있다.
- 함수 호출 횟수나 호출 순서가 달라지면 기대와 다르게 동작하는 경우. 상태 테스트로는 검증하기 어려운 상황이므로 상호작용 테스트가 제 역할을 할 수 있다.
- 상호작용 테스트는 상태 테스트를 완전하게 대체하지 못하므로 보완하는 역할 정도로만 사용하는 것이 좋다.

### (iii) 상호작용 테스트 모범 사례

#### 상태 변경 함수일 경우에만 상호작용 테스트를 우선 고려하자.

- 시스템이 의존 객체의 함수를 호출하면 다음의 두 경우 중 하나가 일어난다.
  - 상태 변경: 함수가 대상 시스템 바깥세상에 부수효과를 남긴다.
  - 상태 유지: 부수효과가 없는 함수다.
- 일반적으로 상호작용 테스트는 상태 변경 함수에 한해서만 수행해야 한다.
  - 상태 변경은 '코드가 다른 어딘가의 상태를 변경한다'라는 유의미한 일을 한다는 뜻이다.
- 상태 유지 함수의 상호작용 테스트는 다른 테스트와 중복될 가능성이 크다.
  - 상호작용 자체에서는 부수효과가 없으므로 정확성 측면에서 중요한 요소가 아니다.
  - 상호작용의 방식이 변경될 때마다 테스트도 수정해야 한다는 단점이 있다.

#### 너무 상세한 테스트는 피하자

- 어떤 함수들이 어떤 인수들을 받아 호출되는지를 너무 세세하게 검증하지 않는 것이 좋다. 그래야 테스트가 더 명확하고 간결해진다.

<br/>

# (3) 더 큰 테스트

- 구글은 테스트 범위라는 개념을 사용한다. 단위 테스트는 당연히 통합 테스트보다 범위가 작다.
- 범위가 가장 큰 테스트는 대체로 의존하는 외부 모듈을 직접 이용하며 테스트 대역은 거의 쓰지 않는다.
- 아래는 더 큰 테스트의 특징이다.
1. 느릴 수 있다. 구글에서 대규모 테스트의 기본 타임아웃 값은 15분이나 1시간이다. 심지어 몇 시간이나 며칠이 걸리는 테스트도 만들어 사용한다.
2. 밀폐되지 않을 수 있다. 대규모 테스트는 다른 테스트나 최종 사용자와 자원 및 트래픽을 공유하기도 한다.
3. 비결정적일 수 있다. 예컨대 밀폐되지 않은 대규모 테스트라면 다른 테스트나 사용자 상태에 영향을 받을 수 있어서 완벽히 결정적이라는 보장이 거의 불가능하다.

- 단위 테스트는 개별 함수, 객체, 모듈에 대한 확신을 심어준다.
- 반면 더 큰 테스트들은 시스템 전체가 의도대로 동작한다는 확신을 더해주는 역할을 한다.

### (i) 충실성

- 더 큰 테스트가 존재하는 이유는 충실성이다.
- 아래 순서에서 환경 충실성은 오른쪽으로 갈수록 높아진다.

```
단위 테스트 - 단일 프로세스 SUT - 격리된 SUT - 스테이징 - 프로덕션
```

### (ii) 단위 테스트가 손 대기 어려운 영역

#### 부정확한 테스트 대역

- 실제와 대역의 동작이 일치하지 않을 가능성이 생긴다.

#### 설정 문제

- 단위 테스트만으로는 설정의 호환성 문제를 검증할 수 없다.
- 결국 더 큰 테스트로 테스트해야 한다.

#### 과부하 시 나타나는 문제

- 단위테스트는 스트레스 테스트를 검증하기에 적합하지 않다.

#### 예기치 못한 동작, 입력, 부작용

- 단위 테스트의 범위는 작성자의 상상력에 갇히게 된다.
- 또한 공개 API에 명시되지 않은 행위까지 모두 확인할 가능성은 극히 낮다.

#### 창발적 행위와 '진공 효과'

- 단위 테스트가 다루는 범위는 제한적이며 이 범위 밖의 행위가 바뀌는 건 알아챌 수 없다.

### (iii) 더 큰 테스트를 만들지 않는 이유

- 더 큰 테스트는 좋은 단위 테스트가 가진 특성 3가지(`높은 신뢰성`, `빠른 속도`, `높은 확장성`) 중 하나도 갖추지 못하는 경우도 있다.
- 더 큰 테스트가 극복해야 할 과제는 두가지 더 있다.
1. 소유권 문제
  - 단위테스트는 누구의 소유인지 명확한 반면 더 큰 테스트는 다수의 단위에 걸쳐 있으므로 소유자도 많다.
  - 시간이 흐를수록 소유권은 더 모호해진다. => 유지보수는 누가 책임지고 테스트가 실패하면 누가 진단하나?
2. 표준화 문제
   - 실행 방식이 너무 다양하다.
   - 팀마다 구현 방식이 다르기 때문에 관리가 어려워진다.

# 3. 좋은 테스트의 정의란?

- 위의 자료에서 좋은 테스트에 대한 얘기 정리됨.

# 참고자료

- 구글 엔지니어는 이렇게 일한다, 타이터스 윈터스 & 톰 맨쉬렉 & 하이럼 라이트 큐레이션, 개앞매시 옮김