# Unit Testing, 블라디미르 코리코프

## 1. 단위 테스트의 목표

### 커버리지 지표

#### 커버리지 지표의 문제점

- 테스트 대상 시스템의 모든 결과를 검증한다고 보장할 수 없다.
- 외부 라이브러리의 코드 경로를 고려할 수 있는 커버리지 지표는 없다.

#### 특정 커버리지 숫자를 목표로 둔다는 것

- 커버리지 지표를 보는 가장 좋은 방법은 지표 그 자체로 보는 것이며, 목표로 여겨서는 안 된다.

> |팁| 시스템의 핵심 부분은 커버리지를 높게 두는 것이 좋다. 하지만 이 높은 수준을 요구사항으로 삼는 것은 좋지 않다.

### 무엇이 성공적인 테스트 스위트를 만들까?

- 성공적인 테스트 스위트의 특성
1. 개발 주기에 통합돼 있다.
2. 코드베이스에서 가장 중요한 부분만을 대상으로 한다.
3. 최소한의 유지비로 최대의 가치를 끌어낸다.

----

## 2. 단위 테스트란?

### 고전파와 런던파

#### 런던파 (or Mockist)

- `입자성 granularity`이 좋다. 테스트가 세밀해서 한 번에 한 클래스만 확인한다.
- 클래스 그래프가 커져도 테스트하기 쉽다.
- 테스트가 실패하면 어떤 기능이 실패했는지 확실히 알 수 있다.
- 하지만 Mock은 `취약성 fragility`이 있다. 
  - 객체의 행동이 바뀌면, 해당 객체의 행동에 대한 모든 Mock을 수정해줘야 한다. 
- 하향식 TDD
- 테스트가 구현에 더 자주 결합되는 편이다. (SUT의 구현 세부와 결합)

#### 고전파 (Classicist)

- 실제 객체를 사용하기 때문에 입자성이 부족할 순 있지만, 객체 간 상호작용을 현실에 가깝게 테스트할 수 있다.
- 큰 클래스 그래프를 테스트하기 어렵다.
- 테스트에서 버그가 발생했을 때, 어떤 부분에서 발생했는지 찾기 어렵다.
- 하지만 Mock보다 견고하다. 객체의 행동이 바뀌어도, 고전파 테스트는 실제 객체를 사용하기 때문에 테스트가 쉽게 깨지지 않는다.
- 상향식 TDD

---

## 3. 단위 테스트 구조

### 단위 테스트를 구성하는 방법

- AAA 패턴(`Arrange`, `Action`, `Assert`)
  - `Given-When-Then` 패턴과 유사하다.
- 여러 개의 준비, 실행, 결과를 만들지 말라. **하나의 테스트에는 하나의 실행과 결과만 검증하라.**
- 테스트 내의 `if`문은 피하자.
- 구절의 크기
  - 준비 구절 크다면, 같은 테스트 클래스 내에 비공개 메소드 혹은 팩토리 클래스를 통해 주빈 과정을 도출해내라. (`오브젝트 마더 Object Mother`, `테슽 데이터 빌더 Test Data Builder`)
  - 실행 구절이 한 줄 이상인 경우를 경계하라. => API에 문제가 있을 가능성이 크므로 설계를 다시 고려해보자.
  - 단일 동작 단위가 여러 결과를 낼 수 있으며, 하나의 테스트로 그 모든 결과를 평가하는 것이 좋다. 하지만 검증 구절이 너무 커지는 것은 경계하자. => 코드에서 추상화가 누락됐을 수 있다.
  - 모든 속성을 검증하는 대신 객체 클래스 내에 적절한 동등 멤버를 정의하는 것이 좋다. => 단일 검증문으로 기대값 비교 가능
- `sut` 명명을 통해 테스트 대상 시스템을 구별해도 좋다.

### 픽스처 재사용은 언제 해야 하는가?

- 테스트에서 언제 어떻게 재사용하는지 아는 것이 중요하다. => 특히 준비 구절 => 테스트 픽스처 사용

> #### 테스트 픽스처의 의미
> 1. 테스트 실행 대상 객체 (SUT)
> 2. NUnit에서 `[TestFixture]`는 테스트가 포함된 클래스를 표시하는 특성 

- 테스트 픽스처를 분별 없이 사용(픽스처 재사용 시, 생성자 사용)하면 아래와 같은 문제가 발생할 수 있다.
1. 테스트 간 결합도가 높아진다.
2. 테스트 가독성이 떨어진다.

- 테스트 클래스에 `비공개 팩토리 메소드 private factory method`를 두는 것이 더 나은 재사용법이다.

### 명명법 관습 (안티 패턴)

- 가장 유명한 관습: `[테스트 대상 메소드]_[시나리오]_[예상 결과]`
  - 동작 대신 세부 구현에 집중하게끔 부추기기 때문에 전혀 도움이 되지 않는다.
- 간단한 문구로 고객이나 도메인 전문가에게 의미 있는 방식으로 시스템 동작을 설명할 수 있게 하자.

#### 명명 지침

1. 엄격한 명명 정책을 따르지 않는다. 표현의 자유를 허용하라.
2. 문제 도메인에 익숙한 비개발자들에게 시나리오를 설명하는 것처럼 테스트 이름을 짓자. 도메인 전문가나 비즈니스 분석가가 좋은 예이다.
3. 단어를 `underscore(_)` 표시로 구분한다. 테스트 클래스의 이름을 지을 때는 밑줄 표시를 사용하지 않는다.

> #### `Describe-Context-It`
> - 코드의 행동을 설명하는 테스트 코드를 작성하도록 도와주는 패턴
> - `Describe`: 설명해야 할 테스트의 대상을 명시
> - `Context`: 테스트를 위한 특정한 상황이나 조건을 설명
> - `It`: 실제 테스트를 수행하는 부분으로, 특정한 상황에서 기대하는 결과를 검증. 즉 테스트 대상의 행위를 설명

----

## 4. 좋은 단위 테스트

### 4대 요소

1) 회귀 방지
2) 리팩터링 내성
3) 빠른 피드백
4) 유지 보수성

### 회귀 방지

- 코드를 수정한 후 기능이 의도한 대로 작동하지 않으면 이를 테스트가 알려줄 수 있어야 한다.
- 회귀 방지 지표에 대한 테스트 점수 평가
  - 테스트 중에 실행되는 코드의 양
  - 코드 복잡도
  - 코드의 도메인 유의성

> |팁| 회귀 방지 지표를 극대화하려면 테스트가 가능한 한 많은 코드를 실행하는 것을 목표로 해야 한다.

### 리팩터링 내성

- 테스트를 실패시키지 않고, 애플리케이션 코드를 리팩터링할 수 있어야 한다.
- 코드를 수정하고 아무것도 고장나지 않았는데, 테스트가 실패한다면 해당 케이스를 `거짓 양성 false positive`라고 한다. (허위 경보)

- 단위 테스트의 목표는 프로젝트 성장을 지속 가능하게 하는 것이다.
  - 메커니즘: 회귀 없이 주기적으로 리팩터링하고 새로운 기능을 추가.
  - 하지만 타당한 이유 없이 실패하면 코드 문제에 대응하는 능력과 의지가 희석된다. => 양치기 소년 => 운영 환경에 영향을 줄 수도.
  - 빈번한 거짓 양성 => 리팩터링 감소. 회귀를 피하려고 코드 변경을 최소화하기 때문이다.

#### 거짓 양성은 언제 발생하는가?

- SUT의 세부 구현 사항에 많이 결합할수록 허위 경보가 더 많이 생긴다.
- 거짓 양성을 줄일 방법은 해당 세부 구현에서 테스트를 분리하는 것뿐이다. => 사용자에게 의미 있는 결과만 확인해야 한다.

### 거짓 양성과 거짓 음성

- `거짓 양성`: 기능이 고장나지 않았는데 테스트가 실패하는 것. => 리팩터링에 영향을 준다.
- `거짓 음성`: 기능이 고장났는데, 테스트가 실패하지 않는 것. (알려지지 않은 버그) => 회귀 방지에 영향을 준다.

### 가치 있는 테스트. 이상적인 테스트.

- 위 4가지 범주 모두에서 점수를 내야 좋은 테스트라고 할 수 있다.
- 하지만 `회귀 방지`, `리팩터링 내성`, `빠른 피드백`은 상호 배타적이라 모두를 최대로 하는 것이 불가능하다.

#### `회귀 방지`, `리팩터링 내성`, `빠른 피드백`의 상호 배타성

- `e2e`는 `빠른 피드백`을 희생한다.
- 간단한 테스트는 `회귀 방지`를 희생한다.
- 깨지기 쉬운 테스트는 `리팩터링 내성`을 희생한다.

#### 결론

- **리팩터링 내성을 포기할 순 없다.**
  - 리팩터링 내성은 다른 특성과 다르게 이분법적으로 선택. 내성이 있느냐, 없느냐 이 두 가지로 갈림. => 포기한다면 완전히 포기하는 수밖에 없다. 
  - 반면 다른 특성은 일정 선에서 타협이 가능하다.
- 따라서, 테스트 스위트를 탄탄하게 만들려면 리팩터링 내성에 영향을 주는 `거짓 양성`을 제거하는 것이 최우선 과제다.

### 블랙박스 테스트와 화이트 박스 테스트

- `black-box testing`: 시스템의 내부 구조를 몰라도 시스템의 기능을 검사할 수 있는 소프트웨어 테스트 방법. 명세와 행동 중점.
  - 회귀 방지는 나쁘나, 리팩터링 내성이 있다.
- `white-box testing`: 애플리케이션의 내부 작업을 검증하는 테스트. 명세가 아닌 소스 코드에서 파생.
  - 리팩터링 내성이 좋지 않고, 회귀 방지에 좋다.
- 리팩터링 내성을 타협할 수 없는 것이므로, 블랙 박스 방식을 선택하는 것이 더 낫다.
  - 다만, 테스트를 분석할 때는 화이트 박스 방법을 사용할 수 있다.



